[
  {
    "slug": "/backend-proxy",
    "title": "Backend Proxy: Clone, Run, Connect",
    "description": "Set up the AUTOUI proxy server to securely handle LLM API keys and manage client authentication.",
    "content": "The AUTOUI proxy server is a **required backend component** that keeps your OpenRouter API key secure on the server while allowing your frontend to communicate with LLM providers.\n\n## Why Use a Proxy?\n\nThe proxy server provides:\n\n* **API Key Security**: Your OpenRouter API key stays on the server, never exposed to browsers\n* **Unified Authentication**: Single client key (shared secret) for all frontend instances\n* **Rate Limiting**: Centralized control over request rates\n* **CORS Management**: Proper CORS headers for cross-origin requests\n* **Request Logging**: Server-side logging for debugging and monitoring\n\n## Architecture\n\n```\nFrontend (Browser)\r\n  │\r\n  │ Sends: config + user message + sharedSecret\r\n  ▼\r\nProxy Server (Your Backend)\r\n  │\r\n  │ Adds: OPENROUTER_API_KEY\r\n  ▼\r\nOpenRouter API\r\n  │\r\n  │ Returns: Plan JSON\r\n  ▼\r\nProxy Server\r\n  │\r\n  │ Forwards: Plan JSON\r\n  ▼\r\nFrontend Runtime\n```\n\n## Setup Steps\n\n## Production Checklist\n\nBefore deploying to production, ensure:\n\n## Security Best Practices\n\n<Note title=\"Client Key Security\" type=\"warning\">\n  * Client keys (shared secrets) can be included in frontend code, but:\n    * Use different keys for different environments\n    * Rotate keys periodically\n    * Monitor for unauthorized usage\n    * Consider IP whitelisting for production\n</Note>\n\n## Troubleshooting\n\n### Proxy Server Won't Start\n\n* Check that `PORT` is not already in use\n* Verify `OPENROUTER_API_KEY` is set correctly\n* Check server logs for error messages\n* Ensure all dependencies are installed\n\n### Frontend Can't Connect to Proxy\n\n* Verify `proxyUrl` matches the server URL\n* Check CORS configuration allows your frontend origin\n* Ensure proxy server is running\n* Check browser console for CORS errors\n\n### Client Key Not Working\n\n* Verify the key was copied correctly (no extra spaces)\n* Ensure the key was generated with the same OpenRouter API key\n* Check proxy server logs for authentication errors\n* Regenerate the key if needed\n\n### OpenRouter API Errors\n\n* Verify your OpenRouter API key is valid\n* Check your OpenRouter account balance/limits\n* Review OpenRouter API documentation for error codes\n* Check proxy server logs for detailed error messages\n\n## Next Steps\n\n* Configure your frontend: See [Installation & Configuration](/docs/installation)\n* Add functions: See [Functions](/docs/functions)\n* Customize styling: See [ModalChat Styling](/docs/styling)\n",
    "_searchMeta": {
      "cleanContent": "the autoui proxy server is a required backend component that keeps your openrouter api key secure on the server while allowing your frontend to communicate with llm providers why use a proxy the proxy server provides: api key security: your openrouter api key stays on the server never exposed to browsers unified authentication: single client key shared secret for all frontend instances rate limiting: centralized control over request rates cors management: proper cors headers for cross-origin requests request logging: server-side logging for debugging and monitoring architecture setup steps production checklist before deploying to production ensure: security best practices client keys shared secrets can be included in frontend code but: use different keys for different environments rotate keys periodically monitor for unauthorized usage consider ip whitelisting for production troubleshooting proxy server won t start check that port is not already in use verify openrouterapikey is set correctly check server logs for error messages ensure all dependencies are installed frontend can t connect to proxy verify proxyurl matches the server url check cors configuration allows your frontend origin ensure proxy server is running check browser console for cors errors client key not working verify the key was copied correctly no extra spaces ensure the key was generated with the same openrouter api key check proxy server logs for authentication errors regenerate the key if needed openrouter api errors verify your openrouter api key is valid check your openrouter account balance limits review openrouter api documentation for error codes check proxy server logs for detailed error messages next steps configure your frontend: see installation configuration add functions: see functions customize styling: see modalchat styling",
      "headings": [
        "Why Use a Proxy?",
        "Architecture",
        "Setup Steps",
        "Production Checklist",
        "Security Best Practices",
        "Troubleshooting",
        "Next Steps"
      ],
      "keywords": [
        "proxy",
        "backend",
        "openrouter",
        "security",
        "api key",
        "client key",
        "Why Use a Proxy?",
        "Architecture",
        "Setup Steps",
        "Production Checklist",
        "Security Best Practices",
        "Troubleshooting",
        "Next Steps",
        "required backend component",
        "API Key Security",
        "Unified Authentication",
        "Rate Limiting",
        "CORS Management",
        "Request Logging",
        "Frontend (Browser)\r\n  │\r\n  │ Sends: config + user message + sharedSecret\r\n  ▼\r\nProxy Server (Your Backend)\r\n  │\r\n  │ Adds: OPENROUTER_API_KEY\r\n  ▼\r\nOpenRouter API\r\n  │\r\n  │ Returns: Plan JSON\r\n  ▼\r\nProxy Server\r\n  │\r\n  │ Forwards: Plan JSON\r\n  ▼\r\nFrontend Runtime",
        "## Setup Steps\n\n## Production Checklist\n\nBefore deploying to production, ensure:\n\n## Security Best Practices\n\n<Note title=\"Client Key Security\" type=\"warning\">\n  * Client keys (shared secrets) can be included in frontend code, but:\n    * Use different keys for different environments\n    * Rotate keys periodically\n    * Monitor for unauthorized usage\n    * Consider IP whitelisting for production\n</Note>\n\n## Troubleshooting\n\n### Proxy Server Won't Start\n\n* Check that",
        "is not already in use\n* Verify",
        "is set correctly\n* Check server logs for error messages\n* Ensure all dependencies are installed\n\n### Frontend Can't Connect to Proxy\n\n* Verify"
      ]
    }
  },
  {
    "slug": "/basic-setup/changelog",
    "title": "Changelog",
    "description": "Changelogs and improvements to the Documents projects.",
    "content": "## Added\n\n**Linting and Formatting**:\n\n* Added `pnpm run lint` and `pnpm run lint:fix` scripts to automate linting tasks.\n* Added `pnpm run format` and `pnpm run format:check` scripts to ensure consistent code formatting.\n\n**SEO Enhancements**:\n\n* Added an SEO component to MDX pages to dynamically include `keywords` and `lastModified` metadata for improved SEO generation.\n\n## Updated\n\n**Next.js Upgrade**:\n\n* Upgraded the project from **Next.js 14** to **Next.js 15**, leveraging the latest features and performance improvements.\n\n**Codebase Improvements**:\n\n* Reordered imports across the project files for better consistency and readability.\n\n**Mermaid Component**:\n\n* Fixed an ID bug that caused rendering issues when multiple Mermaid diagrams were included in MDX pages.\n* Improved initialization and rendering logic to prevent duplicate diagram rendering.\n",
    "_searchMeta": {
      "cleanContent": "added linting and formatting: added pnpm run lint and pnpm run lint:fix scripts to automate linting tasks added pnpm run format and pnpm run format:check scripts to ensure consistent code formatting seo enhancements: added an seo component to mdx pages to dynamically include keywords and lastmodified metadata for improved seo generation updated next js upgrade: upgraded the project from next js 14 to next js 15 leveraging the latest features and performance improvements codebase improvements: reordered imports across the project files for better consistency and readability mermaid component: fixed an id bug that caused rendering issues when multiple mermaid diagrams were included in mdx pages improved initialization and rendering logic to prevent duplicate diagram rendering",
      "headings": [
        "Added",
        "Updated"
      ],
      "keywords": [
        "changelog",
        "guide",
        "nextjs",
        "documents",
        "Added",
        "Updated",
        "Linting and Formatting",
        "SEO Enhancements",
        "Next.js Upgrade",
        "Next.js 14",
        "Next.js 15",
        "Codebase Improvements",
        "Mermaid Component",
        "pnpm run lint",
        "pnpm run lint:fix",
        "pnpm run format",
        "pnpm run format:check",
        "keywords",
        "lastModified"
      ]
    }
  },
  {
    "slug": "/basic-setup",
    "title": "Introduction",
    "description": "This section provides an overview of how to get started with the Documents, Next.js Document Starter Kit.",
    "content": "![Banner](/images/banner.png \"Documents\")\n\n## Documents\n\n**Documents** is a lightweight, modular starter kit built with **Next.js**, **React**, **Tailwind CSS**, and **TypeScript**. It’s designed to help you\r\nlaunch structured, professional documentation without spending time on boilerplate.\n\nWhether you're building product manuals, internal systems guides, or dev documentation, Documents gives you a clean foundation that’s easy to\r\nextend and maintain.\n\n## Why use Documents?\n\nThis kit was built to simplify how teams manage and publish documentation. It works across projects of all sizes—from a single\r\nreadme to enterprise knowledge bases.\n\nWith MDX, reusable components, and Tailwind styling, it keeps your workflow efficient without compromising flexibility.\n\nUse it for:\n\n* **Product Guides** – Setup, usage, and troubleshooting\n* **Internal Docs** – Processes, policies, and team references\n* **Technical Manuals** – APIs, SDKs, architecture walkthroughs\n\nCustomize the UI and structure to match your brand or workflow—no lock-in.\n\n## Core Features\n\n| Feature                              | Description                                                                 |\r\n| ------------------------------------ | --------------------------------------------------------------------------- |\r\n| **Write in Markdown/MDX**            | Combine Markdown with components and Mermaid.js for rich content.           |\r\n| **Flexible Navigation**              | Multi-level menus, page hierarchy, and auto-generated TOCs.                 |\r\n| **Code Support**                     | Syntax highlighting, code tabs, and one-click copy.                         |\r\n| **Search**                           | Fuzzy matching with highlight and instant results.                          |\r\n| **Responsive Design**                | Built-in light/dark mode with mobile support.                               |\r\n| **Math + Tables**                    | LaTeX rendering and clean table styling.                                    |\r\n| **SEO Defaults**                     | Preconfigured meta, Open Graph, and structured data.                        |\r\n| **AI Docs (Upcoming)**               | AI tools for smart search and content generation (coming soon).             |\n\n## Using This Kit\n\nNavigation is on the left. Pages flow from setup to advanced features, but you're free to jump around.\n\nUse the table of contents on the right to skip through sections.\n\nStart with the [Installation Guide](/docs/basic-setup/installation).\n\n## Community Support\n\nGot questions? Reach out via:\n\n* [GitHub](https://github.com/rubixvi/rubix-documents)\n* [Twitter](https://x.com/rubixstory)\n* [Facebook](https://www.facebook.com/rubixstudios)\n",
    "_searchMeta": {
      "cleanContent": "banner documents documents is a lightweight modular starter kit built with next js react tailwind css and typescript it s designed to help you launch structured professional documentation without spending time on boilerplate whether you re building product manuals internal systems guides or dev documentation documents gives you a clean foundation that s easy to extend and maintain why use documents this kit was built to simplify how teams manage and publish documentation it works across projects of all sizes from a single readme to enterprise knowledge bases with mdx reusable components and tailwind styling it keeps your workflow efficient without compromising flexibility use it for: product guides setup usage and troubleshooting internal docs processes policies and team references technical manuals apis sdks architecture walkthroughs customize the ui and structure to match your brand or workflow no lock-in core features feature description ------------------------------------ --------------------------------------------------------------------------- write in markdown mdx combine markdown with components and mermaid js for rich content flexible navigation multi-level menus page hierarchy and auto-generated tocs code support syntax highlighting code tabs and one-click copy search fuzzy matching with highlight and instant results responsive design built-in light dark mode with mobile support math tables latex rendering and clean table styling seo defaults preconfigured meta open graph and structured data ai docs upcoming ai tools for smart search and content generation coming soon using this kit navigation is on the left pages flow from setup to advanced features but you re free to jump around use the table of contents on the right to skip through sections start with the installation guide community support got questions reach out via: github twitter facebook",
      "headings": [
        "Documents",
        "Why use Documents?",
        "Core Features",
        "Using This Kit",
        "Community Support"
      ],
      "keywords": [
        "introduction",
        "guide",
        "nextjs",
        "documents",
        "Documents",
        "Why use Documents?",
        "Core Features",
        "Using This Kit",
        "Community Support",
        "Next.js",
        "React",
        "Tailwind CSS",
        "TypeScript",
        "Product Guides",
        "Internal Docs",
        "Technical Manuals",
        "Write in Markdown/MDX",
        "Flexible Navigation",
        "Code Support",
        "Search",
        "Responsive Design",
        "Math + Tables",
        "SEO Defaults",
        "AI Docs (Upcoming)"
      ]
    }
  },
  {
    "slug": "/basic-setup/installation",
    "title": "Installation",
    "description": "This guide covers the installation of Documents and how to edit your new project.",
    "content": "To install and edit the Documents, you need to have several prerequisites in place. Here's a list of all the essential pre-requisites\r\nfor setting up and working on this project.\n\n[![Deploy with Vercel](https://vercel.com/button)](https://vercel.com/new/clone?repository-url=https%3A%2F%2Fgithub.com%2Frubixvi%2Frubix-documents\\&project-name=my-documents\\&repository-name=my-documents\\&demo-title=Documents\\&demo-description=This%20Document%20Starter%20Kit%20is%20developed%20with%20Next.js%2C%20Tailwind%20CSS%20and%20TypeScript.%20It%20serves%20as%20a%20flexible%20and%20scalable%20foundation%20for%20building%20documentation%20websites%20or%20content-driven%20projects.\\&demo-url=https%3A%2F%2Frubix-documents.vercel.app%2F\\&demo-image=https%3A%2F%2Fgithub.com%2Frubixvi%2Frubix-documents%2Fblob%2Fmain%2Fpublic%2Fscreens%2Fscreen-1.png)\n\n## Prerequisites\n\n## Installation\n\n## Optional\n\n## Important Information\n\nThe project's search functionality relies on the Husky's automation to build `search-data/documents.json` ensure git commit is performed to generate this file.\n",
    "_searchMeta": {
      "cleanContent": "to install and edit the documents you need to have several prerequisites in place here s a list of all the essential pre-requisites for setting up and working on this project deploy with vercel https: vercel com new clone repository-url https 3a 2f 2fgithub com 2frubixvi 2frubix-documents project-name my-documents repository-name my-documents demo-title documents demo-description this 20document 20starter 20kit 20is 20developed 20with 20next js 2c 20tailwind 20css 20and 20typescript 20it 20serves 20as 20a 20flexible 20and 20scalable 20foundation 20for 20building 20documentation 20websites 20or 20content-driven 20projects demo-url https 3a 2f 2frubix-documents vercel app 2f demo-image https 3a 2f 2fgithub com 2frubixvi 2frubix-documents 2fblob 2fmain 2fpublic 2fscreens 2fscreen-1 png prerequisites installation optional important information the project s search functionality relies on the husky s automation to build search-data documents json ensure git commit is performed to generate this file",
      "headings": [
        "Prerequisites",
        "Installation",
        "Optional",
        "Important Information"
      ],
      "keywords": [
        "installation",
        "github",
        "node",
        "guide",
        "nextjs",
        "documents",
        "Prerequisites",
        "Installation",
        "Optional",
        "Important Information",
        "search-data/documents.json"
      ]
    }
  },
  {
    "slug": "/basic-setup/setup",
    "title": "Setup",
    "description": "Setting up and configuring your documentation project",
    "content": "Setting up your new documentation project is straightforward. Most of the essential project settings can be configured within the `settings` folder.\n\n## Settings\n\nThis section provides the core settings for your documentation site, such as defining the site's URL, site icon and title.\n\n```tsx showLineNumbers\nexport const url = \"\"                 // The URL for your documentation site\r\nexport const siteicon = \"\"            // Icon displayed next to the site name in the header\r\nexport const sitename = \"\"            // Title of your documentation site\n```\n\n## Google Tags\n\nThis section allows you to integrate Google Tag Manager into your documentation project. You can add your GTM code and configure whether it's connected.\n\n```tsx showLineNumbers\nexport const gtm = \"\"                 // Add your Google Tag Manager code here\r\nexport const gtmconnected = true      // Set to true if GTM is connected, otherwise set to false\n```\n\n## Search Engine\n\nConfigure essential SEO settings to ensure your documentation site is optimized for search engines. This includes meta descriptions, keywords and social media sharing details like images and alt text.\n\n```tsx showLineNumbers\nexport const description = \"\"         // Description of your documentation site for SEO\r\nexport const keywords = [\"\", \"\"]      // List of SEO keywords for your documentation site\r\nexport const urlimage = \"\"            // The URL of the image used when sharing on social media)\r\nexport const imagealt = \"\"            // Alt text for shared images, helpful for screen readers\r\nexport const twitterhandle = \"\"       // Your company’s Twitter handle for social sharing\n```\n\n## Footer Branding\n\nThe footer settings allow you to customize the company information displayed at the bottom of the site. You can add the company name and the URL that the name will link to.\n\n```tsx showLineNumbers\nexport const companyname = \"\"         // The company name displayed in the copyright section\r\nexport const companylink = \"\"         // The URL your company name should link to\n```\n\n## General Layout\n\nThe layout settings control the appearance and functionality of various elements of the documentation site, such as branding, the right sidebar, feedback options, table of contents, and scroll-to-top functionality.\n\n```tsx showLineNumbers\nexport const branding = true          // Set to true to display our branding elements\r\nexport const rightsidebar = true      // Set to true to enable the right sidebar with feedback, table of contents and scroll-to-top\r\nexport const feedbackedit = true      // Control to enable/disable feedback on GitHub\r\nexport const tableofcontent = true    // Control to enable/disable the generated table of contents\r\nexport const totopscroll = true       // Control to enable/disable scroll-to-top button\n```\n\n## Github Control\n\nIf your MDX files are hosted on GitHub, you can configure the project to load documents directly from there. This option can be useful for syncing documentation updates directly with your repository.\n\n```tsx showLineNumbers\nexport const loadfromgithub = false   // Set to true to load your MDX documents directly from GitHub\n```\n\n## Project Structure\n",
    "_searchMeta": {
      "cleanContent": "setting up your new documentation project is straightforward most of the essential project settings can be configured within the settings folder settings this section provides the core settings for your documentation site such as defining the site s url site icon and title google tags this section allows you to integrate google tag manager into your documentation project you can add your gtm code and configure whether it s connected search engine configure essential seo settings to ensure your documentation site is optimized for search engines this includes meta descriptions keywords and social media sharing details like images and alt text footer branding the footer settings allow you to customize the company information displayed at the bottom of the site you can add the company name and the url that the name will link to general layout the layout settings control the appearance and functionality of various elements of the documentation site such as branding the right sidebar feedback options table of contents and scroll-to-top functionality github control if your mdx files are hosted on github you can configure the project to load documents directly from there this option can be useful for syncing documentation updates directly with your repository project structure",
      "headings": [
        "Settings",
        "Google Tags",
        "Search Engine",
        "Footer Branding",
        "General Layout",
        "Github Control",
        "Project Structure"
      ],
      "keywords": [
        "setup",
        "configuration",
        "layout",
        "Google",
        "SEO",
        "nextjs",
        "documents",
        "Settings",
        "Google Tags",
        "Search Engine",
        "Footer Branding",
        "General Layout",
        "Github Control",
        "Project Structure",
        "settings",
        "tsx showLineNumbers\nexport const url = \"\"                 // The URL for your documentation site\r\nexport const siteicon = \"\"            // Icon displayed next to the site name in the header\r\nexport const sitename = \"\"            // Title of your documentation site",
        "## Google Tags\n\nThis section allows you to integrate Google Tag Manager into your documentation project. You can add your GTM code and configure whether it's connected.",
        "tsx showLineNumbers\nexport const gtm = \"\"                 // Add your Google Tag Manager code here\r\nexport const gtmconnected = true      // Set to true if GTM is connected, otherwise set to false",
        "## Search Engine\n\nConfigure essential SEO settings to ensure your documentation site is optimized for search engines. This includes meta descriptions, keywords and social media sharing details like images and alt text.",
        "tsx showLineNumbers\nexport const description = \"\"         // Description of your documentation site for SEO\r\nexport const keywords = [\"\", \"\"]      // List of SEO keywords for your documentation site\r\nexport const urlimage = \"\"            // The URL of the image used when sharing on social media)\r\nexport const imagealt = \"\"            // Alt text for shared images, helpful for screen readers\r\nexport const twitterhandle = \"\"       // Your company’s Twitter handle for social sharing",
        "## Footer Branding\n\nThe footer settings allow you to customize the company information displayed at the bottom of the site. You can add the company name and the URL that the name will link to.",
        "tsx showLineNumbers\nexport const companyname = \"\"         // The company name displayed in the copyright section\r\nexport const companylink = \"\"         // The URL your company name should link to",
        "## General Layout\n\nThe layout settings control the appearance and functionality of various elements of the documentation site, such as branding, the right sidebar, feedback options, table of contents, and scroll-to-top functionality.",
        "tsx showLineNumbers\nexport const branding = true          // Set to true to display our branding elements\r\nexport const rightsidebar = true      // Set to true to enable the right sidebar with feedback, table of contents and scroll-to-top\r\nexport const feedbackedit = true      // Control to enable/disable feedback on GitHub\r\nexport const tableofcontent = true    // Control to enable/disable the generated table of contents\r\nexport const totopscroll = true       // Control to enable/disable scroll-to-top button",
        "## Github Control\n\nIf your MDX files are hosted on GitHub, you can configure the project to load documents directly from there. This option can be useful for syncing documentation updates directly with your repository.",
        "tsx showLineNumbers\nexport const loadfromgithub = false   // Set to true to load your MDX documents directly from GitHub"
      ]
    }
  },
  {
    "slug": "/best-practices/nextjs",
    "title": "Best Practices for Next.js Apps",
    "description": "Learn the best approaches for using AUTOUI in Next.js applications, including SSR considerations, App Router patterns, and performance optimization.",
    "content": "This guide covers best practices for integrating AUTOUI into Next.js applications, with special attention to Server-Side Rendering (SSR), the App Router, and Next.js-specific patterns.\n\n## SSR Considerations\n\n### Always Use Dynamic Imports\n\nModalChat must be dynamically imported with `ssr: false` to prevent hydration mismatches:\n\n```tsx\n// app/layout.tsx or app/page.tsx\r\n\"use client\"\r\n\r\nimport dynamic from \"next/dynamic\"\r\n\r\nconst ModalChat = dynamic(\r\n  () => import(\"@autoai-ui/autoui\").then(m => m.ModalChat),\r\n  { ssr: false }  // ← Critical: Must disable SSR\r\n)\r\n\r\nexport default function Layout({ children }) {\r\n  const config = createAutoUIConfig()\r\n  \r\n  return (\r\n    <html>\r\n      <body>\r\n        {children}\r\n        <ModalChat config={config} />\r\n      </body>\r\n    </html>\r\n  )\r\n}\n```\n\n### Client Component Boundary\n\nSince ModalChat requires client-side features, ensure your config is created in a client component:\n\n```tsx\n// ✅ Good: Config in client component\r\n\"use client\"\r\n\r\nimport { useMemo } from 'react'\r\nimport { createAutoUIConfig } from '@/lib/autoui-config'\r\n\r\nexport default function ClientLayout() {\r\n  const config = useMemo(() => createAutoUIConfig(), [])\r\n  return <ModalChat config={config} />\r\n}\r\n\r\n// ❌ Bad: Config in server component\r\n// This won't work because server components can't use browser APIs\r\nexport default function ServerLayout() {\r\n  const config = createAutoUIConfig() // Error: Can't access window/localStorage\r\n  return <ModalChat config={config} />\r\n}\n```\n\n## App Router Patterns\n\n### Global ModalChat in Root Layout\n\nAdd ModalChat to your root layout for app-wide access:\n\n```tsx\n// app/layout.tsx\r\nimport { AutoUIChat } from '@/components/autoui-chat'\r\n\r\nexport default function RootLayout({ children }) {\r\n  return (\r\n    <html>\r\n      <body>\r\n        {children}\r\n        <AutoUIChat /> {/* Global chat component */}\r\n      </body>\r\n    </html>\r\n  )\r\n}\n```\n\n### Create a Wrapper Component\n\nCreate a dedicated client component wrapper:\n\n```tsx\n// components/autoui-chat.tsx\r\n\"use client\"\r\n\r\nimport { ModalChat } from \"@autoai-ui/autoui\"\r\nimport dynamic from \"next/dynamic\"\r\nimport { useMemo } from \"react\"\r\nimport { createAutoUIConfig } from \"@/lib/autoui-config\"\r\n\r\nconst DynamicModalChat = dynamic(\r\n  () => Promise.resolve(ModalChat),\r\n  { ssr: false }\r\n)\r\n\r\nexport function AutoUIChat() {\r\n  const config = useMemo(() => createAutoUIConfig(), [])\r\n  \r\n  return (\r\n    <DynamicModalChat \r\n      config={config}\r\n      style={{\r\n        position: 'fixed',\r\n        bottom: '24px',\r\n        right: '24px',\r\n        zIndex: 1000,\r\n      }}\r\n    />\r\n  )\r\n}\n```\n\n## Configuration Management\n\n### Environment Variables\n\nUse Next.js environment variables (no `NEXT_PUBLIC_` prefix needed for server, required for client):\n\n```tsx\n// .env.local\r\nNEXT_PUBLIC_PROXY_URL=http://localhost:3001\r\nNEXT_PUBLIC_SHARED_SECRET=your-secret-key\n```\n\n```tsx\n// lib/autoui-config.tsx\r\n\"use client\"\r\n\r\nexport function createAutoUIConfig(): AutoUIConfig {\r\n  return {\r\n    appId: 'my-nextjs-app',\r\n    llm: {\r\n      proxyUrl: process.env.NEXT_PUBLIC_PROXY_URL!,\r\n      sharedSecret: process.env.NEXT_PUBLIC_SHARED_SECRET,\r\n    },\r\n    // ... rest of config\r\n  }\r\n}\n```\n\n### Use Next.js Router in Functions\n\nAccess Next.js router through closure:\n\n```tsx\n// lib/autoui-config.tsx\r\n\"use client\"\r\n\r\nimport { useRouter } from 'next/navigation'\r\nimport type { AppRouterInstance } from 'next/dist/shared/lib/app-router-context.shared-runtime'\r\n\r\nexport function createAutoUIConfig(router: AppRouterInstance): AutoUIConfig {\r\n  return {\r\n    // ... other config\r\n    functions: {\r\n      navigateToPage: {\r\n        prompt: 'Navigate to a page',\r\n        callFunc: ({ path }: { path: string }) => {\r\n          router.push(path)\r\n          return { success: true, path }\r\n        },\r\n        returns: 'Navigation result',\r\n      },\r\n    },\r\n  }\r\n}\n```\n\n```tsx\n// components/autoui-chat.tsx\r\n\"use client\"\r\n\r\nimport { useRouter } from 'next/navigation'\r\nimport { useMemo } from 'react'\r\n\r\nexport function AutoUIChat() {\r\n  const router = useRouter()\r\n  const config = useMemo(() => createAutoUIConfig(router), [router])\r\n  \r\n  return <ModalChat config={config} />\r\n}\n```\n\n## Server Actions Integration\n\n### Use Server Actions for Backend Operations\n\nLeverage Next.js Server Actions for secure backend operations:\n\n```tsx\n// app/actions.ts\r\n\"use server\"\r\n\r\nexport async function fetchUserData(userId: string) {\r\n  // Server-side operation - secure, can access database\r\n  const user = await db.user.findUnique({ where: { id: userId } })\r\n  return { user }\r\n}\n```\n\n```tsx\n// lib/autoui-config.tsx\r\n\"use client\"\r\n\r\nimport { fetchUserData } from '@/app/actions'\r\n\r\nexport function createAutoUIConfig(): AutoUIConfig {\r\n  return {\r\n    // ... other config\r\n    functions: {\r\n      getUserData: {\r\n        prompt: 'Get user data',\r\n        callFunc: async ({ userId }: { userId: string }) => {\r\n          return await fetchUserData(userId)\r\n        },\r\n        returns: 'User data object',\r\n        canShareDataWithLLM: false,\r\n      },\r\n    },\r\n  }\r\n}\n```\n\n## Performance Optimization\n\n### Code Splitting\n\nModalChat is automatically code-split when using dynamic imports:\n\n```tsx\n// This automatically code-splits ModalChat\r\nconst ModalChat = dynamic(\r\n  () => import(\"@autoai-ui/autoui\").then(m => m.ModalChat),\r\n  { ssr: false }\r\n)\n```\n\n### Memoize Config with Dependencies\n\nIf your config depends on props or state, memoize it properly:\n\n```tsx\n\"use client\"\r\n\r\nimport { useMemo } from 'react'\r\nimport { useRouter } from 'next/navigation'\r\nimport { useSession } from '@/hooks/use-session'\r\n\r\nexport function AutoUIChat() {\r\n  const router = useRouter()\r\n  const session = useSession()\r\n  \r\n  const config = useMemo(() => createAutoUIConfig(router, session), [router, session])\r\n  \r\n  return <ModalChat config={config} />\r\n}\n```\n\n### Optimize Bundle Size\n\nOnly import what you need:\n\n```tsx\n// ✅ Good: Import only ModalChat\r\nimport { ModalChat } from \"@autoai-ui/autoui\"\r\n\r\n// ❌ Avoid: Importing entire library if not needed\r\nimport * as AutoUI from \"@autoai-ui/autoui\"\n```\n\n## TypeScript Best Practices\n\n### Use Proper Types\n\nImport types from the library:\n\n```tsx\nimport type { AutoUIConfig, AutoUIFunction, AutoUIComponent } from \"@autoai-ui/autoui\"\r\n\r\nexport function createAutoUIConfig(): AutoUIConfig {\r\n  // TypeScript will validate your config\r\n  return {\r\n    appId: 'my-app',\r\n    // ... rest of config\r\n  }\r\n}\n```\n\n### Type Your Functions\n\nType your function parameters and return values:\n\n```tsx\nimport type { AutoUIConfig } from \"@autoai-ui/autoui\"\r\n\r\nconst config: AutoUIConfig = {\r\n  // ... other config\r\n  functions: {\r\n    searchProducts: {\r\n      prompt: 'Search products',\r\n      callFunc: ({ query }: { query: string }): { results: any[]; count: number } => {\r\n        const results = searchProducts(query)\r\n        return { results, count: results.length }\r\n      },\r\n      returns: 'Object with results array and count',\r\n    },\r\n  },\r\n}\n```\n\n## Middleware Integration\n\n### Protect Routes with Middleware\n\nIf you need authentication, use Next.js middleware:\n\n```tsx\n// middleware.ts\r\nimport { NextResponse } from 'next/server'\r\nimport type { NextRequest } from 'next/server'\r\n\r\nexport function middleware(request: NextRequest) {\r\n  // Your auth logic\r\n  const token = request.cookies.get('token')\r\n  \r\n  if (!token && request.nextUrl.pathname.startsWith('/protected')) {\r\n    return NextResponse.redirect(new URL('/login', request.url))\r\n  }\r\n  \r\n  return NextResponse.next()\r\n}\n```\n\nYour AutoUIConfig functions can then check authentication:\n\n```tsx\nfunctions: {\r\n  getProtectedData: {\r\n    prompt: 'Get protected data',\r\n    callFunc: async () => {\r\n      // Check auth in function\r\n      const response = await fetch('/api/protected', {\r\n        headers: { 'Authorization': `Bearer ${getToken()}` }\r\n      })\r\n      return response.json()\r\n    },\r\n  },\r\n}\n```\n\n## API Routes Integration\n\n### Use API Routes for Backend Logic\n\nCreate API routes for complex backend operations:\n\n```tsx\n// app/api/search/route.ts\r\nexport async function POST(request: Request) {\r\n  const { query } = await request.json()\r\n  \r\n  // Server-side search logic\r\n  const results = await searchDatabase(query)\r\n  \r\n  return Response.json({ results })\r\n}\n```\n\n```tsx\n// lib/autoui-config.tsx\r\nfunctions: {\r\n  search: {\r\n    prompt: 'Search the database',\r\n    callFunc: async ({ query }: { query: string }) => {\r\n      const response = await fetch('/api/search', {\r\n        method: 'POST',\r\n        headers: { 'Content-Type': 'application/json' },\r\n        body: JSON.stringify({ query }),\r\n      })\r\n      return response.json()\r\n    },\r\n    returns: 'Search results',\r\n    canShareDataWithLLM: true,\r\n  },\r\n}\n```\n\n## Error Handling\n\n### Use Next.js Error Boundaries\n\nWrap ModalChat in an error boundary:\n\n```tsx\n// app/error-boundary.tsx\r\n\"use client\"\r\n\r\nimport { Component, type ReactNode } from 'react'\r\n\r\ninterface Props {\r\n  children: ReactNode\r\n}\r\n\r\ninterface State {\r\n  hasError: boolean\r\n}\r\n\r\nexport class ErrorBoundary extends Component<Props, State> {\r\n  constructor(props: Props) {\r\n    super(props)\r\n    this.state = { hasError: false }\r\n  }\r\n\r\n  static getDerivedStateFromError() {\r\n    return { hasError: true }\r\n  }\r\n\r\n  render() {\r\n    if (this.state.hasError) {\r\n      return <div>Something went wrong with the chat.</div>\r\n    }\r\n\r\n    return this.props.children\r\n  }\r\n}\n```\n\n```tsx\n// app/layout.tsx\r\nimport { ErrorBoundary } from './error-boundary'\r\nimport { AutoUIChat } from '@/components/autoui-chat'\r\n\r\nexport default function RootLayout({ children }) {\r\n  return (\r\n    <html>\r\n      <body>\r\n        {children}\r\n        <ErrorBoundary>\r\n          <AutoUIChat />\r\n        </ErrorBoundary>\r\n      </body>\r\n    </html>\r\n  )\r\n}\n```\n\n## Deployment Considerations\n\n### Environment Variables in Production\n\nSet environment variables in your deployment platform:\n\n```bash\n# Vercel\r\nvercel env add NEXT_PUBLIC_PROXY_URL\r\nvercel env add NEXT_PUBLIC_SHARED_SECRET\r\n\r\n# Other platforms\r\n# Set NEXT_PUBLIC_* variables in your platform's environment settings\n```\n\n### Build Optimization\n\nEnsure your build includes ModalChat correctly:\n\n```json\n// next.config.js\r\n/** @type {import('next').NextConfig} */\r\nconst nextConfig = {\r\n  // Your config\r\n}\r\n\r\nmodule.exports = nextConfig\n```\n\nModalChat will be automatically code-split and won't affect your initial bundle size.\n\n## Common Patterns\n\n### Route Navigation Pattern\n\n```tsx\n\"use client\"\r\n\r\nimport { useRouter, usePathname } from 'next/navigation'\r\n\r\nexport function createAutoUIConfig(router: AppRouterInstance): AutoUIConfig {\r\n  return {\r\n    // ... other config\r\n    functions: {\r\n      navigateToPage: {\r\n        prompt: 'Navigate to a page',\r\n        callFunc: ({ path }: { path: string }) => {\r\n          router.push(path)\r\n          return { success: true, currentPath: path }\r\n        },\r\n        returns: 'Navigation result',\r\n      },\r\n      getCurrentPage: {\r\n        prompt: 'Get current page path',\r\n        callFunc: () => {\r\n          return { path: window.location.pathname }\r\n        },\r\n        returns: 'Current page path',\r\n      },\r\n    },\r\n  }\r\n}\n```\n\n### Data Fetching with Server Components\n\nCombine server components with client-side ModalChat:\n\n```tsx\n// app/products/page.tsx (Server Component)\r\nasync function ProductsPage() {\r\n  const products = await fetchProducts() // Server-side fetch\r\n  \r\n  return (\r\n    <div>\r\n      <ProductsList products={products} />\r\n      <AutoUIChat /> {/* Client component */}\r\n    </div>\r\n  )\r\n}\n```\n\n## Testing\n\n### Mock Next.js Router\n\nMock the Next.js router in tests:\n\n```tsx\n// __mocks__/next/navigation.ts\r\nexport const useRouter = () => ({\r\n  push: jest.fn(),\r\n  replace: jest.fn(),\r\n  refresh: jest.fn(),\r\n})\r\n\r\nexport const usePathname = () => '/test-path'\n```\n\n## Security Best Practices\n\n### Never Expose Server Secrets\n\nServer-side secrets should never be in `NEXT_PUBLIC_*` variables:\n\n```tsx\n// ❌ Bad: Exposing server secret\r\nNEXT_PUBLIC_DATABASE_PASSWORD=secret123\r\n\r\n// ✅ Good: Server-only variable\r\nDATABASE_PASSWORD=secret123\r\n\r\n// Use in Server Actions or API Routes (not in client components)\n```\n\n### Validate Input in API Routes\n\nAlways validate input in your API routes:\n\n```tsx\n// app/api/search/route.ts\r\nimport { z } from 'zod'\r\n\r\nconst searchSchema = z.object({\r\n  query: z.string().min(1).max(100),\r\n})\r\n\r\nexport async function POST(request: Request) {\r\n  const body = await request.json()\r\n  const { query } = searchSchema.parse(body) // Validates and throws if invalid\r\n  \r\n  // Safe to use query\r\n  return Response.json({ results: await search(query) })\r\n}\n```\n\n## Next Steps\n\n* Review [React best practices](/docs/best-practices/react) for general React patterns\n* Learn about [Functions](/docs/functions) for advanced function registration\n* Check [Components](/docs/components) for component patterns\n* See [Troubleshooting](/docs/troubleshooting) for common Next.js issues\n",
    "_searchMeta": {
      "cleanContent": "this guide covers best practices for integrating autoui into next js applications with special attention to server-side rendering ssr the app router and next js-specific patterns ssr considerations always use dynamic imports modalchat must be dynamically imported with ssr: false to prevent hydration mismatches: client component boundary since modalchat requires client-side features ensure your config is created in a client component: app router patterns global modalchat in root layout add modalchat to your root layout for app-wide access: create a wrapper component create a dedicated client component wrapper: configuration management environment variables use next js environment variables no nextpublic prefix needed for server required for client : use next js router in functions access next js router through closure: server actions integration use server actions for backend operations leverage next js server actions for secure backend operations: performance optimization code splitting modalchat is automatically code-split when using dynamic imports: memoize config with dependencies if your config depends on props or state memoize it properly: optimize bundle size only import what you need: typescript best practices use proper types import types from the library: type your functions type your function parameters and return values: middleware integration protect routes with middleware if you need authentication use next js middleware: your autouiconfig functions can then check authentication: api routes integration use api routes for backend logic create api routes for complex backend operations: error handling use next js error boundaries wrap modalchat in an error boundary: deployment considerations environment variables in production set environment variables in your deployment platform: build optimization ensure your build includes modalchat correctly: modalchat will be automatically code-split and won t affect your initial bundle size common patterns route navigation pattern data fetching with server components combine server components with client-side modalchat: testing mock next js router mock the next js router in tests: security best practices never expose server secrets server-side secrets should never be in nextpublic variables: validate input in api routes always validate input in your api routes: next steps review react best practices for general react patterns learn about functions for advanced function registration check components for component patterns see troubleshooting for common next js issues",
      "headings": [
        "SSR Considerations",
        "App Router Patterns",
        "Configuration Management",
        "Server Actions Integration",
        "Performance Optimization",
        "TypeScript Best Practices",
        "Middleware Integration",
        "API Routes Integration",
        "Error Handling",
        "Deployment Considerations",
        "Common Patterns",
        "Testing",
        "Security Best Practices",
        "Next Steps"
      ],
      "keywords": [
        "best practices",
        "nextjs",
        "next.js",
        "ssr",
        "app router",
        "server components",
        "SSR Considerations",
        "App Router Patterns",
        "Configuration Management",
        "Server Actions Integration",
        "Performance Optimization",
        "TypeScript Best Practices",
        "Middleware Integration",
        "API Routes Integration",
        "Error Handling",
        "Deployment Considerations",
        "Common Patterns",
        "Testing",
        "Security Best Practices",
        "Next Steps",
        "ssr: false",
        "tsx\n// app/layout.tsx or app/page.tsx\r\n\"use client\"\r\n\r\nimport dynamic from \"next/dynamic\"\r\n\r\nconst ModalChat = dynamic(\r\n  () => import(\"@autoai-ui/autoui\").then(m => m.ModalChat),\r\n  { ssr: false }  // ← Critical: Must disable SSR\r\n)\r\n\r\nexport default function Layout({ children }) {\r\n  const config = createAutoUIConfig()\r\n  \r\n  return (\r\n    <html>\r\n      <body>\r\n        {children}\r\n        <ModalChat config={config} />\r\n      </body>\r\n    </html>\r\n  )\r\n}",
        "### Client Component Boundary\n\nSince ModalChat requires client-side features, ensure your config is created in a client component:",
        "tsx\n// ✅ Good: Config in client component\r\n\"use client\"\r\n\r\nimport { useMemo } from 'react'\r\nimport { createAutoUIConfig } from '@/lib/autoui-config'\r\n\r\nexport default function ClientLayout() {\r\n  const config = useMemo(() => createAutoUIConfig(), [])\r\n  return <ModalChat config={config} />\r\n}\r\n\r\n// ❌ Bad: Config in server component\r\n// This won't work because server components can't use browser APIs\r\nexport default function ServerLayout() {\r\n  const config = createAutoUIConfig() // Error: Can't access window/localStorage\r\n  return <ModalChat config={config} />\r\n}",
        "## App Router Patterns\n\n### Global ModalChat in Root Layout\n\nAdd ModalChat to your root layout for app-wide access:",
        "tsx\n// app/layout.tsx\r\nimport { AutoUIChat } from '@/components/autoui-chat'\r\n\r\nexport default function RootLayout({ children }) {\r\n  return (\r\n    <html>\r\n      <body>\r\n        {children}\r\n        <AutoUIChat /> {/* Global chat component */}\r\n      </body>\r\n    </html>\r\n  )\r\n}",
        "### Create a Wrapper Component\n\nCreate a dedicated client component wrapper:",
        "tsx\n// components/autoui-chat.tsx\r\n\"use client\"\r\n\r\nimport { ModalChat } from \"@autoai-ui/autoui\"\r\nimport dynamic from \"next/dynamic\"\r\nimport { useMemo } from \"react\"\r\nimport { createAutoUIConfig } from \"@/lib/autoui-config\"\r\n\r\nconst DynamicModalChat = dynamic(\r\n  () => Promise.resolve(ModalChat),\r\n  { ssr: false }\r\n)\r\n\r\nexport function AutoUIChat() {\r\n  const config = useMemo(() => createAutoUIConfig(), [])\r\n  \r\n  return (\r\n    <DynamicModalChat \r\n      config={config}\r\n      style={{\r\n        position: 'fixed',\r\n        bottom: '24px',\r\n        right: '24px',\r\n        zIndex: 1000,\r\n      }}\r\n    />\r\n  )\r\n}",
        "## Configuration Management\n\n### Environment Variables\n\nUse Next.js environment variables (no",
        "prefix needed for server, required for client):",
        "tsx\n// .env.local\r\nNEXT_PUBLIC_PROXY_URL=http://localhost:3001\r\nNEXT_PUBLIC_SHARED_SECRET=your-secret-key",
        "",
        "tsx\n// lib/autoui-config.tsx\r\n\"use client\"\r\n\r\nexport function createAutoUIConfig(): AutoUIConfig {\r\n  return {\r\n    appId: 'my-nextjs-app',\r\n    llm: {\r\n      proxyUrl: process.env.NEXT_PUBLIC_PROXY_URL!,\r\n      sharedSecret: process.env.NEXT_PUBLIC_SHARED_SECRET,\r\n    },\r\n    // ... rest of config\r\n  }\r\n}",
        "### Use Next.js Router in Functions\n\nAccess Next.js router through closure:",
        "tsx\n// lib/autoui-config.tsx\r\n\"use client\"\r\n\r\nimport { useRouter } from 'next/navigation'\r\nimport type { AppRouterInstance } from 'next/dist/shared/lib/app-router-context.shared-runtime'\r\n\r\nexport function createAutoUIConfig(router: AppRouterInstance): AutoUIConfig {\r\n  return {\r\n    // ... other config\r\n    functions: {\r\n      navigateToPage: {\r\n        prompt: 'Navigate to a page',\r\n        callFunc: ({ path }: { path: string }) => {\r\n          router.push(path)\r\n          return { success: true, path }\r\n        },\r\n        returns: 'Navigation result',\r\n      },\r\n    },\r\n  }\r\n}",
        "tsx\n// components/autoui-chat.tsx\r\n\"use client\"\r\n\r\nimport { useRouter } from 'next/navigation'\r\nimport { useMemo } from 'react'\r\n\r\nexport function AutoUIChat() {\r\n  const router = useRouter()\r\n  const config = useMemo(() => createAutoUIConfig(router), [router])\r\n  \r\n  return <ModalChat config={config} />\r\n}",
        "## Server Actions Integration\n\n### Use Server Actions for Backend Operations\n\nLeverage Next.js Server Actions for secure backend operations:",
        "tsx\n// app/actions.ts\r\n\"use server\"\r\n\r\nexport async function fetchUserData(userId: string) {\r\n  // Server-side operation - secure, can access database\r\n  const user = await db.user.findUnique({ where: { id: userId } })\r\n  return { user }\r\n}",
        "tsx\n// lib/autoui-config.tsx\r\n\"use client\"\r\n\r\nimport { fetchUserData } from '@/app/actions'\r\n\r\nexport function createAutoUIConfig(): AutoUIConfig {\r\n  return {\r\n    // ... other config\r\n    functions: {\r\n      getUserData: {\r\n        prompt: 'Get user data',\r\n        callFunc: async ({ userId }: { userId: string }) => {\r\n          return await fetchUserData(userId)\r\n        },\r\n        returns: 'User data object',\r\n        canShareDataWithLLM: false,\r\n      },\r\n    },\r\n  }\r\n}",
        "## Performance Optimization\n\n### Code Splitting\n\nModalChat is automatically code-split when using dynamic imports:",
        "tsx\n// This automatically code-splits ModalChat\r\nconst ModalChat = dynamic(\r\n  () => import(\"@autoai-ui/autoui\").then(m => m.ModalChat),\r\n  { ssr: false }\r\n)",
        "### Memoize Config with Dependencies\n\nIf your config depends on props or state, memoize it properly:",
        "tsx\n\"use client\"\r\n\r\nimport { useMemo } from 'react'\r\nimport { useRouter } from 'next/navigation'\r\nimport { useSession } from '@/hooks/use-session'\r\n\r\nexport function AutoUIChat() {\r\n  const router = useRouter()\r\n  const session = useSession()\r\n  \r\n  const config = useMemo(() => createAutoUIConfig(router, session), [router, session])\r\n  \r\n  return <ModalChat config={config} />\r\n}",
        "### Optimize Bundle Size\n\nOnly import what you need:",
        "tsx\n// ✅ Good: Import only ModalChat\r\nimport { ModalChat } from \"@autoai-ui/autoui\"\r\n\r\n// ❌ Avoid: Importing entire library if not needed\r\nimport * as AutoUI from \"@autoai-ui/autoui\"",
        "## TypeScript Best Practices\n\n### Use Proper Types\n\nImport types from the library:",
        "tsx\nimport type { AutoUIConfig, AutoUIFunction, AutoUIComponent } from \"@autoai-ui/autoui\"\r\n\r\nexport function createAutoUIConfig(): AutoUIConfig {\r\n  // TypeScript will validate your config\r\n  return {\r\n    appId: 'my-app',\r\n    // ... rest of config\r\n  }\r\n}",
        "### Type Your Functions\n\nType your function parameters and return values:",
        "tsx\nimport type { AutoUIConfig } from \"@autoai-ui/autoui\"\r\n\r\nconst config: AutoUIConfig = {\r\n  // ... other config\r\n  functions: {\r\n    searchProducts: {\r\n      prompt: 'Search products',\r\n      callFunc: ({ query }: { query: string }): { results: any[]; count: number } => {\r\n        const results = searchProducts(query)\r\n        return { results, count: results.length }\r\n      },\r\n      returns: 'Object with results array and count',\r\n    },\r\n  },\r\n}",
        "## Middleware Integration\n\n### Protect Routes with Middleware\n\nIf you need authentication, use Next.js middleware:",
        "tsx\n// middleware.ts\r\nimport { NextResponse } from 'next/server'\r\nimport type { NextRequest } from 'next/server'\r\n\r\nexport function middleware(request: NextRequest) {\r\n  // Your auth logic\r\n  const token = request.cookies.get('token')\r\n  \r\n  if (!token && request.nextUrl.pathname.startsWith('/protected')) {\r\n    return NextResponse.redirect(new URL('/login', request.url))\r\n  }\r\n  \r\n  return NextResponse.next()\r\n}",
        "Your AutoUIConfig functions can then check authentication:",
        "tsx\nfunctions: {\r\n  getProtectedData: {\r\n    prompt: 'Get protected data',\r\n    callFunc: async () => {\r\n      // Check auth in function\r\n      const response = await fetch('/api/protected', {\r\n        headers: { 'Authorization':",
        "}\r\n      })\r\n      return response.json()\r\n    },\r\n  },\r\n}",
        "## API Routes Integration\n\n### Use API Routes for Backend Logic\n\nCreate API routes for complex backend operations:",
        "tsx\n// app/api/search/route.ts\r\nexport async function POST(request: Request) {\r\n  const { query } = await request.json()\r\n  \r\n  // Server-side search logic\r\n  const results = await searchDatabase(query)\r\n  \r\n  return Response.json({ results })\r\n}",
        "tsx\n// lib/autoui-config.tsx\r\nfunctions: {\r\n  search: {\r\n    prompt: 'Search the database',\r\n    callFunc: async ({ query }: { query: string }) => {\r\n      const response = await fetch('/api/search', {\r\n        method: 'POST',\r\n        headers: { 'Content-Type': 'application/json' },\r\n        body: JSON.stringify({ query }),\r\n      })\r\n      return response.json()\r\n    },\r\n    returns: 'Search results',\r\n    canShareDataWithLLM: true,\r\n  },\r\n}",
        "## Error Handling\n\n### Use Next.js Error Boundaries\n\nWrap ModalChat in an error boundary:",
        "tsx\n// app/error-boundary.tsx\r\n\"use client\"\r\n\r\nimport { Component, type ReactNode } from 'react'\r\n\r\ninterface Props {\r\n  children: ReactNode\r\n}\r\n\r\ninterface State {\r\n  hasError: boolean\r\n}\r\n\r\nexport class ErrorBoundary extends Component<Props, State> {\r\n  constructor(props: Props) {\r\n    super(props)\r\n    this.state = { hasError: false }\r\n  }\r\n\r\n  static getDerivedStateFromError() {\r\n    return { hasError: true }\r\n  }\r\n\r\n  render() {\r\n    if (this.state.hasError) {\r\n      return <div>Something went wrong with the chat.</div>\r\n    }\r\n\r\n    return this.props.children\r\n  }\r\n}",
        "tsx\n// app/layout.tsx\r\nimport { ErrorBoundary } from './error-boundary'\r\nimport { AutoUIChat } from '@/components/autoui-chat'\r\n\r\nexport default function RootLayout({ children }) {\r\n  return (\r\n    <html>\r\n      <body>\r\n        {children}\r\n        <ErrorBoundary>\r\n          <AutoUIChat />\r\n        </ErrorBoundary>\r\n      </body>\r\n    </html>\r\n  )\r\n}",
        "## Deployment Considerations\n\n### Environment Variables in Production\n\nSet environment variables in your deployment platform:",
        "bash\n# Vercel\r\nvercel env add NEXT_PUBLIC_PROXY_URL\r\nvercel env add NEXT_PUBLIC_SHARED_SECRET\r\n\r\n# Other platforms\r\n# Set NEXT_PUBLIC_* variables in your platform's environment settings",
        "### Build Optimization\n\nEnsure your build includes ModalChat correctly:",
        "json\n// next.config.js\r\n/** @type {import('next').NextConfig} */\r\nconst nextConfig = {\r\n  // Your config\r\n}\r\n\r\nmodule.exports = nextConfig",
        "ModalChat will be automatically code-split and won't affect your initial bundle size.\n\n## Common Patterns\n\n### Route Navigation Pattern",
        "tsx\n\"use client\"\r\n\r\nimport { useRouter, usePathname } from 'next/navigation'\r\n\r\nexport function createAutoUIConfig(router: AppRouterInstance): AutoUIConfig {\r\n  return {\r\n    // ... other config\r\n    functions: {\r\n      navigateToPage: {\r\n        prompt: 'Navigate to a page',\r\n        callFunc: ({ path }: { path: string }) => {\r\n          router.push(path)\r\n          return { success: true, currentPath: path }\r\n        },\r\n        returns: 'Navigation result',\r\n      },\r\n      getCurrentPage: {\r\n        prompt: 'Get current page path',\r\n        callFunc: () => {\r\n          return { path: window.location.pathname }\r\n        },\r\n        returns: 'Current page path',\r\n      },\r\n    },\r\n  }\r\n}",
        "### Data Fetching with Server Components\n\nCombine server components with client-side ModalChat:",
        "tsx\n// app/products/page.tsx (Server Component)\r\nasync function ProductsPage() {\r\n  const products = await fetchProducts() // Server-side fetch\r\n  \r\n  return (\r\n    <div>\r\n      <ProductsList products={products} />\r\n      <AutoUIChat /> {/* Client component */}\r\n    </div>\r\n  )\r\n}",
        "## Testing\n\n### Mock Next.js Router\n\nMock the Next.js router in tests:",
        "tsx\n// __mocks__/next/navigation.ts\r\nexport const useRouter = () => ({\r\n  push: jest.fn(),\r\n  replace: jest.fn(),\r\n  refresh: jest.fn(),\r\n})\r\n\r\nexport const usePathname = () => '/test-path'",
        "## Security Best Practices\n\n### Never Expose Server Secrets\n\nServer-side secrets should never be in",
        "variables:",
        "tsx\n// ❌ Bad: Exposing server secret\r\nNEXT_PUBLIC_DATABASE_PASSWORD=secret123\r\n\r\n// ✅ Good: Server-only variable\r\nDATABASE_PASSWORD=secret123\r\n\r\n// Use in Server Actions or API Routes (not in client components)",
        "### Validate Input in API Routes\n\nAlways validate input in your API routes:",
        "tsx\n// app/api/search/route.ts\r\nimport { z } from 'zod'\r\n\r\nconst searchSchema = z.object({\r\n  query: z.string().min(1).max(100),\r\n})\r\n\r\nexport async function POST(request: Request) {\r\n  const body = await request.json()\r\n  const { query } = searchSchema.parse(body) // Validates and throws if invalid\r\n  \r\n  // Safe to use query\r\n  return Response.json({ results: await search(query) })\r\n}"
      ]
    }
  },
  {
    "slug": "/best-practices/react",
    "title": "Best Practices for React Apps",
    "description": "Learn the best approaches for using AUTOUI in React applications, including configuration, performance, and common patterns.",
    "content": "This guide covers best practices for integrating AUTOUI into React applications, helping you build robust, performant, and maintainable AI-powered features.\n\n## Configuration Management\n\n### Centralize Your Config\n\nCreate a dedicated config file to keep your AutoUIConfig organized and maintainable:\n\n```tsx\n// lib/autoui-config.ts\r\nimport { AutoUIConfig } from \"@autoai-ui/autoui\"\r\n\r\nexport function createAutoUIConfig(): AutoUIConfig {\r\n  return {\r\n    appId: 'my-react-app',\r\n    llm: {\r\n      proxyUrl: process.env.REACT_APP_PROXY_URL || 'http://localhost:3001',\r\n      sharedSecret: process.env.REACT_APP_SHARED_SECRET,\r\n      // ... rest of config\r\n    },\r\n    // ... rest of config\r\n  }\r\n}\n```\n\n### Use Environment Variables\n\nAlways use environment variables for sensitive configuration:\n\n```tsx\n// .env\r\nREACT_APP_PROXY_URL=http://localhost:3001\r\nREACT_APP_SHARED_SECRET=your-secret-key\n```\n\n```tsx\n// In your config\r\nllm: {\r\n  proxyUrl: process.env.REACT_APP_PROXY_URL!,\r\n  sharedSecret: process.env.REACT_APP_SHARED_SECRET,\r\n}\n```\n\n## Component Integration\n\n### Use Dynamic Imports for Code Splitting\n\nIf you're using a bundler that supports code splitting, dynamically import ModalChat to reduce initial bundle size:\n\n```tsx\nimport { lazy, Suspense } from 'react'\r\n\r\nconst ModalChat = lazy(() => import('@autoai-ui/autoui').then(m => ({ default: m.ModalChat })))\r\n\r\nfunction App() {\r\n  const config = createAutoUIConfig()\r\n  \r\n  return (\r\n    <div>\r\n      <Suspense fallback={<div>Loading chat...</div>}>\r\n        <ModalChat config={config} />\r\n      </Suspense>\r\n    </div>\r\n  )\r\n}\n```\n\n### Memoize Your Config\n\nIf your config is expensive to create, memoize it to avoid recreating it on every render:\n\n```tsx\nimport { useMemo } from 'react'\r\n\r\nfunction App() {\r\n  const config = useMemo(() => createAutoUIConfig(), [])\r\n  \r\n  return <ModalChat config={config} />\r\n}\n```\n\n## Function Registration\n\n### Keep Functions Pure When Possible\n\nFunctions that don't depend on external state are easier to test and reason about:\n\n```tsx\n// ✅ Good: Pure function\r\nfunctions: {\r\n  calculateTotal: {\r\n    prompt: 'Calculate the total price',\r\n    callFunc: ({ items }: { items: Array<{ price: number }> }) => {\r\n      return items.reduce((sum, item) => sum + item.price, 0)\r\n    },\r\n    returns: 'number - Total price',\r\n    canShareDataWithLLM: true,\r\n  },\r\n}\r\n\r\n// ⚠️ Acceptable: Function with side effects (when necessary)\r\nfunctions: {\r\n  navigateToPage: {\r\n    prompt: 'Navigate to a page',\r\n    callFunc: ({ path }: { path: string }) => {\r\n      window.location.href = path\r\n      return { success: true }\r\n    },\r\n    returns: 'Object with success status',\r\n  },\r\n}\n```\n\n### Always Return Values\n\nFunctions must return a value so the LLM can analyze results:\n\n```tsx\n// ✅ Good: Returns a value\r\ncallFunc: ({ query }: { query: string }) => {\r\n  const results = searchItems(query)\r\n  return { results, count: results.length }\r\n}\r\n\r\n// ❌ Bad: Returns void\r\ncallFunc: ({ query }: { query: string }) => {\r\n  searchItems(query) // Missing return!\r\n}\n```\n\n### Use canShareDataWithLLM Appropriately\n\nSet `canShareDataWithLLM: true` for functions that return safe, shareable data:\n\n```tsx\nfunctions: {\r\n  // ✅ Safe to share - public data\r\n  getPublicProducts: {\r\n    prompt: 'Get list of products',\r\n    callFunc: () => fetchProducts(),\r\n    canShareDataWithLLM: true,\r\n  },\r\n  \r\n  // ❌ Don't share - sensitive data\r\n  getUserProfile: {\r\n    prompt: 'Get user profile',\r\n    callFunc: () => getCurrentUser(),\r\n    canShareDataWithLLM: false, // Contains sensitive info\r\n  },\r\n}\n```\n\n## Component Registration\n\n### Use Proper Component Types\n\nComponents should be React `ComponentType`, which can be function components or class components:\n\n```tsx\n// ✅ Good: Function component\r\nconst MyComponent = ({ title }: { title: string }) => (\r\n  <div>{title}</div>\r\n)\r\n\r\ncomponents: {\r\n  MyComponent: {\r\n    prompt: 'Displays a title',\r\n    callComponent: MyComponent,\r\n    props: {\r\n      title: 'string - The title to display',\r\n    },\r\n  },\r\n}\r\n\r\n// ✅ Also good: Inline function component\r\ncomponents: {\r\n  MyComponent: {\r\n    prompt: 'Displays a title',\r\n    callComponent: ({ title }: { title: string }) => <div>{title}</div>,\r\n  },\r\n}\n```\n\n### Provide Default Props\n\nDefault props help the LLM understand what values to use:\n\n```tsx\ncomponents: {\r\n  ProductCard: {\r\n    prompt: 'Displays a product card',\r\n    props: {\r\n      name: 'string - Product name',\r\n      price: 'number - Product price',\r\n    },\r\n    defaults: {\r\n      name: 'Untitled Product',\r\n      price: 0,\r\n    },\r\n    callComponent: ProductCard,\r\n  },\r\n}\n```\n\n### Document Props Clearly\n\nClear prop descriptions help the LLM use components correctly:\n\n```tsx\ncomponents: {\r\n  UserProfile: {\r\n    prompt: 'Displays user profile information',\r\n    props: {\r\n      userId: 'string (required) - Unique user identifier',\r\n      showEmail: 'boolean (optional) - Whether to show email address',\r\n      theme: 'string (optional) - Color theme: \"light\" | \"dark\"',\r\n    },\r\n    callComponent: UserProfile,\r\n  },\r\n}\n```\n\n## State Management\n\n### Access React Context in Functions\n\nIf you need to access React context or state in functions, pass them through closure:\n\n```tsx\nimport { useContext } from 'react'\r\nimport { UserContext } from './contexts/UserContext'\r\n\r\nfunction App() {\r\n  const user = useContext(UserContext)\r\n  \r\n  const config = useMemo(() => ({\r\n    // ... other config\r\n    functions: {\r\n      getUserData: {\r\n        prompt: 'Get current user data',\r\n        callFunc: () => {\r\n          // Access user from closure\r\n          return { name: user.name, email: user.email }\r\n        },\r\n        returns: 'User object',\r\n        canShareDataWithLLM: false,\r\n      },\r\n    },\r\n  }), [user])\r\n  \r\n  return <ModalChat config={config} />\r\n}\n```\n\n### Use Callbacks for State Updates\n\nWhen functions need to update React state, use callbacks:\n\n```tsx\nfunction App() {\r\n  const [cart, setCart] = useState([])\r\n  \r\n  const config = useMemo(() => ({\r\n    // ... other config\r\n    functions: {\r\n      addToCart: {\r\n        prompt: 'Add item to cart',\r\n        callFunc: ({ itemId }: { itemId: string }) => {\r\n          setCart(prev => [...prev, itemId])\r\n          return { success: true, cartSize: cart.length + 1 }\r\n        },\r\n        returns: 'Object with success status and cart size',\r\n      },\r\n    },\r\n  }), [cart])\r\n  \r\n  return <ModalChat config={config} />\r\n}\n```\n\n## Performance Optimization\n\n### Limit Function Complexity\n\nKeep functions focused and performant:\n\n```tsx\n// ✅ Good: Simple, focused function\r\nfunctions: {\r\n  getItemCount: {\r\n    prompt: 'Get number of items',\r\n    callFunc: () => items.length,\r\n    returns: 'number',\r\n  },\r\n}\r\n\r\n// ⚠️ Avoid: Complex operations that block the UI\r\nfunctions: {\r\n  processLargeDataset: {\r\n    prompt: 'Process large dataset',\r\n    callFunc: async () => {\r\n      // This might block the UI - consider using Web Workers\r\n      return processData(largeDataset)\r\n    },\r\n  },\r\n}\n```\n\n### Use Appropriate maxSteps\n\nSet `maxSteps` based on your app's complexity:\n\n```tsx\nruntime: {\r\n  maxSteps: 10,  // Simple apps\r\n  // maxSteps: 20,  // Medium complexity\r\n  // maxSteps: 30,  // Complex apps with many functions\r\n}\n```\n\n### Enable Debug Logs in Development\n\nUse debug logs during development, disable in production:\n\n```tsx\nruntime: {\r\n  enableDebugLogs: process.env.NODE_ENV === 'development',\r\n}\n```\n\n## Error Handling\n\n### Provide Meaningful Error Messages\n\nFunctions should return helpful error information:\n\n```tsx\nfunctions: {\r\n  fetchData: {\r\n    prompt: 'Fetch data from API',\r\n    callFunc: async ({ url }: { url: string }) => {\r\n      try {\r\n        const response = await fetch(url)\r\n        if (!response.ok) {\r\n          return { \r\n            error: true, \r\n            message: `HTTP ${response.status}: ${response.statusText}` \r\n          }\r\n        }\r\n        return { data: await response.json() }\r\n      } catch (error) {\r\n        return { \r\n          error: true, \r\n          message: error instanceof Error ? error.message : 'Unknown error' \r\n        }\r\n      }\r\n    },\r\n    returns: 'Object with data or error information',\r\n  },\r\n}\n```\n\n### Configure Error Handling\n\nSet appropriate error handling based on your needs:\n\n```tsx\nruntime: {\r\n  errorHandling: {\r\n    showToUser: true,        // Show errors in chat UI\r\n    retryOnFail: false,     // Don't auto-retry (user can retry manually)\r\n  },\r\n}\n```\n\n## Testing\n\n### Mock Functions for Testing\n\nCreate mock implementations for testing:\n\n```tsx\n// __mocks__/autoui-config.ts\r\nexport function createAutoUIConfig(): AutoUIConfig {\r\n  return {\r\n    appId: 'test-app',\r\n    llm: {\r\n      proxyUrl: 'http://localhost:3001',\r\n    },\r\n    runtime: {\r\n      validateLLMOutput: false, // Disable validation in tests\r\n      enableDebugLogs: false,\r\n    },\r\n    functions: {\r\n      // Mock functions for testing\r\n      testFunction: {\r\n        prompt: 'Test function',\r\n        callFunc: () => ({ test: true }),\r\n      },\r\n    },\r\n  }\r\n}\n```\n\n## Security Best Practices\n\n### Never Expose Secrets\n\nNever hardcode API keys or secrets in your config:\n\n```tsx\n// ❌ Bad: Hardcoded secret\r\nllm: {\r\n  proxyUrl: 'http://localhost:3001',\r\n  sharedSecret: 'my-secret-key', // Don't do this!\r\n}\r\n\r\n// ✅ Good: Use environment variables\r\nllm: {\r\n  proxyUrl: process.env.REACT_APP_PROXY_URL!,\r\n  sharedSecret: process.env.REACT_APP_SHARED_SECRET,\r\n}\n```\n\n### Validate User Input in Functions\n\nAlways validate and sanitize user input:\n\n```tsx\nfunctions: {\r\n  searchItems: {\r\n    prompt: 'Search for items',\r\n    callFunc: ({ query }: { query: string }) => {\r\n      // Validate input\r\n      if (!query || typeof query !== 'string') {\r\n        return { error: 'Invalid query' }\r\n      }\r\n      \r\n      // Sanitize (remove dangerous characters)\r\n      const sanitized = query.replace(/[<>]/g, '')\r\n      \r\n      return searchItems(sanitized)\r\n    },\r\n  },\r\n}\n```\n\n## Common Patterns\n\n### Navigation Pattern\n\n```tsx\nimport { useNavigate } from 'react-router-dom'\r\n\r\nfunction App() {\r\n  const navigate = useNavigate()\r\n  \r\n  const config = useMemo(() => ({\r\n    // ... other config\r\n    functions: {\r\n      navigateToPage: {\r\n        prompt: 'Navigate to a page',\r\n        callFunc: ({ path }: { path: string }) => {\r\n          navigate(path)\r\n          return { success: true, path }\r\n        },\r\n        returns: 'Navigation result',\r\n      },\r\n    },\r\n  }), [navigate])\r\n  \r\n  return <ModalChat config={config} />\r\n}\n```\n\n### Data Fetching Pattern\n\n```tsx\nfunctions: {\r\n  fetchUserData: {\r\n    prompt: 'Fetch user data from API',\r\n    callFunc: async ({ userId }: { userId: string }) => {\r\n      const response = await fetch(`/api/users/${userId}`)\r\n      if (!response.ok) {\r\n        return { error: 'Failed to fetch user' }\r\n      }\r\n      const data = await response.json()\r\n      return { user: data, fetchedAt: new Date().toISOString() }\r\n    },\r\n    returns: 'User data object',\r\n    canShareDataWithLLM: false, // User data is sensitive\r\n  },\r\n}\n```\n\n## Next Steps\n\n* Learn about [Next.js best practices](/docs/best-practices/nextjs) for server-side rendering\n* Review [Functions documentation](/docs/functions) for advanced function patterns\n* Check [Components documentation](/docs/components) for component registration details\n",
    "_searchMeta": {
      "cleanContent": "this guide covers best practices for integrating autoui into react applications helping you build robust performant and maintainable ai-powered features configuration management centralize your config create a dedicated config file to keep your autouiconfig organized and maintainable: use environment variables always use environment variables for sensitive configuration: component integration use dynamic imports for code splitting if you re using a bundler that supports code splitting dynamically import modalchat to reduce initial bundle size: memoize your config if your config is expensive to create memoize it to avoid recreating it on every render: function registration keep functions pure when possible functions that don t depend on external state are easier to test and reason about: always return values functions must return a value so the llm can analyze results: use cansharedatawithllm appropriately set cansharedatawithllm: true for functions that return safe shareable data: component registration use proper component types components should be react componenttype which can be function components or class components: provide default props default props help the llm understand what values to use: document props clearly clear prop descriptions help the llm use components correctly: state management access react context in functions if you need to access react context or state in functions pass them through closure: use callbacks for state updates when functions need to update react state use callbacks: performance optimization limit function complexity keep functions focused and performant: use appropriate maxsteps set maxsteps based on your app s complexity: enable debug logs in development use debug logs during development disable in production: error handling provide meaningful error messages functions should return helpful error information: configure error handling set appropriate error handling based on your needs: testing mock functions for testing create mock implementations for testing: security best practices never expose secrets never hardcode api keys or secrets in your config: validate user input in functions always validate and sanitize user input: common patterns navigation pattern data fetching pattern next steps learn about next js best practices for server-side rendering review functions documentation for advanced function patterns check components documentation for component registration details",
      "headings": [
        "Configuration Management",
        "Component Integration",
        "Function Registration",
        "Component Registration",
        "State Management",
        "Performance Optimization",
        "Error Handling",
        "Testing",
        "Security Best Practices",
        "Common Patterns",
        "Next Steps"
      ],
      "keywords": [
        "best practices",
        "react",
        "patterns",
        "performance",
        "configuration",
        "Configuration Management",
        "Component Integration",
        "Function Registration",
        "Component Registration",
        "State Management",
        "Performance Optimization",
        "Error Handling",
        "Testing",
        "Security Best Practices",
        "Common Patterns",
        "Next Steps",
        "tsx\n// lib/autoui-config.ts\r\nimport { AutoUIConfig } from \"@autoai-ui/autoui\"\r\n\r\nexport function createAutoUIConfig(): AutoUIConfig {\r\n  return {\r\n    appId: 'my-react-app',\r\n    llm: {\r\n      proxyUrl: process.env.REACT_APP_PROXY_URL || 'http://localhost:3001',\r\n      sharedSecret: process.env.REACT_APP_SHARED_SECRET,\r\n      // ... rest of config\r\n    },\r\n    // ... rest of config\r\n  }\r\n}",
        "### Use Environment Variables\n\nAlways use environment variables for sensitive configuration:",
        "tsx\n// .env\r\nREACT_APP_PROXY_URL=http://localhost:3001\r\nREACT_APP_SHARED_SECRET=your-secret-key",
        "",
        "tsx\n// In your config\r\nllm: {\r\n  proxyUrl: process.env.REACT_APP_PROXY_URL!,\r\n  sharedSecret: process.env.REACT_APP_SHARED_SECRET,\r\n}",
        "## Component Integration\n\n### Use Dynamic Imports for Code Splitting\n\nIf you're using a bundler that supports code splitting, dynamically import ModalChat to reduce initial bundle size:",
        "tsx\nimport { lazy, Suspense } from 'react'\r\n\r\nconst ModalChat = lazy(() => import('@autoai-ui/autoui').then(m => ({ default: m.ModalChat })))\r\n\r\nfunction App() {\r\n  const config = createAutoUIConfig()\r\n  \r\n  return (\r\n    <div>\r\n      <Suspense fallback={<div>Loading chat...</div>}>\r\n        <ModalChat config={config} />\r\n      </Suspense>\r\n    </div>\r\n  )\r\n}",
        "### Memoize Your Config\n\nIf your config is expensive to create, memoize it to avoid recreating it on every render:",
        "tsx\nimport { useMemo } from 'react'\r\n\r\nfunction App() {\r\n  const config = useMemo(() => createAutoUIConfig(), [])\r\n  \r\n  return <ModalChat config={config} />\r\n}",
        "## Function Registration\n\n### Keep Functions Pure When Possible\n\nFunctions that don't depend on external state are easier to test and reason about:",
        "tsx\n// ✅ Good: Pure function\r\nfunctions: {\r\n  calculateTotal: {\r\n    prompt: 'Calculate the total price',\r\n    callFunc: ({ items }: { items: Array<{ price: number }> }) => {\r\n      return items.reduce((sum, item) => sum + item.price, 0)\r\n    },\r\n    returns: 'number - Total price',\r\n    canShareDataWithLLM: true,\r\n  },\r\n}\r\n\r\n// ⚠️ Acceptable: Function with side effects (when necessary)\r\nfunctions: {\r\n  navigateToPage: {\r\n    prompt: 'Navigate to a page',\r\n    callFunc: ({ path }: { path: string }) => {\r\n      window.location.href = path\r\n      return { success: true }\r\n    },\r\n    returns: 'Object with success status',\r\n  },\r\n}",
        "### Always Return Values\n\nFunctions must return a value so the LLM can analyze results:",
        "tsx\n// ✅ Good: Returns a value\r\ncallFunc: ({ query }: { query: string }) => {\r\n  const results = searchItems(query)\r\n  return { results, count: results.length }\r\n}\r\n\r\n// ❌ Bad: Returns void\r\ncallFunc: ({ query }: { query: string }) => {\r\n  searchItems(query) // Missing return!\r\n}",
        "### Use canShareDataWithLLM Appropriately\n\nSet",
        "for functions that return safe, shareable data:",
        "tsx\nfunctions: {\r\n  // ✅ Safe to share - public data\r\n  getPublicProducts: {\r\n    prompt: 'Get list of products',\r\n    callFunc: () => fetchProducts(),\r\n    canShareDataWithLLM: true,\r\n  },\r\n  \r\n  // ❌ Don't share - sensitive data\r\n  getUserProfile: {\r\n    prompt: 'Get user profile',\r\n    callFunc: () => getCurrentUser(),\r\n    canShareDataWithLLM: false, // Contains sensitive info\r\n  },\r\n}",
        "## Component Registration\n\n### Use Proper Component Types\n\nComponents should be React",
        ", which can be function components or class components:",
        "tsx\n// ✅ Good: Function component\r\nconst MyComponent = ({ title }: { title: string }) => (\r\n  <div>{title}</div>\r\n)\r\n\r\ncomponents: {\r\n  MyComponent: {\r\n    prompt: 'Displays a title',\r\n    callComponent: MyComponent,\r\n    props: {\r\n      title: 'string - The title to display',\r\n    },\r\n  },\r\n}\r\n\r\n// ✅ Also good: Inline function component\r\ncomponents: {\r\n  MyComponent: {\r\n    prompt: 'Displays a title',\r\n    callComponent: ({ title }: { title: string }) => <div>{title}</div>,\r\n  },\r\n}",
        "### Provide Default Props\n\nDefault props help the LLM understand what values to use:",
        "tsx\ncomponents: {\r\n  ProductCard: {\r\n    prompt: 'Displays a product card',\r\n    props: {\r\n      name: 'string - Product name',\r\n      price: 'number - Product price',\r\n    },\r\n    defaults: {\r\n      name: 'Untitled Product',\r\n      price: 0,\r\n    },\r\n    callComponent: ProductCard,\r\n  },\r\n}",
        "### Document Props Clearly\n\nClear prop descriptions help the LLM use components correctly:",
        "tsx\ncomponents: {\r\n  UserProfile: {\r\n    prompt: 'Displays user profile information',\r\n    props: {\r\n      userId: 'string (required) - Unique user identifier',\r\n      showEmail: 'boolean (optional) - Whether to show email address',\r\n      theme: 'string (optional) - Color theme: \"light\" | \"dark\"',\r\n    },\r\n    callComponent: UserProfile,\r\n  },\r\n}",
        "## State Management\n\n### Access React Context in Functions\n\nIf you need to access React context or state in functions, pass them through closure:",
        "tsx\nimport { useContext } from 'react'\r\nimport { UserContext } from './contexts/UserContext'\r\n\r\nfunction App() {\r\n  const user = useContext(UserContext)\r\n  \r\n  const config = useMemo(() => ({\r\n    // ... other config\r\n    functions: {\r\n      getUserData: {\r\n        prompt: 'Get current user data',\r\n        callFunc: () => {\r\n          // Access user from closure\r\n          return { name: user.name, email: user.email }\r\n        },\r\n        returns: 'User object',\r\n        canShareDataWithLLM: false,\r\n      },\r\n    },\r\n  }), [user])\r\n  \r\n  return <ModalChat config={config} />\r\n}",
        "### Use Callbacks for State Updates\n\nWhen functions need to update React state, use callbacks:",
        "tsx\nfunction App() {\r\n  const [cart, setCart] = useState([])\r\n  \r\n  const config = useMemo(() => ({\r\n    // ... other config\r\n    functions: {\r\n      addToCart: {\r\n        prompt: 'Add item to cart',\r\n        callFunc: ({ itemId }: { itemId: string }) => {\r\n          setCart(prev => [...prev, itemId])\r\n          return { success: true, cartSize: cart.length + 1 }\r\n        },\r\n        returns: 'Object with success status and cart size',\r\n      },\r\n    },\r\n  }), [cart])\r\n  \r\n  return <ModalChat config={config} />\r\n}",
        "## Performance Optimization\n\n### Limit Function Complexity\n\nKeep functions focused and performant:",
        "tsx\n// ✅ Good: Simple, focused function\r\nfunctions: {\r\n  getItemCount: {\r\n    prompt: 'Get number of items',\r\n    callFunc: () => items.length,\r\n    returns: 'number',\r\n  },\r\n}\r\n\r\n// ⚠️ Avoid: Complex operations that block the UI\r\nfunctions: {\r\n  processLargeDataset: {\r\n    prompt: 'Process large dataset',\r\n    callFunc: async () => {\r\n      // This might block the UI - consider using Web Workers\r\n      return processData(largeDataset)\r\n    },\r\n  },\r\n}",
        "### Use Appropriate maxSteps\n\nSet",
        "based on your app's complexity:",
        "tsx\nruntime: {\r\n  maxSteps: 10,  // Simple apps\r\n  // maxSteps: 20,  // Medium complexity\r\n  // maxSteps: 30,  // Complex apps with many functions\r\n}",
        "### Enable Debug Logs in Development\n\nUse debug logs during development, disable in production:",
        "tsx\nruntime: {\r\n  enableDebugLogs: process.env.NODE_ENV === 'development',\r\n}",
        "## Error Handling\n\n### Provide Meaningful Error Messages\n\nFunctions should return helpful error information:",
        "tsx\nfunctions: {\r\n  fetchData: {\r\n    prompt: 'Fetch data from API',\r\n    callFunc: async ({ url }: { url: string }) => {\r\n      try {\r\n        const response = await fetch(url)\r\n        if (!response.ok) {\r\n          return { \r\n            error: true, \r\n            message:",
        "}\r\n        }\r\n        return { data: await response.json() }\r\n      } catch (error) {\r\n        return { \r\n          error: true, \r\n          message: error instanceof Error ? error.message : 'Unknown error' \r\n        }\r\n      }\r\n    },\r\n    returns: 'Object with data or error information',\r\n  },\r\n}",
        "### Configure Error Handling\n\nSet appropriate error handling based on your needs:",
        "tsx\nruntime: {\r\n  errorHandling: {\r\n    showToUser: true,        // Show errors in chat UI\r\n    retryOnFail: false,     // Don't auto-retry (user can retry manually)\r\n  },\r\n}",
        "## Testing\n\n### Mock Functions for Testing\n\nCreate mock implementations for testing:",
        "tsx\n// __mocks__/autoui-config.ts\r\nexport function createAutoUIConfig(): AutoUIConfig {\r\n  return {\r\n    appId: 'test-app',\r\n    llm: {\r\n      proxyUrl: 'http://localhost:3001',\r\n    },\r\n    runtime: {\r\n      validateLLMOutput: false, // Disable validation in tests\r\n      enableDebugLogs: false,\r\n    },\r\n    functions: {\r\n      // Mock functions for testing\r\n      testFunction: {\r\n        prompt: 'Test function',\r\n        callFunc: () => ({ test: true }),\r\n      },\r\n    },\r\n  }\r\n}",
        "## Security Best Practices\n\n### Never Expose Secrets\n\nNever hardcode API keys or secrets in your config:",
        "tsx\n// ❌ Bad: Hardcoded secret\r\nllm: {\r\n  proxyUrl: 'http://localhost:3001',\r\n  sharedSecret: 'my-secret-key', // Don't do this!\r\n}\r\n\r\n// ✅ Good: Use environment variables\r\nllm: {\r\n  proxyUrl: process.env.REACT_APP_PROXY_URL!,\r\n  sharedSecret: process.env.REACT_APP_SHARED_SECRET,\r\n}",
        "### Validate User Input in Functions\n\nAlways validate and sanitize user input:",
        "tsx\nfunctions: {\r\n  searchItems: {\r\n    prompt: 'Search for items',\r\n    callFunc: ({ query }: { query: string }) => {\r\n      // Validate input\r\n      if (!query || typeof query !== 'string') {\r\n        return { error: 'Invalid query' }\r\n      }\r\n      \r\n      // Sanitize (remove dangerous characters)\r\n      const sanitized = query.replace(/[<>]/g, '')\r\n      \r\n      return searchItems(sanitized)\r\n    },\r\n  },\r\n}",
        "## Common Patterns\n\n### Navigation Pattern",
        "tsx\nimport { useNavigate } from 'react-router-dom'\r\n\r\nfunction App() {\r\n  const navigate = useNavigate()\r\n  \r\n  const config = useMemo(() => ({\r\n    // ... other config\r\n    functions: {\r\n      navigateToPage: {\r\n        prompt: 'Navigate to a page',\r\n        callFunc: ({ path }: { path: string }) => {\r\n          navigate(path)\r\n          return { success: true, path }\r\n        },\r\n        returns: 'Navigation result',\r\n      },\r\n    },\r\n  }), [navigate])\r\n  \r\n  return <ModalChat config={config} />\r\n}",
        "### Data Fetching Pattern",
        "tsx\nfunctions: {\r\n  fetchUserData: {\r\n    prompt: 'Fetch user data from API',\r\n    callFunc: async ({ userId }: { userId: string }) => {\r\n      const response = await fetch(",
        ")\r\n      if (!response.ok) {\r\n        return { error: 'Failed to fetch user' }\r\n      }\r\n      const data = await response.json()\r\n      return { user: data, fetchedAt: new Date().toISOString() }\r\n    },\r\n    returns: 'User data object',\r\n    canShareDataWithLLM: false, // User data is sensitive\r\n  },\r\n}"
      ]
    }
  },
  {
    "slug": "/components",
    "title": "Components Registry",
    "description": "Register React components for generative UI. Enable the AI assistant to render custom components dynamically.",
    "content": "The Components Registry allows you to register React components that the AI assistant can render dynamically. This enables **generative UI**—the assistant can compose new interfaces on the fly based on user requests.\n\n## How Components Work\n\nWhen you register a component, the LLM can:\n\n1. Decide to render it based on user requests\n2. Pass props based on the component's `defaults` and `prompt`\n3. Compose multiple components together\n4. Update component props through conversation\n\n## Component Structure\n\nEach component in your config has this structure:\n\n```tsx\ncomponents: {\r\n  ComponentName: {\r\n    prompt: 'Description of what this component displays...',\r\n    defaults: {\r\n      propName: 'default value',\r\n    },\r\n    callComponent: (props) => <YourComponent {...props} />,\r\n    category: 'optional-category',\r\n  },\r\n}\n```\n\n## Key Concepts\n\n### Prompt\n\nThe `prompt` field describes what the component does and when to render it:\n\n```tsx\nprompt: 'Shows cart items with quantities and total; triggers checkout when requested.'\n```\n\nThe LLM uses this to decide:\n\n* When to render the component\n* What props to pass\n* How to describe it to the user\n\n### Defaults\n\nThe `defaults` object provides example/default props that help the LLM understand the component's structure:\n\n```tsx\ndefaults: {\r\n  items: [\r\n    { id: '1', name: 'Beige Coat', price: 89.99, quantity: 2 },\r\n    { id: '2', name: 'Denim Jacket', price: 69.99, quantity: 1 },\r\n  ],\r\n}\n```\n\n**Purpose:**\n\n* Shows the LLM what props the component expects\n* Provides example data structure\n* Helps the LLM generate appropriate props\n\n### callComponent\n\nA function that returns your React component with the provided props:\n\n```tsx\ncallComponent: (props) => <CartSummary {...props} />\n```\n\n**Important:**\n\n* Must return a valid React element\n* Props come from the LLM (based on defaults and prompt)\n* You can transform or validate props before passing them\n\n### Category\n\nAn optional string that groups related components:\n\n```tsx\ncategory: 'checkout' // Groups with other checkout-related components\n```\n\nUseful for organization and helping the LLM understand component relationships.\n\n## Example: E-Commerce Components\n\nHere's a complete example from an e-commerce app:\n\n```tsx\ncomponents: {\r\n  CartSummary: {\r\n    prompt: 'Shows cart items with quantities and total; triggers checkout when requested.',\r\n    defaults: {\r\n      items: [\r\n        { id: '1', name: 'Beige Coat', price: 89.99, quantity: 2 },\r\n        { id: '2', name: 'Denim Jacket', price: 69.99, quantity: 1 },\r\n      ],\r\n    },\r\n    callComponent: (props) => <CartSummary {...props} />,\r\n    category: 'checkout',\r\n  },\r\n\r\n  ProductCard: {\r\n    prompt: 'Displays a single product with image, name, price, and add-to-cart button.',\r\n    defaults: {\r\n      id: '1',\r\n      name: 'Product Name',\r\n      price: 29.99,\r\n      image: 'https://example.com/product.jpg',\r\n      description: 'Product description',\r\n    },\r\n    callComponent: (props) => <ProductCard {...props} />,\r\n    category: 'products',\r\n  },\r\n\r\n  ProductGrid: {\r\n    prompt: 'Displays a grid of product cards. Use when showing multiple products.',\r\n    defaults: {\r\n      products: [\r\n        { id: '1', name: 'Product 1', price: 29.99 },\r\n        { id: '2', name: 'Product 2', price: 39.99 },\r\n      ],\r\n    },\r\n    callComponent: (props) => <ProductGrid {...props} />,\r\n    category: 'products',\r\n  },\r\n}\n```\n\n## Component Patterns\n\n### Display Components\n\nComponents that show data:\n\n```tsx\nUserProfile: {\r\n  prompt: 'Displays user profile information: name, avatar, email, and stats.',\r\n  defaults: {\r\n    name: 'John Doe',\r\n    email: 'john@example.com',\r\n    avatar: 'https://example.com/avatar.jpg',\r\n    stats: { posts: 42, followers: 123 },\r\n  },\r\n  callComponent: (props) => <UserProfile {...props} />,\r\n}\n```\n\n### Form Components\n\nComponents that collect input:\n\n```tsx\nTaskForm: {\r\n  prompt: 'Displays a form for creating or editing a task. Includes fields for title, description, status, priority, and due date.',\r\n  defaults: {\r\n    title: '',\r\n    description: '',\r\n    status: 'todo',\r\n    priority: 'medium',\r\n    dueDate: null,\r\n  },\r\n  callComponent: (props) => <TaskForm {...props} />,\r\n  category: 'forms',\r\n}\n```\n\n### Interactive Components\n\nComponents that trigger actions:\n\n```tsx\nActionButton: {\r\n  prompt: 'A button that triggers an action when clicked. Use for primary actions like \"Save\", \"Submit\", \"Delete\".',\r\n  defaults: {\r\n    label: 'Click me',\r\n    variant: 'primary',\r\n    onClick: () => {},\r\n  },\r\n  callComponent: (props) => <ActionButton {...props} />,\r\n  category: 'actions',\r\n}\n```\n\n### Layout Components\n\nComponents that organize other components:\n\n```tsx\nDashboard: {\r\n  prompt: 'A dashboard layout with sidebar, header, and main content area. Can contain widgets and charts.',\r\n  defaults: {\r\n    sidebarItems: [],\r\n    headerTitle: 'Dashboard',\r\n    widgets: [],\r\n  },\r\n  callComponent: (props) => <Dashboard {...props} />,\r\n  category: 'layout',\r\n}\n```\n\n## Props Handling\n\n### Validating Props\n\nValidate and transform props before passing them to your component:\n\n```tsx\ncallComponent: (props) => {\r\n  // Validate required props\r\n  if (!props.items || !Array.isArray(props.items)) {\r\n    return <div>Error: Invalid items prop</div>\r\n  }\r\n\r\n  // Transform props\r\n  const transformedProps = {\r\n    ...props,\r\n    items: props.items.map(item => ({\r\n      ...item,\r\n      total: item.price * item.quantity,\r\n    })),\r\n  }\r\n\r\n  return <CartSummary {...transformedProps} />\r\n}\n```\n\n### Default Props\n\nProvide fallback values:\n\n```tsx\ncallComponent: (props) => {\r\n  const safeProps = {\r\n    title: props.title || 'Untitled',\r\n    items: props.items || [],\r\n    onAction: props.onAction || (() => {}),\r\n  }\r\n  return <MyComponent {...safeProps} />\r\n}\n```\n\n## Component Categories\n\nUse categories to organize related components:\n\n```tsx\n// Navigation\r\ncomponents: {\r\n  NavBar: { category: 'navigation', /* ... */ },\r\n  Sidebar: { category: 'navigation', /* ... */ },\r\n}\r\n\r\n// Data Display\r\ncomponents: {\r\n  Table: { category: 'data', /* ... */ },\r\n  Chart: { category: 'data', /* ... */ },\r\n  List: { category: 'data', /* ... */ },\r\n}\r\n\r\n// Forms\r\ncomponents: {\r\n  TextInput: { category: 'forms', /* ... */ },\r\n  Select: { category: 'forms', /* ... */ },\r\n  Checkbox: { category: 'forms', /* ... */ },\r\n}\n```\n\n## Best Practices\n\n<Note title=\"Realistic Defaults\" type=\"warning\">\n  Provide realistic default props that match your actual data structure. This helps the LLM generate appropriate props.\n</Note>\n\n<Note title=\"Error Boundaries\" type=\"warning\">\n  Consider wrapping components in error boundaries to handle rendering errors gracefully:\n\n  ```tsx\n  callComponent: (props) => (\r\n    <ErrorBoundary>\r\n      <YourComponent {...props} />\r\n    </ErrorBoundary>\r\n  )\n  ```\n</Note>\n\n## Combining Components and Functions\n\nComponents can work together with functions:\n\n```tsx\n// Function to fetch data\r\nfunctions: {\r\n  getProducts: {\r\n    prompt: 'Fetch list of products.',\r\n    callFunc: () => products,\r\n    returns: 'Product[]',\r\n  },\r\n}\r\n\r\n// Component to display data\r\ncomponents: {\r\n  ProductGrid: {\r\n    prompt: 'Display a grid of products.',\r\n    defaults: {\r\n      products: [],\r\n    },\r\n    callComponent: (props) => <ProductGrid {...props} />,\r\n  },\r\n}\n```\n\nThe LLM can:\n\n1. Call `getProducts()` to fetch data\n2. Render `ProductGrid` with the fetched products\n3. Compose multiple components together\n\n## Limitations\n\n* Components are rendered in the chat context (inside ModalChat)\n* Complex layouts may be limited by chat UI constraints\n* Props are generated by the LLM, so validation is important\n* Performance: Many components may impact chat performance\n\n## Next Steps\n\n* Learn about functions: [Functions](/docs/functions)\n* Configure runtime: [Runtime & Debugging](/docs/runtime)\n* Customize styling: [ModalChat Styling](/docs/styling)\n",
    "_searchMeta": {
      "cleanContent": "the components registry allows you to register react components that the ai assistant can render dynamically this enables generative ui the assistant can compose new interfaces on the fly based on user requests how components work when you register a component the llm can: decide to render it based on user requests pass props based on the component s defaults and prompt compose multiple components together update component props through conversation component structure each component in your config has this structure: key concepts prompt the prompt field describes what the component does and when to render it: the llm uses this to decide: when to render the component what props to pass how to describe it to the user defaults the defaults object provides example default props that help the llm understand the component s structure: purpose: shows the llm what props the component expects provides example data structure helps the llm generate appropriate props callcomponent a function that returns your react component with the provided props: important: must return a valid react element props come from the llm based on defaults and prompt you can transform or validate props before passing them category an optional string that groups related components: useful for organization and helping the llm understand component relationships example: e-commerce components here s a complete example from an e-commerce app: component patterns display components components that show data: form components components that collect input: interactive components components that trigger actions: layout components components that organize other components: props handling validating props validate and transform props before passing them to your component: default props provide fallback values: component categories use categories to organize related components: best practices provide realistic default props that match your actual data structure this helps the llm generate appropriate props consider wrapping components in error boundaries to handle rendering errors gracefully: combining components and functions components can work together with functions: the llm can: call getproducts to fetch data render productgrid with the fetched products compose multiple components together limitations components are rendered in the chat context inside modalchat complex layouts may be limited by chat ui constraints props are generated by the llm so validation is important performance: many components may impact chat performance next steps learn about functions: functions configure runtime: runtime debugging customize styling: modalchat styling",
      "headings": [
        "How Components Work",
        "Component Structure",
        "Key Concepts",
        "Example: E-Commerce Components",
        "Component Patterns",
        "Props Handling",
        "Component Categories",
        "Best Practices",
        "Combining Components and Functions",
        "Limitations",
        "Next Steps"
      ],
      "keywords": [
        "components",
        "generative ui",
        "react components",
        "registry",
        "callComponent",
        "How Components Work",
        "Component Structure",
        "Key Concepts",
        "Example: E-Commerce Components",
        "Component Patterns",
        "Props Handling",
        "Component Categories",
        "Best Practices",
        "Combining Components and Functions",
        "Limitations",
        "Next Steps",
        "generative UI",
        "Purpose:",
        "Important:",
        "defaults",
        "prompt",
        "tsx\ncomponents: {\r\n  ComponentName: {\r\n    prompt: 'Description of what this component displays...',\r\n    defaults: {\r\n      propName: 'default value',\r\n    },\r\n    callComponent: (props) => <YourComponent {...props} />,\r\n    category: 'optional-category',\r\n  },\r\n}",
        "## Key Concepts\n\n### Prompt\n\nThe",
        "field describes what the component does and when to render it:",
        "tsx\nprompt: 'Shows cart items with quantities and total; triggers checkout when requested.'",
        "The LLM uses this to decide:\n\n* When to render the component\n* What props to pass\n* How to describe it to the user\n\n### Defaults\n\nThe",
        "object provides example/default props that help the LLM understand the component's structure:",
        "tsx\ndefaults: {\r\n  items: [\r\n    { id: '1', name: 'Beige Coat', price: 89.99, quantity: 2 },\r\n    { id: '2', name: 'Denim Jacket', price: 69.99, quantity: 1 },\r\n  ],\r\n}",
        "**Purpose:**\n\n* Shows the LLM what props the component expects\n* Provides example data structure\n* Helps the LLM generate appropriate props\n\n### callComponent\n\nA function that returns your React component with the provided props:",
        "tsx\ncallComponent: (props) => <CartSummary {...props} />",
        "**Important:**\n\n* Must return a valid React element\n* Props come from the LLM (based on defaults and prompt)\n* You can transform or validate props before passing them\n\n### Category\n\nAn optional string that groups related components:",
        "tsx\ncategory: 'checkout' // Groups with other checkout-related components",
        "Useful for organization and helping the LLM understand component relationships.\n\n## Example: E-Commerce Components\n\nHere's a complete example from an e-commerce app:",
        "tsx\ncomponents: {\r\n  CartSummary: {\r\n    prompt: 'Shows cart items with quantities and total; triggers checkout when requested.',\r\n    defaults: {\r\n      items: [\r\n        { id: '1', name: 'Beige Coat', price: 89.99, quantity: 2 },\r\n        { id: '2', name: 'Denim Jacket', price: 69.99, quantity: 1 },\r\n      ],\r\n    },\r\n    callComponent: (props) => <CartSummary {...props} />,\r\n    category: 'checkout',\r\n  },\r\n\r\n  ProductCard: {\r\n    prompt: 'Displays a single product with image, name, price, and add-to-cart button.',\r\n    defaults: {\r\n      id: '1',\r\n      name: 'Product Name',\r\n      price: 29.99,\r\n      image: 'https://example.com/product.jpg',\r\n      description: 'Product description',\r\n    },\r\n    callComponent: (props) => <ProductCard {...props} />,\r\n    category: 'products',\r\n  },\r\n\r\n  ProductGrid: {\r\n    prompt: 'Displays a grid of product cards. Use when showing multiple products.',\r\n    defaults: {\r\n      products: [\r\n        { id: '1', name: 'Product 1', price: 29.99 },\r\n        { id: '2', name: 'Product 2', price: 39.99 },\r\n      ],\r\n    },\r\n    callComponent: (props) => <ProductGrid {...props} />,\r\n    category: 'products',\r\n  },\r\n}",
        "## Component Patterns\n\n### Display Components\n\nComponents that show data:",
        "tsx\nUserProfile: {\r\n  prompt: 'Displays user profile information: name, avatar, email, and stats.',\r\n  defaults: {\r\n    name: 'John Doe',\r\n    email: 'john@example.com',\r\n    avatar: 'https://example.com/avatar.jpg',\r\n    stats: { posts: 42, followers: 123 },\r\n  },\r\n  callComponent: (props) => <UserProfile {...props} />,\r\n}",
        "### Form Components\n\nComponents that collect input:",
        "tsx\nTaskForm: {\r\n  prompt: 'Displays a form for creating or editing a task. Includes fields for title, description, status, priority, and due date.',\r\n  defaults: {\r\n    title: '',\r\n    description: '',\r\n    status: 'todo',\r\n    priority: 'medium',\r\n    dueDate: null,\r\n  },\r\n  callComponent: (props) => <TaskForm {...props} />,\r\n  category: 'forms',\r\n}",
        "### Interactive Components\n\nComponents that trigger actions:",
        "tsx\nActionButton: {\r\n  prompt: 'A button that triggers an action when clicked. Use for primary actions like \"Save\", \"Submit\", \"Delete\".',\r\n  defaults: {\r\n    label: 'Click me',\r\n    variant: 'primary',\r\n    onClick: () => {},\r\n  },\r\n  callComponent: (props) => <ActionButton {...props} />,\r\n  category: 'actions',\r\n}",
        "### Layout Components\n\nComponents that organize other components:",
        "tsx\nDashboard: {\r\n  prompt: 'A dashboard layout with sidebar, header, and main content area. Can contain widgets and charts.',\r\n  defaults: {\r\n    sidebarItems: [],\r\n    headerTitle: 'Dashboard',\r\n    widgets: [],\r\n  },\r\n  callComponent: (props) => <Dashboard {...props} />,\r\n  category: 'layout',\r\n}",
        "## Props Handling\n\n### Validating Props\n\nValidate and transform props before passing them to your component:",
        "tsx\ncallComponent: (props) => {\r\n  // Validate required props\r\n  if (!props.items || !Array.isArray(props.items)) {\r\n    return <div>Error: Invalid items prop</div>\r\n  }\r\n\r\n  // Transform props\r\n  const transformedProps = {\r\n    ...props,\r\n    items: props.items.map(item => ({\r\n      ...item,\r\n      total: item.price * item.quantity,\r\n    })),\r\n  }\r\n\r\n  return <CartSummary {...transformedProps} />\r\n}",
        "### Default Props\n\nProvide fallback values:",
        "tsx\ncallComponent: (props) => {\r\n  const safeProps = {\r\n    title: props.title || 'Untitled',\r\n    items: props.items || [],\r\n    onAction: props.onAction || (() => {}),\r\n  }\r\n  return <MyComponent {...safeProps} />\r\n}",
        "## Component Categories\n\nUse categories to organize related components:",
        "tsx\n// Navigation\r\ncomponents: {\r\n  NavBar: { category: 'navigation', /* ... */ },\r\n  Sidebar: { category: 'navigation', /* ... */ },\r\n}\r\n\r\n// Data Display\r\ncomponents: {\r\n  Table: { category: 'data', /* ... */ },\r\n  Chart: { category: 'data', /* ... */ },\r\n  List: { category: 'data', /* ... */ },\r\n}\r\n\r\n// Forms\r\ncomponents: {\r\n  TextInput: { category: 'forms', /* ... */ },\r\n  Select: { category: 'forms', /* ... */ },\r\n  Checkbox: { category: 'forms', /* ... */ },\r\n}",
        "## Best Practices\n\n<Note title=\"Realistic Defaults\" type=\"warning\">\n  Provide realistic default props that match your actual data structure. This helps the LLM generate appropriate props.\n</Note>\n\n<Note title=\"Error Boundaries\" type=\"warning\">\n  Consider wrapping components in error boundaries to handle rendering errors gracefully:",
        "tsx\n  callComponent: (props) => (\r\n    <ErrorBoundary>\r\n      <YourComponent {...props} />\r\n    </ErrorBoundary>\r\n  )",
        "</Note>\n\n## Combining Components and Functions\n\nComponents can work together with functions:",
        "tsx\n// Function to fetch data\r\nfunctions: {\r\n  getProducts: {\r\n    prompt: 'Fetch list of products.',\r\n    callFunc: () => products,\r\n    returns: 'Product[]',\r\n  },\r\n}\r\n\r\n// Component to display data\r\ncomponents: {\r\n  ProductGrid: {\r\n    prompt: 'Display a grid of products.',\r\n    defaults: {\r\n      products: [],\r\n    },\r\n    callComponent: (props) => <ProductGrid {...props} />,\r\n  },\r\n}",
        "The LLM can:\n\n1. Call",
        "to fetch data\n2. Render"
      ]
    }
  },
  {
    "slug": "/config",
    "title": "Config Explanation",
    "description": "Understand AutoUIConfig structure and how to configure AUTOUI for your app.",
    "content": "Your `AutoUIConfig` is the contract between your app and the AI assistant. It tells the AI what your app can do.\n\n## Basic Structure\n\n```tsx\nimport { AutoUIConfig } from \"@autoai-ui/autoui\"\r\n\r\nconst config: AutoUIConfig = {\r\n  appId: 'my-app',           // Required: Unique app ID\r\n  llm: { /* ... */ },        // Required: LLM configuration\r\n  runtime: { /* ... */ },    // Required: Runtime settings\r\n  functions: { /* ... */ },  // Optional: Functions AI can call\r\n  components: { /* ... */ }, // Optional: Components AI can render\r\n  metadata: { /* ... */ },   // Optional: App metadata\r\n}\n```\n\n## Required Fields\n\n### `appId`\n\nUnique identifier for your app:\n\n```tsx\nappId: 'my-app'\n```\n\n### `llm`\n\nLLM provider configuration:\n\n```tsx\nllm: {\r\n  proxyUrl: 'http://localhost:3001',  // Required: Your proxy URL\r\n  sharedSecret: 'your-secret',        // Optional: Proxy auth\r\n  appDescriptionPrompt: 'My app does...', // Optional: Describe your app\r\n}\n```\n\n### `runtime`\n\nRuntime execution settings:\n\n```tsx\nruntime: {\r\n  validateLLMOutput: true,           // Validate AI responses\r\n  storeChatToLocalStorage: true,      // Save chat history\r\n  maxSteps: 20,                        // Max AI actions per turn\r\n  errorHandling: {\r\n    showToUser: true,                  // Show errors in chat\r\n    retryOnFail: false,                // Auto-retry on failure\r\n  },\r\n}\n```\n\n## Optional Fields\n\n### `metadata`\n\nApp information (helps AI understand your app):\n\n```tsx\nmetadata: {\r\n  appName: 'My App',\r\n  description: 'What my app does...',\r\n  tags: ['ecommerce', 'react'],\r\n}\n```\n\n### `functions`\n\nFunctions the AI can call:\n\n```tsx\nfunctions: {\r\n  searchProducts: {\r\n    prompt: 'Search for products',\r\n    callFunc: ({ query }) => searchProducts(query),\r\n    returns: 'Array of products',\r\n  },\r\n}\n```\n\n### `components`\n\nComponents the AI can render:\n\n```tsx\ncomponents: {\r\n  ProductCard: {\r\n    prompt: 'Display a product card',\r\n    callComponent: ProductCard,\r\n    props: {\r\n      name: 'string - Product name',\r\n      price: 'number - Product price',\r\n    },\r\n  },\r\n}\n```\n\n## React vs Next.js\n\n### React Config\n\n```tsx\n// lib/autoui-config.ts\r\nimport { AutoUIConfig } from \"@autoai-ui/autoui\"\r\n\r\nexport function createAutoUIConfig(): AutoUIConfig {\r\n  return {\r\n    appId: 'my-react-app',\r\n    llm: {\r\n      proxyUrl: process.env.REACT_APP_PROXY_URL!,\r\n      sharedSecret: process.env.REACT_APP_SHARED_SECRET,\r\n    },\r\n    runtime: {\r\n      validateLLMOutput: true,\r\n      storeChatToLocalStorage: true,\r\n    },\r\n  }\r\n}\n```\n\n### Next.js Config\n\n```tsx\n// lib/autoui-config.tsx\r\n\"use client\"\r\n\r\nimport { AutoUIConfig } from \"@autoai-ui/autoui\"\r\n\r\nexport function createAutoUIConfig(): AutoUIConfig {\r\n  return {\r\n    appId: 'my-nextjs-app',\r\n    llm: {\r\n      proxyUrl: process.env.NEXT_PUBLIC_PROXY_URL!,\r\n      sharedSecret: process.env.NEXT_PUBLIC_SHARED_SECRET,\r\n    },\r\n    runtime: {\r\n      validateLLMOutput: true,\r\n      storeChatToLocalStorage: true,\r\n    },\r\n  }\r\n}\n```\n\n## Common Patterns\n\n### With Navigation\n\n```tsx\nimport { useRouter } from 'next/navigation'\r\n\r\nexport function createAutoUIConfig(router) {\r\n  return {\r\n    // ... other config\r\n    functions: {\r\n      navigate: {\r\n        prompt: 'Navigate to a page',\r\n        callFunc: ({ path }) => {\r\n          router.push(path)\r\n          return { success: true }\r\n        },\r\n      },\r\n    },\r\n  }\r\n}\n```\n\n### With State\n\n```tsx\nimport { useState } from 'react'\r\n\r\nfunction App() {\r\n  const [cart, setCart] = useState([])\r\n  \r\n  const config = {\r\n    // ... other config\r\n    functions: {\r\n      addToCart: {\r\n        prompt: 'Add item to cart',\r\n        callFunc: ({ item }) => {\r\n          setCart([...cart, item])\r\n          return { success: true }\r\n        },\r\n      },\r\n    },\r\n  }\r\n  \r\n  return <ModalChat config={config} />\r\n}\n```\n\n## Best Practices\n\n1. **Use environment variables** for sensitive data\n2. **Keep functions simple** and focused\n3. **Document props clearly** for components\n4. **Set appropriate maxSteps** based on complexity\n5. **Enable validation** in production\n\n## Learn More\n\n* [Functions Guide](/docs/functions) - Register functions\n* [Components Guide](/docs/components) - Register components\n* [Full Reference](/docs/reference/autouiconfig) - Complete API reference\n",
    "_searchMeta": {
      "cleanContent": "your autouiconfig is the contract between your app and the ai assistant it tells the ai what your app can do basic structure required fields appid unique identifier for your app: llm llm provider configuration: runtime runtime execution settings: optional fields metadata app information helps ai understand your app : functions functions the ai can call: components components the ai can render: react vs next js react config next js config common patterns with navigation with state best practices use environment variables for sensitive data keep functions simple and focused document props clearly for components set appropriate maxsteps based on complexity enable validation in production learn more functions guide - register functions components guide - register components full reference - complete api reference",
      "headings": [
        "Basic Structure",
        "Required Fields",
        "Optional Fields",
        "React vs Next.js",
        "Common Patterns",
        "Best Practices",
        "Learn More"
      ],
      "keywords": [
        "config",
        "configuration",
        "autouiconfig",
        "setup",
        "Basic Structure",
        "Required Fields",
        "Optional Fields",
        "React vs Next.js",
        "Common Patterns",
        "Best Practices",
        "Learn More",
        "Use environment variables",
        "Keep functions simple",
        "Document props clearly",
        "Set appropriate maxSteps",
        "Enable validation",
        "AutoUIConfig",
        "tsx\nimport { AutoUIConfig } from \"@autoai-ui/autoui\"\r\n\r\nconst config: AutoUIConfig = {\r\n  appId: 'my-app',           // Required: Unique app ID\r\n  llm: { /* ... */ },        // Required: LLM configuration\r\n  runtime: { /* ... */ },    // Required: Runtime settings\r\n  functions: { /* ... */ },  // Optional: Functions AI can call\r\n  components: { /* ... */ }, // Optional: Components AI can render\r\n  metadata: { /* ... */ },   // Optional: App metadata\r\n}",
        "## Required Fields\n\n###",
        "Unique identifier for your app:",
        "tsx\nappId: 'my-app'",
        "###",
        "LLM provider configuration:",
        "tsx\nllm: {\r\n  proxyUrl: 'http://localhost:3001',  // Required: Your proxy URL\r\n  sharedSecret: 'your-secret',        // Optional: Proxy auth\r\n  appDescriptionPrompt: 'My app does...', // Optional: Describe your app\r\n}",
        "Runtime execution settings:",
        "tsx\nruntime: {\r\n  validateLLMOutput: true,           // Validate AI responses\r\n  storeChatToLocalStorage: true,      // Save chat history\r\n  maxSteps: 20,                        // Max AI actions per turn\r\n  errorHandling: {\r\n    showToUser: true,                  // Show errors in chat\r\n    retryOnFail: false,                // Auto-retry on failure\r\n  },\r\n}",
        "## Optional Fields\n\n###",
        "App information (helps AI understand your app):",
        "tsx\nmetadata: {\r\n  appName: 'My App',\r\n  description: 'What my app does...',\r\n  tags: ['ecommerce', 'react'],\r\n}",
        "Functions the AI can call:",
        "tsx\nfunctions: {\r\n  searchProducts: {\r\n    prompt: 'Search for products',\r\n    callFunc: ({ query }) => searchProducts(query),\r\n    returns: 'Array of products',\r\n  },\r\n}",
        "Components the AI can render:",
        "tsx\ncomponents: {\r\n  ProductCard: {\r\n    prompt: 'Display a product card',\r\n    callComponent: ProductCard,\r\n    props: {\r\n      name: 'string - Product name',\r\n      price: 'number - Product price',\r\n    },\r\n  },\r\n}",
        "## React vs Next.js\n\n### React Config",
        "tsx\n// lib/autoui-config.ts\r\nimport { AutoUIConfig } from \"@autoai-ui/autoui\"\r\n\r\nexport function createAutoUIConfig(): AutoUIConfig {\r\n  return {\r\n    appId: 'my-react-app',\r\n    llm: {\r\n      proxyUrl: process.env.REACT_APP_PROXY_URL!,\r\n      sharedSecret: process.env.REACT_APP_SHARED_SECRET,\r\n    },\r\n    runtime: {\r\n      validateLLMOutput: true,\r\n      storeChatToLocalStorage: true,\r\n    },\r\n  }\r\n}",
        "### Next.js Config",
        "tsx\n// lib/autoui-config.tsx\r\n\"use client\"\r\n\r\nimport { AutoUIConfig } from \"@autoai-ui/autoui\"\r\n\r\nexport function createAutoUIConfig(): AutoUIConfig {\r\n  return {\r\n    appId: 'my-nextjs-app',\r\n    llm: {\r\n      proxyUrl: process.env.NEXT_PUBLIC_PROXY_URL!,\r\n      sharedSecret: process.env.NEXT_PUBLIC_SHARED_SECRET,\r\n    },\r\n    runtime: {\r\n      validateLLMOutput: true,\r\n      storeChatToLocalStorage: true,\r\n    },\r\n  }\r\n}",
        "## Common Patterns\n\n### With Navigation",
        "tsx\nimport { useRouter } from 'next/navigation'\r\n\r\nexport function createAutoUIConfig(router) {\r\n  return {\r\n    // ... other config\r\n    functions: {\r\n      navigate: {\r\n        prompt: 'Navigate to a page',\r\n        callFunc: ({ path }) => {\r\n          router.push(path)\r\n          return { success: true }\r\n        },\r\n      },\r\n    },\r\n  }\r\n}",
        "### With State",
        "tsx\nimport { useState } from 'react'\r\n\r\nfunction App() {\r\n  const [cart, setCart] = useState([])\r\n  \r\n  const config = {\r\n    // ... other config\r\n    functions: {\r\n      addToCart: {\r\n        prompt: 'Add item to cart',\r\n        callFunc: ({ item }) => {\r\n          setCart([...cart, item])\r\n          return { success: true }\r\n        },\r\n      },\r\n    },\r\n  }\r\n  \r\n  return <ModalChat config={config} />\r\n}"
      ]
    }
  },
  {
    "slug": "/functions",
    "title": "Functions",
    "description": "Learn how to register JavaScript functions that the AI assistant can call to interact with your application.",
    "content": "Functions are JavaScript functions you register in your `AutoUIConfig` that the AI assistant can call to interact with your application. They enable the assistant to read state, modify data, trigger side effects, and return information.\n\n## Function Structure\n\nEach function in your config has this structure:\n\n```tsx\nfunctions: {\r\n  functionName: {\r\n    prompt: 'Description of what this function does...',\r\n    params: {\r\n      paramName: 'Type description — what this parameter is',\r\n    },\r\n    callFunc: ({ paramName }) => {\r\n      // Your function implementation\r\n      return result\r\n    },\r\n    returns: 'ReturnType — description of what is returned',\r\n  },\r\n}\n```\n\n## Key Concepts\n\n### Prompt\n\nThe `prompt` field is a **natural language description** that tells the LLM:\n\n* What the function does\n* When to call it\n* What it's used for\n\nThe LLM uses this description to decide whether to call the function and with what parameters.\n\n### Params\n\nThe `params` object describes function parameters in a format the LLM can understand:\n\n```tsx\nparams: {\r\n  draft: 'TaskDraft — { title, description?, status, priority, due_date? }',\r\n  taskId: 'string — unique identifier for the task',\r\n  status: 'string — new status value: \"todo\" | \"in-progress\" | \"done\"',\r\n}\n```\n\n**Format:** `parameterName: 'Type — description'`\n\n* Use TypeScript-like type notation\n* Mark optional parameters with `?`\n* Include examples or constraints when helpful\n\n### callFunc\n\nThe actual JavaScript function that gets executed. It receives an object with the parameters:\n\n```tsx\ncallFunc: ({ draft, taskId, status }) => {\r\n  // Implementation\r\n  return result\r\n}\n```\n\n**Important:**\n\n* Parameters are passed as an object (destructured)\n* The function can be async\n* Return values become context for the LLM\n* Side effects (API calls, state updates) are allowed\n\n### Returns\n\nA description of what the function returns, in the same format as params:\n\n```tsx\nreturns: 'Task — full task object with id, title, status, priority, created_at'\n```\n\n## Example: Task Management Functions\n\nHere's a complete example from a task management app:\n\n```tsx\nfunctions: {\r\n  createTask: {\r\n    prompt: 'Create a new Task object from a TaskDraft by adding id and created_at timestamp.',\r\n    params: {\r\n      draft: 'TaskDraft — { title, description?, status, priority, due_date? }',\r\n    },\r\n    callFunc: ({ draft }: { draft: TaskDraft }) => {\r\n      const task = {\r\n        ...draft,\r\n        id: generateId(),\r\n        created_at: new Date().toISOString(),\r\n      }\r\n      tasks.push(task)\r\n      return task\r\n    },\r\n    returns: 'Task — full task with generated id and created_at fields.',\r\n  },\r\n\r\n  updateTask: {\r\n    prompt: 'Update an existing Task using a TaskDraft patch, preserving id and created_at.',\r\n    params: {\r\n      task: 'Task — existing task object',\r\n      patch: 'TaskDraft — fields to update',\r\n    },\r\n    callFunc: ({ task, patch }: { task: Task; patch: TaskDraft }) => {\r\n      const updated = {\r\n        ...task,\r\n        ...patch,\r\n        id: task.id, // Preserve id\r\n        created_at: task.created_at, // Preserve created_at\r\n      }\r\n      const index = tasks.findIndex(t => t.id === task.id)\r\n      if (index !== -1) {\r\n        tasks[index] = updated\r\n      }\r\n      return updated\r\n    },\r\n    returns: 'Task — updated task object.',\r\n  },\r\n\r\n  summarizeTasks: {\r\n    prompt: 'Compute task statistics: total count and counts by status and priority.',\r\n    params: {\r\n      tasks: 'Task[] — current list of tasks',\r\n    },\r\n    callFunc: ({ tasks }: { tasks: Task[] }) => {\r\n      const total = tasks.length\r\n      const byStatus: Record<string, number> = {}\r\n      const byPriority: Record<string, number> = {}\r\n\r\n      for (const t of tasks) {\r\n        byStatus[t.status] = (byStatus[t.status] ?? 0) + 1\r\n        byPriority[t.priority] = (byPriority[t.priority] ?? 0) + 1\r\n      }\r\n\r\n      return { total, byStatus, byPriority }\r\n    },\r\n    returns: '{ total: number, byStatus: Record<string, number>, byPriority: Record<string, number> }',\r\n  },\r\n\r\n  openTaskForm: {\r\n    prompt: 'Open the task creation form in the main app UI. After opening, tell the user they can close the chat and continue in the form.',\r\n    callFunc: () => {\r\n      setShowForm(true)\r\n    },\r\n  },\r\n\r\n  fetchCurrentTasksState: {\r\n    prompt: 'Return the current list of tasks from application state.',\r\n    callFunc: () => tasks,\r\n    returns: 'Task[] — array of all tasks',\r\n  },\r\n\r\n  showHowManyTasks: {\r\n    prompt: 'Return the number of tasks in the current task list.',\r\n    callFunc: () => tasks.length,\r\n    returns: 'number — count of tasks',\r\n  },\r\n}\n```\n\n## Function Types\n\n### Read-Only Functions\n\nFunctions that only read state and return data:\n\n```tsx\ngetUserProfile: {\r\n  prompt: 'Get the current user profile information.',\r\n  callFunc: () => currentUser,\r\n  returns: 'User — user object with name, email, avatar',\r\n}\n```\n\n### State Modification Functions\n\nFunctions that modify application state:\n\n```tsx\nupdateUserSettings: {\r\n  prompt: 'Update user settings with new values.',\r\n  params: {\r\n    settings: 'UserSettings — { theme, notifications, language }',\r\n  },\r\n  callFunc: ({ settings }) => {\r\n    userSettings = { ...userSettings, ...settings }\r\n    saveToLocalStorage(userSettings)\r\n    return userSettings\r\n  },\r\n  returns: 'UserSettings — updated settings object',\r\n}\n```\n\n### Side Effect Functions\n\nFunctions that trigger side effects (API calls, navigation, etc.):\n\n```tsx\nnavigateToPage: {\r\n  prompt: 'Navigate to a specific page in the application.',\r\n  params: {\r\n    path: 'string — route path (e.g., \"/dashboard\", \"/settings\")',\r\n  },\r\n  callFunc: ({ path }) => {\r\n    router.push(path)\r\n  },\r\n},\r\n\r\nsendEmail: {\r\n  prompt: 'Send an email notification.',\r\n  params: {\r\n    to: 'string — recipient email address',\r\n    subject: 'string — email subject',\r\n    body: 'string — email body text',\r\n  },\r\n  callFunc: async ({ to, subject, body }) => {\r\n    await emailService.send({ to, subject, body })\r\n    return { success: true, messageId: '...' }\r\n  },\r\n  returns: '{ success: boolean, messageId?: string }',\r\n}\n```\n\n### Async Functions\n\nFunctions can be async and return promises:\n\n```tsx\nfetchData: {\r\n  prompt: 'Fetch data from an API endpoint.',\r\n  params: {\r\n    endpoint: 'string — API endpoint URL',\r\n  },\r\n  callFunc: async ({ endpoint }) => {\r\n    const response = await fetch(endpoint)\r\n    return await response.json()\r\n  },\r\n  returns: 'any — JSON response from API',\r\n}\n```\n\n## Data Sharing Rules\n\nFunctions share the same JavaScript scope as your React component. This means:\n\n* **State access**: Functions can read and modify React state\n* **Closures**: Functions have access to variables in their closure\n* **Side effects**: Functions can trigger any side effects (API calls, navigation, etc.)\n\n**Example:**\n\n```tsx\nfunction MyApp() {\r\n  const [tasks, setTasks] = useState([])\r\n  const [showForm, setShowForm] = useState(false)\r\n\r\n  const config: AutoUIConfig = {\r\n    // ...\r\n    functions: {\r\n      // Can access tasks and setTasks\r\n      createTask: {\r\n        prompt: 'Create a new task.',\r\n        params: {\r\n          title: 'string — task title',\r\n        },\r\n        callFunc: ({ title }) => {\r\n          const newTask = { id: generateId(), title, status: 'todo' }\r\n          setTasks([...tasks, newTask]) // Modify React state\r\n          return newTask\r\n        },\r\n        returns: 'Task — newly created task',\r\n      },\r\n\r\n      // Can access showForm and setShowForm\r\n      openTaskForm: {\r\n        prompt: 'Open the task creation form.',\r\n        callFunc: () => {\r\n          setShowForm(true) // Trigger UI change\r\n        },\r\n      },\r\n    },\r\n  }\r\n\r\n  return <ModalChat config={config} />\r\n}\n```\n\n## Best Practices\n\n<Note title=\"Type Safety\" type=\"warning\">\n  While params are described as strings, consider adding TypeScript types for your own code:\n\n  ```tsx\n  interface TaskDraft {\r\n    title: string\r\n    description?: string\r\n    status: 'todo' | 'in-progress' | 'done'\r\n    priority: 'low' | 'medium' | 'high'\r\n    due_date?: string\r\n  }\r\n\r\n  callFunc: ({ draft }: { draft: TaskDraft }) => {\r\n    // TypeScript will catch errors\r\n  }\n  ```\n</Note>\n\n<Note title=\"Idempotency\" type=\"success\">\n  When possible, make functions idempotent (safe to call multiple times):\n\n  ```tsx\n  // Good: Idempotent\r\n  markAsComplete: {\r\n    callFunc: ({ taskId }) => {\r\n      const task = tasks.find(t => t.id === taskId)\r\n      if (task) {\r\n        task.status = 'done' // Safe to call multiple times\r\n      }\r\n      return task\r\n    },\r\n  }\n  ```\n</Note>\n\n## Common Patterns\n\n### CRUD Operations\n\n```tsx\n// Create\r\ncreateItem: { /* ... */ }\r\n\r\n// Read\r\ngetItem: { /* ... */ }\r\nlistItems: { /* ... */ }\r\n\r\n// Update\r\nupdateItem: { /* ... */ }\r\n\r\n// Delete\r\ndeleteItem: { /* ... */ }\n```\n\n### Filtering and Search\n\n```tsx\nsearchItems: {\r\n  prompt: 'Search items by query string.',\r\n  params: {\r\n    query: 'string — search query',\r\n    filters: 'object (optional) — { category?, status?, dateRange? }',\r\n  },\r\n  callFunc: ({ query, filters }) => {\r\n    return items.filter(item => {\r\n      // Filter logic\r\n    })\r\n  },\r\n}\n```\n\n### Statistics and Aggregations\n\n```tsx\ngetStats: {\r\n  prompt: 'Get aggregated statistics.',\r\n  callFunc: () => {\r\n    return {\r\n      total: items.length,\r\n      byCategory: groupBy(items, 'category'),\r\n      average: calculateAverage(items),\r\n    }\r\n  },\r\n}\n```\n\n## Next Steps\n\n* Register components: [Components Registry](/docs/components)\n* Configure runtime: [Runtime & Debugging](/docs/runtime)\n* Troubleshoot issues: [Troubleshooting](/docs/troubleshooting)\n",
    "_searchMeta": {
      "cleanContent": "functions are javascript functions you register in your autouiconfig that the ai assistant can call to interact with your application they enable the assistant to read state modify data trigger side effects and return information function structure each function in your config has this structure: key concepts prompt the prompt field is a natural language description that tells the llm: what the function does when to call it what it s used for the llm uses this description to decide whether to call the function and with what parameters params the params object describes function parameters in a format the llm can understand: format: parametername: type description use typescript-like type notation mark optional parameters with include examples or constraints when helpful callfunc the actual javascript function that gets executed it receives an object with the parameters: important: parameters are passed as an object destructured the function can be async return values become context for the llm side effects api calls state updates are allowed returns a description of what the function returns in the same format as params: example: task management functions here s a complete example from a task management app: function types read-only functions functions that only read state and return data: state modification functions functions that modify application state: side effect functions functions that trigger side effects api calls navigation etc : async functions functions can be async and return promises: data sharing rules functions share the same javascript scope as your react component this means: state access: functions can read and modify react state closures: functions have access to variables in their closure side effects: functions can trigger any side effects api calls navigation etc example: best practices while params are described as strings consider adding typescript types for your own code: when possible make functions idempotent safe to call multiple times : common patterns crud operations filtering and search statistics and aggregations next steps register components: components registry configure runtime: runtime debugging troubleshoot issues: troubleshooting",
      "headings": [
        "Function Structure",
        "Key Concepts",
        "Example: Task Management Functions",
        "Function Types",
        "Data Sharing Rules",
        "Best Practices",
        "Common Patterns",
        "Next Steps"
      ],
      "keywords": [
        "functions",
        "callFunc",
        "params",
        "returns",
        "side effects",
        "Function Structure",
        "Key Concepts",
        "Example: Task Management Functions",
        "Function Types",
        "Data Sharing Rules",
        "Best Practices",
        "Common Patterns",
        "Next Steps",
        "natural language description",
        "Format:",
        "Important:",
        "State access",
        "Closures",
        "Side effects",
        "Example:",
        "AutoUIConfig",
        "tsx\nfunctions: {\r\n  functionName: {\r\n    prompt: 'Description of what this function does...',\r\n    params: {\r\n      paramName: 'Type description — what this parameter is',\r\n    },\r\n    callFunc: ({ paramName }) => {\r\n      // Your function implementation\r\n      return result\r\n    },\r\n    returns: 'ReturnType — description of what is returned',\r\n  },\r\n}",
        "## Key Concepts\n\n### Prompt\n\nThe",
        "field is a **natural language description** that tells the LLM:\n\n* What the function does\n* When to call it\n* What it's used for\n\nThe LLM uses this description to decide whether to call the function and with what parameters.\n\n### Params\n\nThe",
        "object describes function parameters in a format the LLM can understand:",
        "tsx\nparams: {\r\n  draft: 'TaskDraft — { title, description?, status, priority, due_date? }',\r\n  taskId: 'string — unique identifier for the task',\r\n  status: 'string — new status value: \"todo\" | \"in-progress\" | \"done\"',\r\n}",
        "**Format:**",
        "* Use TypeScript-like type notation\n* Mark optional parameters with",
        "* Include examples or constraints when helpful\n\n### callFunc\n\nThe actual JavaScript function that gets executed. It receives an object with the parameters:",
        "tsx\ncallFunc: ({ draft, taskId, status }) => {\r\n  // Implementation\r\n  return result\r\n}",
        "**Important:**\n\n* Parameters are passed as an object (destructured)\n* The function can be async\n* Return values become context for the LLM\n* Side effects (API calls, state updates) are allowed\n\n### Returns\n\nA description of what the function returns, in the same format as params:",
        "tsx\nreturns: 'Task — full task object with id, title, status, priority, created_at'",
        "## Example: Task Management Functions\n\nHere's a complete example from a task management app:",
        "tsx\nfunctions: {\r\n  createTask: {\r\n    prompt: 'Create a new Task object from a TaskDraft by adding id and created_at timestamp.',\r\n    params: {\r\n      draft: 'TaskDraft — { title, description?, status, priority, due_date? }',\r\n    },\r\n    callFunc: ({ draft }: { draft: TaskDraft }) => {\r\n      const task = {\r\n        ...draft,\r\n        id: generateId(),\r\n        created_at: new Date().toISOString(),\r\n      }\r\n      tasks.push(task)\r\n      return task\r\n    },\r\n    returns: 'Task — full task with generated id and created_at fields.',\r\n  },\r\n\r\n  updateTask: {\r\n    prompt: 'Update an existing Task using a TaskDraft patch, preserving id and created_at.',\r\n    params: {\r\n      task: 'Task — existing task object',\r\n      patch: 'TaskDraft — fields to update',\r\n    },\r\n    callFunc: ({ task, patch }: { task: Task; patch: TaskDraft }) => {\r\n      const updated = {\r\n        ...task,\r\n        ...patch,\r\n        id: task.id, // Preserve id\r\n        created_at: task.created_at, // Preserve created_at\r\n      }\r\n      const index = tasks.findIndex(t => t.id === task.id)\r\n      if (index !== -1) {\r\n        tasks[index] = updated\r\n      }\r\n      return updated\r\n    },\r\n    returns: 'Task — updated task object.',\r\n  },\r\n\r\n  summarizeTasks: {\r\n    prompt: 'Compute task statistics: total count and counts by status and priority.',\r\n    params: {\r\n      tasks: 'Task[] — current list of tasks',\r\n    },\r\n    callFunc: ({ tasks }: { tasks: Task[] }) => {\r\n      const total = tasks.length\r\n      const byStatus: Record<string, number> = {}\r\n      const byPriority: Record<string, number> = {}\r\n\r\n      for (const t of tasks) {\r\n        byStatus[t.status] = (byStatus[t.status] ?? 0) + 1\r\n        byPriority[t.priority] = (byPriority[t.priority] ?? 0) + 1\r\n      }\r\n\r\n      return { total, byStatus, byPriority }\r\n    },\r\n    returns: '{ total: number, byStatus: Record<string, number>, byPriority: Record<string, number> }',\r\n  },\r\n\r\n  openTaskForm: {\r\n    prompt: 'Open the task creation form in the main app UI. After opening, tell the user they can close the chat and continue in the form.',\r\n    callFunc: () => {\r\n      setShowForm(true)\r\n    },\r\n  },\r\n\r\n  fetchCurrentTasksState: {\r\n    prompt: 'Return the current list of tasks from application state.',\r\n    callFunc: () => tasks,\r\n    returns: 'Task[] — array of all tasks',\r\n  },\r\n\r\n  showHowManyTasks: {\r\n    prompt: 'Return the number of tasks in the current task list.',\r\n    callFunc: () => tasks.length,\r\n    returns: 'number — count of tasks',\r\n  },\r\n}",
        "## Function Types\n\n### Read-Only Functions\n\nFunctions that only read state and return data:",
        "tsx\ngetUserProfile: {\r\n  prompt: 'Get the current user profile information.',\r\n  callFunc: () => currentUser,\r\n  returns: 'User — user object with name, email, avatar',\r\n}",
        "### State Modification Functions\n\nFunctions that modify application state:",
        "tsx\nupdateUserSettings: {\r\n  prompt: 'Update user settings with new values.',\r\n  params: {\r\n    settings: 'UserSettings — { theme, notifications, language }',\r\n  },\r\n  callFunc: ({ settings }) => {\r\n    userSettings = { ...userSettings, ...settings }\r\n    saveToLocalStorage(userSettings)\r\n    return userSettings\r\n  },\r\n  returns: 'UserSettings — updated settings object',\r\n}",
        "### Side Effect Functions\n\nFunctions that trigger side effects (API calls, navigation, etc.):",
        "tsx\nnavigateToPage: {\r\n  prompt: 'Navigate to a specific page in the application.',\r\n  params: {\r\n    path: 'string — route path (e.g., \"/dashboard\", \"/settings\")',\r\n  },\r\n  callFunc: ({ path }) => {\r\n    router.push(path)\r\n  },\r\n},\r\n\r\nsendEmail: {\r\n  prompt: 'Send an email notification.',\r\n  params: {\r\n    to: 'string — recipient email address',\r\n    subject: 'string — email subject',\r\n    body: 'string — email body text',\r\n  },\r\n  callFunc: async ({ to, subject, body }) => {\r\n    await emailService.send({ to, subject, body })\r\n    return { success: true, messageId: '...' }\r\n  },\r\n  returns: '{ success: boolean, messageId?: string }',\r\n}",
        "### Async Functions\n\nFunctions can be async and return promises:",
        "tsx\nfetchData: {\r\n  prompt: 'Fetch data from an API endpoint.',\r\n  params: {\r\n    endpoint: 'string — API endpoint URL',\r\n  },\r\n  callFunc: async ({ endpoint }) => {\r\n    const response = await fetch(endpoint)\r\n    return await response.json()\r\n  },\r\n  returns: 'any — JSON response from API',\r\n}",
        "## Data Sharing Rules\n\nFunctions share the same JavaScript scope as your React component. This means:\n\n* **State access**: Functions can read and modify React state\n* **Closures**: Functions have access to variables in their closure\n* **Side effects**: Functions can trigger any side effects (API calls, navigation, etc.)\n\n**Example:**",
        "tsx\nfunction MyApp() {\r\n  const [tasks, setTasks] = useState([])\r\n  const [showForm, setShowForm] = useState(false)\r\n\r\n  const config: AutoUIConfig = {\r\n    // ...\r\n    functions: {\r\n      // Can access tasks and setTasks\r\n      createTask: {\r\n        prompt: 'Create a new task.',\r\n        params: {\r\n          title: 'string — task title',\r\n        },\r\n        callFunc: ({ title }) => {\r\n          const newTask = { id: generateId(), title, status: 'todo' }\r\n          setTasks([...tasks, newTask]) // Modify React state\r\n          return newTask\r\n        },\r\n        returns: 'Task — newly created task',\r\n      },\r\n\r\n      // Can access showForm and setShowForm\r\n      openTaskForm: {\r\n        prompt: 'Open the task creation form.',\r\n        callFunc: () => {\r\n          setShowForm(true) // Trigger UI change\r\n        },\r\n      },\r\n    },\r\n  }\r\n\r\n  return <ModalChat config={config} />\r\n}",
        "## Best Practices\n\n<Note title=\"Type Safety\" type=\"warning\">\n  While params are described as strings, consider adding TypeScript types for your own code:",
        "tsx\n  interface TaskDraft {\r\n    title: string\r\n    description?: string\r\n    status: 'todo' | 'in-progress' | 'done'\r\n    priority: 'low' | 'medium' | 'high'\r\n    due_date?: string\r\n  }\r\n\r\n  callFunc: ({ draft }: { draft: TaskDraft }) => {\r\n    // TypeScript will catch errors\r\n  }",
        "</Note>\n\n<Note title=\"Idempotency\" type=\"success\">\n  When possible, make functions idempotent (safe to call multiple times):",
        "tsx\n  // Good: Idempotent\r\n  markAsComplete: {\r\n    callFunc: ({ taskId }) => {\r\n      const task = tasks.find(t => t.id === taskId)\r\n      if (task) {\r\n        task.status = 'done' // Safe to call multiple times\r\n      }\r\n      return task\r\n    },\r\n  }",
        "</Note>\n\n## Common Patterns\n\n### CRUD Operations",
        "tsx\n// Create\r\ncreateItem: { /* ... */ }\r\n\r\n// Read\r\ngetItem: { /* ... */ }\r\nlistItems: { /* ... */ }\r\n\r\n// Update\r\nupdateItem: { /* ... */ }\r\n\r\n// Delete\r\ndeleteItem: { /* ... */ }",
        "### Filtering and Search",
        "tsx\nsearchItems: {\r\n  prompt: 'Search items by query string.',\r\n  params: {\r\n    query: 'string — search query',\r\n    filters: 'object (optional) — { category?, status?, dateRange? }',\r\n  },\r\n  callFunc: ({ query, filters }) => {\r\n    return items.filter(item => {\r\n      // Filter logic\r\n    })\r\n  },\r\n}",
        "### Statistics and Aggregations",
        "tsx\ngetStats: {\r\n  prompt: 'Get aggregated statistics.',\r\n  callFunc: () => {\r\n    return {\r\n      total: items.length,\r\n      byCategory: groupBy(items, 'category'),\r\n      average: calculateAverage(items),\r\n    }\r\n  },\r\n}"
      ]
    }
  },
  {
    "slug": "/installation",
    "title": "Quick Installation & Configuration",
    "description": "Install AUTOUI and get it running in your app quickly.",
    "content": "Get AUTOUI running in 3 steps.\n\n## Step 1: Install\n\n```bash\nnpm install @autoai-ui/autoui\n```\n\n## Step 2: Basic Config\n\nCreate your config file:\n\n**React:**\n\n```tsx\n// lib/autoui-config.ts\r\nimport { AutoUIConfig } from \"@autoai-ui/autoui\"\r\n\r\nexport function createAutoUIConfig(): AutoUIConfig {\r\n  return {\r\n    appId: 'my-app',\r\n    llm: {\r\n      proxyUrl: process.env.REACT_APP_PROXY_URL || 'http://localhost:3001',\r\n      sharedSecret: process.env.REACT_APP_SHARED_SECRET,\r\n    },\r\n    runtime: {\r\n      validateLLMOutput: true,\r\n      storeChatToLocalStorage: true,\r\n    },\r\n  }\r\n}\n```\n\n**Next.js:**\n\n```tsx\n// lib/autoui-config.tsx\r\n\"use client\"\r\n\r\nimport { AutoUIConfig } from \"@autoai-ui/autoui\"\r\n\r\nexport function createAutoUIConfig(): AutoUIConfig {\r\n  return {\r\n    appId: 'my-app',\r\nllm: {\r\n      proxyUrl: process.env.NEXT_PUBLIC_PROXY_URL || 'http://localhost:3001',\r\n      sharedSecret: process.env.NEXT_PUBLIC_SHARED_SECRET,\r\n    },\r\n    runtime: {\r\n      validateLLMOutput: true,\r\n      storeChatToLocalStorage: true,\r\n    },\r\n  }\r\n}\n```\n\n## Step 3: Add ModalChat\n\n**React:**\n\n```tsx\nimport { ModalChat } from \"@autoai-ui/autoui\"\r\nimport { createAutoUIConfig } from \"./lib/autoui-config\"\r\n\r\nfunction App() {\r\n  const config = createAutoUIConfig()\r\n  return <ModalChat config={config} />\r\n}\n```\n\n**Next.js:**\n\n```tsx\n\"use client\"\r\n\r\nimport dynamic from \"next/dynamic\"\r\nimport { createAutoUIConfig } from \"@/lib/autoui-config\"\r\n\r\nconst ModalChat = dynamic(\r\n  () => import(\"@autoai-ui/autoui\").then(m => m.ModalChat),\r\n  { ssr: false }  // ← Required for Next.js\r\n)\r\n\r\nexport default function App() {\r\n  const config = createAutoUIConfig()\r\n  return <ModalChat config={config} />\r\n}\n```\n\n## Environment Variables\n\nCreate `.env` (React) or `.env.local` (Next.js):\n\n```env\nREACT_APP_PROXY_URL=http://localhost:3001\r\nREACT_APP_SHARED_SECRET=your-secret\n```\n\nor\n\n```env\nNEXT_PUBLIC_PROXY_URL=http://localhost:3001\r\nNEXT_PUBLIC_SHARED_SECRET=your-secret\n```\n\n## What's Next?\n\n* Set up your [Backend Proxy](/docs/backend-proxy)\n* Understand [Config Structure](/docs/config)\n* See [Quick Start Guides](/docs/quickstart) for detailed setup\n",
    "_searchMeta": {
      "cleanContent": "get autoui running in 3 steps step 1: install step 2: basic config create your config file: react: next js: step 3: add modalchat react: next js: environment variables create env react or env local next js : or what s next set up your backend proxy understand config structure see quick start guides for detailed setup",
      "headings": [
        "Step 1: Install",
        "Step 2: Basic Config",
        "Step 3: Add ModalChat",
        "Environment Variables",
        "What's Next?"
      ],
      "keywords": [
        "installation",
        "setup",
        "quick",
        "Step 1: Install",
        "Step 2: Basic Config",
        "Step 3: Add ModalChat",
        "Environment Variables",
        "What's Next?",
        "React:",
        "Next.js:",
        "bash\nnpm install @autoai-ui/autoui",
        "## Step 2: Basic Config\n\nCreate your config file:\n\n**React:**",
        "tsx\n// lib/autoui-config.ts\r\nimport { AutoUIConfig } from \"@autoai-ui/autoui\"\r\n\r\nexport function createAutoUIConfig(): AutoUIConfig {\r\n  return {\r\n    appId: 'my-app',\r\n    llm: {\r\n      proxyUrl: process.env.REACT_APP_PROXY_URL || 'http://localhost:3001',\r\n      sharedSecret: process.env.REACT_APP_SHARED_SECRET,\r\n    },\r\n    runtime: {\r\n      validateLLMOutput: true,\r\n      storeChatToLocalStorage: true,\r\n    },\r\n  }\r\n}",
        "**Next.js:**",
        "tsx\n// lib/autoui-config.tsx\r\n\"use client\"\r\n\r\nimport { AutoUIConfig } from \"@autoai-ui/autoui\"\r\n\r\nexport function createAutoUIConfig(): AutoUIConfig {\r\n  return {\r\n    appId: 'my-app',\r\nllm: {\r\n      proxyUrl: process.env.NEXT_PUBLIC_PROXY_URL || 'http://localhost:3001',\r\n      sharedSecret: process.env.NEXT_PUBLIC_SHARED_SECRET,\r\n    },\r\n    runtime: {\r\n      validateLLMOutput: true,\r\n      storeChatToLocalStorage: true,\r\n    },\r\n  }\r\n}",
        "## Step 3: Add ModalChat\n\n**React:**",
        "tsx\nimport { ModalChat } from \"@autoai-ui/autoui\"\r\nimport { createAutoUIConfig } from \"./lib/autoui-config\"\r\n\r\nfunction App() {\r\n  const config = createAutoUIConfig()\r\n  return <ModalChat config={config} />\r\n}",
        "tsx\n\"use client\"\r\n\r\nimport dynamic from \"next/dynamic\"\r\nimport { createAutoUIConfig } from \"@/lib/autoui-config\"\r\n\r\nconst ModalChat = dynamic(\r\n  () => import(\"@autoai-ui/autoui\").then(m => m.ModalChat),\r\n  { ssr: false }  // ← Required for Next.js\r\n)\r\n\r\nexport default function App() {\r\n  const config = createAutoUIConfig()\r\n  return <ModalChat config={config} />\r\n}",
        "## Environment Variables\n\nCreate",
        "(React) or",
        "(Next.js):",
        "env\nREACT_APP_PROXY_URL=http://localhost:3001\r\nREACT_APP_SHARED_SECRET=your-secret",
        "or",
        "env\nNEXT_PUBLIC_PROXY_URL=http://localhost:3001\r\nNEXT_PUBLIC_SHARED_SECRET=your-secret"
      ]
    }
  },
  {
    "slug": "/introduction",
    "title": "What is AUTOUI?",
    "description": "Learn about AUTOUI, a config-driven React library that integrates AI-powered chat assistants into your applications.",
    "content": "AUTOUI is an npm library that integrates a ready-to-use **ModalChat** component into any React application. Instead of building chat interfaces from scratch, you provide a configuration object that describes your app's capabilities, and AUTOUI handles the rest—from LLM communication to plan execution to UI rendering.\n\n## How AUTOUI Works\n\nAUTOUI follows a **config-driven architecture** where your application's capabilities are defined declaratively. Here's the high-level flow:\n\n```\nUser → ModalChat → Proxy Server → OpenRouter/LLM → Plan JSON → Frontend Runtime → Functions/Components\n```\n\n## Key Concepts\n\n### ModalChat\n\nThe main React component you import and render. It displays a chat interface (typically as a floating button that opens a modal) and manages the conversation flow.\n\n```tsx\nimport { ModalChat } from \"@autoai-ui/autoui\"\r\n\r\n<ModalChat config={myConfig} />\n```\n\n### Config-Driven UI\n\nYour `AutoUIConfig` object is the **contract** between your app and the AI assistant. It tells the LLM:\n\n* What your app does (via `metadata.description` and `llm.appDescriptionPrompt`)\n* What functions are available (via `functions`)\n* What UI components can be rendered (via `components`)\n* How to behave (via `runtime` settings)\n\n### Plan & Steps\n\nThe LLM returns a **plan**—a structured JSON object that describes a sequence of actions. The runtime executes these steps in order, calling functions and rendering components as needed.\n\n### Runtime\n\nThe AUTOUI runtime orchestrates plan execution. It:\n\n* Validates LLM output (if `validateLLMOutput` is enabled)\n* Executes function calls with proper error handling\n* Renders components with provided props\n* Manages conversation state and localStorage persistence\n* Enforces `maxSteps` limits to prevent infinite loops\n\n### Functions\n\nFunctions are JavaScript functions you register in your config. They can:\n\n* Read application state\n* Modify data\n* Trigger side effects (API calls, navigation, etc.)\n* Return data that becomes context for the LLM\r\n  So it is you who decides what functions modalChat can acess\n\n### Components Registry\n\nYou can register React components that the LLM can render dynamically. This enables **generative UI**—the assistant can compose new interfaces on the fly based on user requests.\n\n### Proxy-First LLM Access\n\nAUTOUI uses a **proxy server** pattern for security:\n\n* Your OpenRouter API key stays on the server\n* The frontend only sends a client key (shared secret)\n* The proxy handles authentication and rate limiting\n* CORS and security policies are centralized\n\n## When to Use AUTOUI\n\n## When Not to Use AUTOUI\n\n## Architecture Diagram\n\n```\n┌─────────────┐\r\n│   User      │\r\n│  (Browser)  │\r\n└──────┬──────┘\r\n       │\r\n       │ Opens ModalChat\r\n       ▼\r\n┌─────────────────┐\r\n│   ModalChat     │ ◄─── AutoUIConfig\r\n│  (React Comp)   │      (functions, components, metadata)\r\n└──────┬──────────┘\r\n       │\r\n       │ Sends config + user message\r\n       ▼\r\n┌─────────────────┐\r\n│  Proxy Server   │\r\n│  (Your Backend) │ ◄─── OPENROUTER_API_KEY (server-side)\r\n└──────┬──────────┘\r\n       │\r\n       │ Forwards to LLM\r\n       ▼\r\n┌─────────────────┐\r\n│  OpenRouter     │\r\n│  / LLM Provider │\r\n└──────┬──────────┘\r\n       │\r\n       │ Returns Plan JSON\r\n       ▼\r\n┌─────────────────┐\r\n│  Frontend       │\r\n│  Runtime        │\r\n└──────┬──────────┘\r\n       │\r\n       │ Executes plan:\r\n       │ - callFunc(...)\r\n       │ - renderComponent(...)\r\n       ▼\r\n┌─────────────────┐\r\n│  Your App       │\r\n│  (State/UI)     │\r\n└─────────────────┘\n```\n\n## Next Steps\n\nReady to get started? Head to the [Installation & Configuration](/docs/installation) guide to set up AUTOUI in your React app.\n",
    "_searchMeta": {
      "cleanContent": "autoui is an npm library that integrates a ready-to-use modalchat component into any react application instead of building chat interfaces from scratch you provide a configuration object that describes your app s capabilities and autoui handles the rest from llm communication to plan execution to ui rendering how autoui works autoui follows a config-driven architecture where your application s capabilities are defined declaratively here s the high-level flow: key concepts modalchat the main react component you import and render it displays a chat interface typically as a floating button that opens a modal and manages the conversation flow config-driven ui your autouiconfig object is the contract between your app and the ai assistant it tells the llm: what your app does via metadata description and llm appdescriptionprompt what functions are available via functions what ui components can be rendered via components how to behave via runtime settings plan steps the llm returns a plan a structured json object that describes a sequence of actions the runtime executes these steps in order calling functions and rendering components as needed runtime the autoui runtime orchestrates plan execution it: validates llm output if validatellmoutput is enabled executes function calls with proper error handling renders components with provided props manages conversation state and localstorage persistence enforces maxsteps limits to prevent infinite loops functions functions are javascript functions you register in your config they can: read application state modify data trigger side effects api calls navigation etc return data that becomes context for the llm so it is you who decides what functions modalchat can acess components registry you can register react components that the llm can render dynamically this enables generative ui the assistant can compose new interfaces on the fly based on user requests proxy-first llm access autoui uses a proxy server pattern for security: your openrouter api key stays on the server the frontend only sends a client key shared secret the proxy handles authentication and rate limiting cors and security policies are centralized when to use autoui when not to use autoui architecture diagram next steps ready to get started head to the installation configuration guide to set up autoui in your react app",
      "headings": [
        "How AUTOUI Works",
        "Key Concepts",
        "When to Use AUTOUI",
        "When Not to Use AUTOUI",
        "Architecture Diagram",
        "Next Steps"
      ],
      "keywords": [
        "autoui",
        "introduction",
        "modalchat",
        "ai",
        "llm",
        "react",
        "How AUTOUI Works",
        "Key Concepts",
        "When to Use AUTOUI",
        "When Not to Use AUTOUI",
        "Architecture Diagram",
        "Next Steps",
        "ModalChat",
        "config-driven architecture",
        "contract",
        "plan",
        "generative UI",
        "proxy server",
        "User → ModalChat → Proxy Server → OpenRouter/LLM → Plan JSON → Frontend Runtime → Functions/Components",
        "## Key Concepts\n\n### ModalChat\n\nThe main React component you import and render. It displays a chat interface (typically as a floating button that opens a modal) and manages the conversation flow.",
        "tsx\nimport { ModalChat } from \"@autoai-ui/autoui\"\r\n\r\n<ModalChat config={myConfig} />",
        "### Config-Driven UI\n\nYour",
        "object is the **contract** between your app and the AI assistant. It tells the LLM:\n\n* What your app does (via",
        "and",
        ")\n* What functions are available (via",
        ")\n* What UI components can be rendered (via",
        ")\n* How to behave (via",
        "settings)\n\n### Plan & Steps\n\nThe LLM returns a **plan**—a structured JSON object that describes a sequence of actions. The runtime executes these steps in order, calling functions and rendering components as needed.\n\n### Runtime\n\nThe AUTOUI runtime orchestrates plan execution. It:\n\n* Validates LLM output (if",
        "is enabled)\n* Executes function calls with proper error handling\n* Renders components with provided props\n* Manages conversation state and localStorage persistence\n* Enforces",
        "limits to prevent infinite loops\n\n### Functions\n\nFunctions are JavaScript functions you register in your config. They can:\n\n* Read application state\n* Modify data\n* Trigger side effects (API calls, navigation, etc.)\n* Return data that becomes context for the LLM\r\n  So it is you who decides what functions modalChat can acess\n\n### Components Registry\n\nYou can register React components that the LLM can render dynamically. This enables **generative UI**—the assistant can compose new interfaces on the fly based on user requests.\n\n### Proxy-First LLM Access\n\nAUTOUI uses a **proxy server** pattern for security:\n\n* Your OpenRouter API key stays on the server\n* The frontend only sends a client key (shared secret)\n* The proxy handles authentication and rate limiting\n* CORS and security policies are centralized\n\n## When to Use AUTOUI\n\n## When Not to Use AUTOUI\n\n## Architecture Diagram",
        "┌─────────────┐\r\n│   User      │\r\n│  (Browser)  │\r\n└──────┬──────┘\r\n       │\r\n       │ Opens ModalChat\r\n       ▼\r\n┌─────────────────┐\r\n│   ModalChat     │ ◄─── AutoUIConfig\r\n│  (React Comp)   │      (functions, components, metadata)\r\n└──────┬──────────┘\r\n       │\r\n       │ Sends config + user message\r\n       ▼\r\n┌─────────────────┐\r\n│  Proxy Server   │\r\n│  (Your Backend) │ ◄─── OPENROUTER_API_KEY (server-side)\r\n└──────┬──────────┘\r\n       │\r\n       │ Forwards to LLM\r\n       ▼\r\n┌─────────────────┐\r\n│  OpenRouter     │\r\n│  / LLM Provider │\r\n└──────┬──────────┘\r\n       │\r\n       │ Returns Plan JSON\r\n       ▼\r\n┌─────────────────┐\r\n│  Frontend       │\r\n│  Runtime        │\r\n└──────┬──────────┘\r\n       │\r\n       │ Executes plan:\r\n       │ - callFunc(...)\r\n       │ - renderComponent(...)\r\n       ▼\r\n┌─────────────────┐\r\n│  Your App       │\r\n│  (State/UI)     │\r\n└─────────────────┘"
      ]
    }
  },
  {
    "slug": "/markdown/cards",
    "title": "Cards",
    "description": "Explore and implement various card styles, including small, large and image cards.",
    "content": "This section introduces the different card styles available in the system, from compact small cards to visually rich image cards. Each example is paired with JSX code snippets, providing you with a practical guide to incorporate these components seamlessly into your project.\n\n## Small Card\n\n```jsx\n<CardGrid>\r\n  <Card\r\n    title=\"Instructions\"\r\n    href=\"/docs/basic-setup/installation\"\r\n    icon=\"alignJustify\"\r\n    variant=\"small\"\r\n    description=\"test description\"\r\n  />\r\n  <Card\r\n    title=\"Setup\"\r\n    href=\"/docs/basic-setup/setup\"\r\n    icon=\"alignJustify\"\r\n    variant=\"small\"\r\n  />\r\n  <Card\r\n    title=\"Rubix Studios\"\r\n    href=\"https://rubixstudios.com.au\"\r\n    icon=\"alignJustify\"\r\n    external={true}\r\n    variant=\"small\"\r\n  />\r\n</CardGrid>\n```\n\n## Large Card\n\n```jsx\n<CardGrid>\r\n  <Card\r\n    subtitle=\"Instructions\"\r\n    title=\"Installation\"\r\n    description=\"Get started with Documents using our quick start installation guide to get your project started.\"\r\n    href=\"/docs/basic-setup/installation\"\r\n  />\r\n  <Card\r\n    subtitle=\"Setup\"\r\n    title=\"Site Settings\"\r\n    description=\"Setting up your Documents projects layout, links and search engine optimisation.\"\r\n    href=\"/docs/basic-setup/setup\"\r\n  />\r\n  <Card\r\n    subtitle=\"Support\"\r\n    title=\"Rubix Studios\"\r\n    description=\"Australia's leading branding, marketing and web development company.\"\r\n    href=\"https://rubixstudios.com.au\"\r\n    external={true}\r\n  />\r\n</CardGrid>\n```\n\n## Image Card\n\n```jsx\n<CardGrid>\r\n  <Card\r\n    title=\"Instructions\"\r\n    href=\"/docs/introduction/installation\"\r\n    image=\"/images/og-image.png\"\r\n    variant=\"image\"\r\n  />\r\n  <Card\r\n    title=\"Setup\"\r\n    href=\"/docs/introduction/setup\"\r\n    image=\"/images/og-image.png\"\r\n    variant=\"image\"\r\n  />\r\n  <Card\r\n    title=\"Rubix Studios\"\r\n    href=\"https://www.rubixstudios.com.au\"\r\n    image=\"/images/og-image.png\"\r\n    external={true}\r\n    variant=\"image\"\r\n  />\r\n</CardGrid>\n```\n",
    "_searchMeta": {
      "cleanContent": "this section introduces the different card styles available in the system from compact small cards to visually rich image cards each example is paired with jsx code snippets providing you with a practical guide to incorporate these components seamlessly into your project small card large card image card",
      "headings": [
        "Small Card",
        "Large Card",
        "Image Card"
      ],
      "keywords": [
        "Small Card",
        "Large Card",
        "Image Card",
        "jsx\n<CardGrid>\r\n  <Card\r\n    title=\"Instructions\"\r\n    href=\"/docs/basic-setup/installation\"\r\n    icon=\"alignJustify\"\r\n    variant=\"small\"\r\n    description=\"test description\"\r\n  />\r\n  <Card\r\n    title=\"Setup\"\r\n    href=\"/docs/basic-setup/setup\"\r\n    icon=\"alignJustify\"\r\n    variant=\"small\"\r\n  />\r\n  <Card\r\n    title=\"Rubix Studios\"\r\n    href=\"https://rubixstudios.com.au\"\r\n    icon=\"alignJustify\"\r\n    external={true}\r\n    variant=\"small\"\r\n  />\r\n</CardGrid>",
        "## Large Card",
        "jsx\n<CardGrid>\r\n  <Card\r\n    subtitle=\"Instructions\"\r\n    title=\"Installation\"\r\n    description=\"Get started with Documents using our quick start installation guide to get your project started.\"\r\n    href=\"/docs/basic-setup/installation\"\r\n  />\r\n  <Card\r\n    subtitle=\"Setup\"\r\n    title=\"Site Settings\"\r\n    description=\"Setting up your Documents projects layout, links and search engine optimisation.\"\r\n    href=\"/docs/basic-setup/setup\"\r\n  />\r\n  <Card\r\n    subtitle=\"Support\"\r\n    title=\"Rubix Studios\"\r\n    description=\"Australia's leading branding, marketing and web development company.\"\r\n    href=\"https://rubixstudios.com.au\"\r\n    external={true}\r\n  />\r\n</CardGrid>",
        "## Image Card",
        "jsx\n<CardGrid>\r\n  <Card\r\n    title=\"Instructions\"\r\n    href=\"/docs/introduction/installation\"\r\n    image=\"/images/og-image.png\"\r\n    variant=\"image\"\r\n  />\r\n  <Card\r\n    title=\"Setup\"\r\n    href=\"/docs/introduction/setup\"\r\n    image=\"/images/og-image.png\"\r\n    variant=\"image\"\r\n  />\r\n  <Card\r\n    title=\"Rubix Studios\"\r\n    href=\"https://www.rubixstudios.com.au\"\r\n    image=\"/images/og-image.png\"\r\n    external={true}\r\n    variant=\"image\"\r\n  />\r\n</CardGrid>"
      ]
    }
  },
  {
    "slug": "/markdown/diagrams",
    "title": "Diagrams",
    "description": "Add various diagram types, including flowcharts, decision trees and entity-relationship diagrams.",
    "content": "Diagrams are powerful tools for visualizing processes, relationships, and decisions. This section showcases different types of diagrams created using **Mermaid**, complete with examples and reusable code snippets to integrate into your projects.\n\n## Flowchart\n\nA flowchart represents a sequence of steps or processes in a visual format. Use this diagram to map workflows, decision-making processes, or operational flows.\n\n```jsx\n<Mermaid\r\n  chart={\\`\r\n    graph TD;\r\n    Start --> Task1;\r\n    Task1 --> Task2;\r\n    Task2 --> End;\r\n  \\`}\r\n/>\n```\n\n## Decision Tree\n\nDecision trees illustrate choices and possible outcomes, making them ideal for decision-making workflows or processes involving multiple paths.\n\n```jsx\n<Mermaid\r\n  chart={\\`\r\n    graph TD;\r\n    A[Start] --> B{Is it raining?};\r\n    B -->|Yes| C[Take an umbrella];\r\n    B -->|No| D[Enjoy the weather];\r\n    C --> E[Go outside];\r\n    D --> E;\r\n  \\`}\r\n/>\n```\n\n## Entity-Relationship Diagram\n\nEntity-relationship diagrams (ERDs) are used to model relationships between entities in a system. They are widely used in database design and system architecture planning.\n\n```jsx\n<Mermaid\r\n  chart={\\`\r\n    erDiagram\r\n    CUSTOMER ||--o{ ORDER : places\r\n    ORDER ||--|{ LINE-ITEM : contains\r\n    PRODUCT ||--o{ LINE-ITEM : \"included in\"\r\n    CUSTOMER {\r\n        string name\r\n        string email\r\n    }\r\n    ORDER {\r\n        int orderNumber\r\n        date orderDate\r\n    }\r\n    LINE-ITEM {\r\n        int quantity\r\n        float price\r\n    }\r\n    PRODUCT {\r\n        int productId\r\n        string name\r\n        float price\r\n    }\r\n  \\`}\r\n/>\n```\n\nEach of these diagrams serves a specific purpose and Mermaid makes it easy to generate them dynamically. Feel free to experiment with the provided code snippets and adapt them to your needs.\n",
    "_searchMeta": {
      "cleanContent": "diagrams are powerful tools for visualizing processes relationships and decisions this section showcases different types of diagrams created using mermaid complete with examples and reusable code snippets to integrate into your projects flowchart a flowchart represents a sequence of steps or processes in a visual format use this diagram to map workflows decision-making processes or operational flows decision tree decision trees illustrate choices and possible outcomes making them ideal for decision-making workflows or processes involving multiple paths entity-relationship diagram entity-relationship diagrams erds are used to model relationships between entities in a system they are widely used in database design and system architecture planning each of these diagrams serves a specific purpose and mermaid makes it easy to generate them dynamically feel free to experiment with the provided code snippets and adapt them to your needs",
      "headings": [
        "Flowchart",
        "Decision Tree",
        "Entity-Relationship Diagram"
      ],
      "keywords": [
        "Flowchart",
        "Decision Tree",
        "Entity-Relationship Diagram",
        "Mermaid",
        "jsx\n<Mermaid\r\n  chart={\\",
        "}\r\n/>",
        "## Decision Tree\n\nDecision trees illustrate choices and possible outcomes, making them ideal for decision-making workflows or processes involving multiple paths.",
        "## Entity-Relationship Diagram\n\nEntity-relationship diagrams (ERDs) are used to model relationships between entities in a system. They are widely used in database design and system architecture planning."
      ]
    }
  },
  {
    "slug": "/markdown/filetree",
    "title": "Filetree",
    "description": "This section provides an overview of file structures and their implementation using the FileTree component.",
    "content": "This section demonstrates the structure of a file tree using the `FileTree` component. Below is an example showcasing folders and files organized hierarchically for a project setup.\n\n## How to Use\n\nIntegrate the `FileTree` component into your project to visually represent file and folder structures. This is particularly useful for documentation, tutorials, or providing users with an overview of your project's architecture.\n\n### JSX Code Example\n\nHere is how you can define the file tree structure in for use in your project:\n\n```jsx\n<FileTree>\r\n  <Folder name=\"src\" label=\"Source Code\">\r\n    <File name=\"index.tsx\" label=\"Index File\" />\r\n    <Folder name=\"components\" label=\"Components\">\r\n      <File name=\"button.tsx\" label=\"Button Component\" />\r\n      <File name=\"input.tsx\" label=\"Input Component\" />\r\n    </Folder>\r\n    <Folder name=\"pages\" label=\"Pages\">\r\n      <File name=\"home.tsx\" label=\"Home Page\" />\r\n      <File name=\"about.tsx\" label=\"About Page\" />\r\n    </Folder>\r\n  </Folder>\r\n</FileTree>\n```\n\nUse this code as a template to set up your own file tree structure and customize it as needed.\n",
    "_searchMeta": {
      "cleanContent": "this section demonstrates the structure of a file tree using the filetree component below is an example showcasing folders and files organized hierarchically for a project setup how to use integrate the filetree component into your project to visually represent file and folder structures this is particularly useful for documentation tutorials or providing users with an overview of your project s architecture jsx code example here is how you can define the file tree structure in for use in your project: use this code as a template to set up your own file tree structure and customize it as needed",
      "headings": [
        "How to Use"
      ],
      "keywords": [
        "How to Use",
        "FileTree",
        "jsx\n<FileTree>\r\n  <Folder name=\"src\" label=\"Source Code\">\r\n    <File name=\"index.tsx\" label=\"Index File\" />\r\n    <Folder name=\"components\" label=\"Components\">\r\n      <File name=\"button.tsx\" label=\"Button Component\" />\r\n      <File name=\"input.tsx\" label=\"Input Component\" />\r\n    </Folder>\r\n    <Folder name=\"pages\" label=\"Pages\">\r\n      <File name=\"home.tsx\" label=\"Home Page\" />\r\n      <File name=\"about.tsx\" label=\"About Page\" />\r\n    </Folder>\r\n  </Folder>\r\n</FileTree>"
      ]
    }
  },
  {
    "slug": "/markdown",
    "title": "Introduction",
    "description": "This section provides an overview of Introduction.",
    "content": "Lorem ipsum dolor sit amet consectetur adipisicing elit. Numquam iste dolorum tempore consectetur explicabo tempora provident quia maxime, molestiae, facilis aperiam et, error illum vel ullam? Quis architecto dolore ullam\n\n* \\[x] Write the press release\n* \\[ ] Update the website\n* \\[ ] Contact the media\n\n| Syntax        | Description |   Test Text |\r\n| :------------ | :---------: | ----------: |\r\n| Header        |    Title    | Here's this |\r\n| Paragraph     |    Text     |    And more |\r\n| Strikethrough |             |    ~~Text~~ |\n\n## Sample Document with Mermaid\n\nHere is a Mermaid diagram:\n\nThis diagram should render automatically without any extra imports.\n\n## Getting Started\n\nTo begin using the Documentation Template, follow these simple steps:\n\n* Start by cloning the repository to your local machine.\n\nLorem ipsum dolor sit amet consectetur adipisicing elit. Reprehenderit quae iure nulla deserunt dolore quam pariatur minus sapiente accusantium. Optio, necessitatibus sequi. Veritatis, aspernatur? Possimus quis repellat eum vitae eveniet.\n\n## Blockquotes\n\nBlockquotes are useful for emphasizing key points or quoting external sources:\n\n> \"Documentation is a love letter that you write to your future self.\" - Damian Conway\n\nFeel free to use blockquotes to highlight important information or quotes relevant to your documentation.\n\n## Code Examples with switch\n\nHere a custom tab component from shadcn ui is used.\n\n## Conclusion\n\nThank you for choosing the Documentation Template for your project. Whether you're documenting software, APIs, or processes, we're here to support you in creating clear and effective documentation. Happy documenting!\n",
    "_searchMeta": {
      "cleanContent": "lorem ipsum dolor sit amet consectetur adipisicing elit numquam iste dolorum tempore consectetur explicabo tempora provident quia maxime molestiae facilis aperiam et error illum vel ullam quis architecto dolore ullam x write the press release update the website contact the media syntax description test text :------------ :---------: ----------: header title here s this paragraph text and more strikethrough text sample document with mermaid here is a mermaid diagram: this diagram should render automatically without any extra imports getting started to begin using the documentation template follow these simple steps: start by cloning the repository to your local machine lorem ipsum dolor sit amet consectetur adipisicing elit reprehenderit quae iure nulla deserunt dolore quam pariatur minus sapiente accusantium optio necessitatibus sequi veritatis aspernatur possimus quis repellat eum vitae eveniet blockquotes blockquotes are useful for emphasizing key points or quoting external sources: documentation is a love letter that you write to your future self - damian conway feel free to use blockquotes to highlight important information or quotes relevant to your documentation code examples with switch here a custom tab component from shadcn ui is used conclusion thank you for choosing the documentation template for your project whether you re documenting software apis or processes we re here to support you in creating clear and effective documentation happy documenting",
      "headings": [
        "Sample Document with Mermaid",
        "Getting Started",
        "Blockquotes",
        "Code Examples with switch",
        "Conclusion"
      ],
      "keywords": [
        "Sample Document with Mermaid",
        "Getting Started",
        "Blockquotes",
        "Code Examples with switch",
        "Conclusion"
      ]
    }
  },
  {
    "slug": "/markdown/lists",
    "title": "Lists",
    "description": "This section provides an overview of creating and using lists in the Documents boilerplate.",
    "content": "Learn how to create and render different types of lists in the Documents boilerplate. Examples include checklists, ordered lists, unordered lists and nested lists.\n\n## Checklist\n\n* \\[x] Write the press release\n* \\[ ] Update the website\n* \\[ ] Contact the media\n\n```jsx\n- [x] Write the press release\r\n- [ ] Update the website\r\n- [ ] Contact the media\n```\n\n## Simple List\n\n* Item 1\n* Item 2\n* Item 3\n\n```jsx\n- Item 1\r\n- Item 2\r\n- Item 3\n```\n\n## Number List\n\n1. Research\n2. Draft the content\n3. Review and edit\n4. Publish\n\n```jsx\n1. Research\r\n2. Draft the content\r\n3. Review and edit\r\n4. Publish\n```\n\n## Nested List\n\n* Main Category 1\n  * Sub Item 1.1\n  * Sub Item 1.2\n* Main Category 2\n  * Sub Item 2.1\n  * Sub Item 2.2\n\n```jsx\n- Main Category 1\r\n  - Sub Item 1.1\r\n  - Sub Item 1.2\r\n- Main Category 2\r\n  - Sub Item 2.1\r\n  - Sub Item 2.2\n```\n\nUse these examples as a foundation to create and customize lists that fit your project's needs.\n",
    "_searchMeta": {
      "cleanContent": "learn how to create and render different types of lists in the documents boilerplate examples include checklists ordered lists unordered lists and nested lists checklist x write the press release update the website contact the media simple list item 1 item 2 item 3 number list research draft the content review and edit publish nested list main category 1 sub item 1 1 sub item 1 2 main category 2 sub item 2 1 sub item 2 2 use these examples as a foundation to create and customize lists that fit your project s needs",
      "headings": [
        "Checklist",
        "Simple List",
        "Number List",
        "Nested List"
      ],
      "keywords": [
        "Checklist",
        "Simple List",
        "Number List",
        "Nested List",
        "jsx\n- [x] Write the press release\r\n- [ ] Update the website\r\n- [ ] Contact the media",
        "## Simple List\n\n* Item 1\n* Item 2\n* Item 3",
        "jsx\n- Item 1\r\n- Item 2\r\n- Item 3",
        "## Number List\n\n1. Research\n2. Draft the content\n3. Review and edit\n4. Publish",
        "jsx\n1. Research\r\n2. Draft the content\r\n3. Review and edit\r\n4. Publish",
        "## Nested List\n\n* Main Category 1\n  * Sub Item 1.1\n  * Sub Item 1.2\n* Main Category 2\n  * Sub Item 2.1\n  * Sub Item 2.2",
        "jsx\n- Main Category 1\r\n  - Sub Item 1.1\r\n  - Sub Item 1.2\r\n- Main Category 2\r\n  - Sub Item 2.1\r\n  - Sub Item 2.2"
      ]
    }
  },
  {
    "slug": "/markdown/maths",
    "title": "Maths",
    "description": "This section provides an overview of Introduction.",
    "content": "Lorem ipsum dolor sit amet consectetur adipisicing elit. Numquam iste dolorum tempore consectetur explicabo tempora provident quia maxime, molestiae, facilis aperiam et, error illum vel ullam? Quis architecto dolore ullam\n\n## Basic Algebra\n\nThe area of a circle ($$A$$) can be calculated using the radius ($$r$$) as follows:\n\n```math\nA = \\pi r^2\n```\n\n## Quadratic Formula\n\nThe quadratic formula for solving an equation of the form $$ax^2 + bx + c = 0$$ is:\n\n```math\nx = \\frac{-b \\pm \\sqrt{b^2 - 4ac}}{2a}\n```\n\n## Newton's Second Law of Motion\n\nNewton's second law of motion states that force ($$F$$) is the product of mass ($$m$$) and acceleration ($$a$$):\n\n```math\nF = ma\n```\n\n## Pythagorean Theorem\n\nThe Pythagorean theorem relates the lengths of the sides of a right triangle:\n\n```math\na^2 + b^2 = c^2\n```\n\n## Einstein's Mass-Energy Equivalence\n\nEinstein's famous equation relates energy ($$E$$), mass ($$m$$), and the speed of light ($$c$$):\n\n```math\nE = mc^2\n```\n",
    "_searchMeta": {
      "cleanContent": "lorem ipsum dolor sit amet consectetur adipisicing elit numquam iste dolorum tempore consectetur explicabo tempora provident quia maxime molestiae facilis aperiam et error illum vel ullam quis architecto dolore ullam basic algebra the area of a circle a can be calculated using the radius r as follows: quadratic formula the quadratic formula for solving an equation of the form ax 2 bx c 0 is: newton s second law of motion newton s second law of motion states that force f is the product of mass m and acceleration a : pythagorean theorem the pythagorean theorem relates the lengths of the sides of a right triangle: einstein s mass-energy equivalence einstein s famous equation relates energy e mass m and the speed of light c :",
      "headings": [
        "Basic Algebra",
        "Quadratic Formula",
        "Newton's Second Law of Motion",
        "Pythagorean Theorem",
        "Einstein's Mass-Energy Equivalence"
      ],
      "keywords": [
        "Basic Algebra",
        "Quadratic Formula",
        "Newton's Second Law of Motion",
        "Pythagorean Theorem",
        "Einstein's Mass-Energy Equivalence",
        "math\nA = \\pi r^2",
        "## Quadratic Formula\n\nThe quadratic formula for solving an equation of the form $$ax^2 + bx + c = 0$$ is:",
        "math\nx = \\frac{-b \\pm \\sqrt{b^2 - 4ac}}{2a}",
        "## Newton's Second Law of Motion\n\nNewton's second law of motion states that force ($$F$$) is the product of mass ($$m$$) and acceleration ($$a$$):",
        "math\nF = ma",
        "## Pythagorean Theorem\n\nThe Pythagorean theorem relates the lengths of the sides of a right triangle:",
        "math\na^2 + b^2 = c^2",
        "## Einstein's Mass-Energy Equivalence\n\nEinstein's famous equation relates energy ($$E$$), mass ($$m$$), and the speed of light ($$c$$):",
        "math\nE = mc^2"
      ]
    }
  },
  {
    "slug": "/markdown/notes",
    "title": "Notes",
    "description": "This section provides an overview of Introduction.",
    "content": "Lorem ipsum dolor sit amet consectetur adipisicing elit. Numquam iste dolorum tempore consectetur explicabo tempora provident quia maxime, molestiae, facilis aperiam et, error illum vel ullam? Quis architecto dolore ullam\n\n## Standard Note\n\n## Success Note\n\n## Warning Note\n\n## Danger Note\n",
    "_searchMeta": {
      "cleanContent": "lorem ipsum dolor sit amet consectetur adipisicing elit numquam iste dolorum tempore consectetur explicabo tempora provident quia maxime molestiae facilis aperiam et error illum vel ullam quis architecto dolore ullam standard note success note warning note danger note",
      "headings": [
        "Standard Note",
        "Success Note",
        "Warning Note",
        "Danger Note"
      ],
      "keywords": [
        "Standard Note",
        "Success Note",
        "Warning Note",
        "Danger Note"
      ]
    }
  },
  {
    "slug": "/markdown/steps",
    "title": "Steps",
    "description": "This section provides an overview of Introduction.",
    "content": "The `<Step>` and `<StepItem>` components allow you to create structured step-by-step guides in your documentation. These components are particularly useful when you want to break down a process or tutorial into easy-to-follow stages.\n\n## Steps\n\nTo create a step-by-step guide in your MDX, you can use the following structure:\n",
    "_searchMeta": {
      "cleanContent": "the step and stepitem components allow you to create structured step-by-step guides in your documentation these components are particularly useful when you want to break down a process or tutorial into easy-to-follow stages steps to create a step-by-step guide in your mdx you can use the following structure:",
      "headings": [
        "Steps"
      ],
      "keywords": [
        "Steps",
        "<Step>",
        "<StepItem>"
      ]
    }
  },
  {
    "slug": "/markdown/table",
    "title": "Table",
    "description": "This section provides an overview of Introduction.",
    "content": "Lorem ipsum dolor sit amet consectetur adipisicing elit. Numquam iste dolorum tempore consectetur explicabo tempora provident quia maxime, molestiae, facilis aperiam et, error illum vel ullam? Quis architecto dolore ullam\n\n| Syntax        | Description |   Test Text |\r\n| :------------ | :---------: | ----------: |\r\n| Header        |    Title    | Here's this |\r\n| Paragraph     |    Text     |    And more |\r\n| Strikethrough |             |    ~~Text~~ |\n\n| Feature       | Documentation Link |                    Notes |\r\n| :------------ | :----------------: | -----------------------: |\r\n| **Feature A** |     [Docs](#)      | For more info click here |\r\n| **Feature B** |     [Guide](#)     |  See the full guide here |\r\n| **Feature C** |     [Setup](#)     |       Setup instructions |\n",
    "_searchMeta": {
      "cleanContent": "lorem ipsum dolor sit amet consectetur adipisicing elit numquam iste dolorum tempore consectetur explicabo tempora provident quia maxime molestiae facilis aperiam et error illum vel ullam quis architecto dolore ullam syntax description test text :------------ :---------: ----------: header title here s this paragraph text and more strikethrough text feature documentation link notes :------------ :----------------: -----------------------: feature a docs for more info click here feature b guide see the full guide here feature c setup setup instructions",
      "headings": [],
      "keywords": [
        "Feature A",
        "Feature B",
        "Feature C"
      ]
    }
  },
  {
    "slug": "/markdown/tabs",
    "title": "Tabs",
    "description": "This section provides an overview of Introduction.",
    "content": "Lorem ipsum dolor sit amet consectetur adipisicing elit. Numquam iste dolorum tempore consectetur explicabo tempora provident quia maxime, molestiae, facilis aperiam et, error illum vel ullam? Quis architecto dolore ullam\n\n## Code Examples with switch\n\nHere a custom tab component from shadcn ui is used.\n",
    "_searchMeta": {
      "cleanContent": "lorem ipsum dolor sit amet consectetur adipisicing elit numquam iste dolorum tempore consectetur explicabo tempora provident quia maxime molestiae facilis aperiam et error illum vel ullam quis architecto dolore ullam code examples with switch here a custom tab component from shadcn ui is used",
      "headings": [
        "Code Examples with switch"
      ],
      "keywords": [
        "Code Examples with switch"
      ]
    }
  },
  {
    "slug": "/navigation",
    "title": "Navigation",
    "description": "How to build our your documents menu and navigations.",
    "content": "",
    "_searchMeta": {
      "cleanContent": "",
      "headings": [],
      "keywords": [
        "navigation",
        "sidebar",
        "menus",
        "mdx",
        "nextjs",
        "documents"
      ]
    }
  },
  {
    "slug": "/quickstart",
    "title": "Quick Start",
    "description": "Get started with AUTOUI in minutes. Choose your framework and follow the simple setup guide.",
    "content": "Get AUTOUI up and running in your React or Next.js app in just a few minutes.\n\n## Choose Your Framework\n\n## What You'll Need\n\n* A React or Next.js project\n* A backend proxy server (we'll help you set this up)\n* An OpenRouter API key (or similar LLM provider)\n\n## Installation\n\n```bash\nnpm install @autoai-ui/autoui\n```\n\nor\n\n```bash\nyarn add @autoai-ui/autoui\n```\n\nor\n\n```bash\npnpm add @autoai-ui/autoui\n```\n\n## Next Steps\n\n1. **Set up your backend proxy** - See [Backend Proxy Setup](/docs/backend-proxy)\n2. **Choose your framework** - Follow the React or Next.js guide\n3. **Configure AUTOUI** - See [Config Explanation](/docs/config)\n\nReady to dive in? Pick your framework above and let's get started!\n",
    "_searchMeta": {
      "cleanContent": "get autoui up and running in your react or next js app in just a few minutes choose your framework what you ll need a react or next js project a backend proxy server we ll help you set this up an openrouter api key or similar llm provider installation or or next steps set up your backend proxy - see backend proxy setup choose your framework - follow the react or next js guide configure autoui - see config explanation ready to dive in pick your framework above and let s get started",
      "headings": [
        "Choose Your Framework",
        "What You'll Need",
        "Installation",
        "Next Steps"
      ],
      "keywords": [
        "quickstart",
        "getting started",
        "setup",
        "installation",
        "Choose Your Framework",
        "What You'll Need",
        "Installation",
        "Next Steps",
        "Set up your backend proxy",
        "Choose your framework",
        "Configure AUTOUI",
        "bash\nnpm install @autoai-ui/autoui",
        "or",
        "bash\nyarn add @autoai-ui/autoui",
        "bash\npnpm add @autoai-ui/autoui"
      ]
    }
  },
  {
    "slug": "/quickstart/nextjs",
    "title": "Quick Start - Next.js",
    "description": "Get started with AUTOUI in a Next.js application. Optimized for App Router and SSR.",
    "content": "Get AUTOUI running in your Next.js app in 5 minutes.\n\n## Step 1: Install AUTOUI\n\n```bash\nnpm install @autoai-ui/autoui\n```\n\n## Step 2: Set Up Backend Proxy\n\nYou'll need a backend proxy server. See [Backend Proxy Setup](/docs/backend-proxy) for details.\n\nFor now, you'll need:\n\n* `PROXY_URL` - Your proxy server URL (e.g., `http://localhost:3001`)\n* `SHARED_SECRET` - Your proxy shared secret\n\n## Step 3: Create Your Config\n\nCreate `lib/autoui-config.tsx` (note: `.tsx` for client component):\n\n```tsx\n\"use client\"\r\n\r\nimport { AutoUIConfig } from \"@autoai-ui/autoui\"\r\n\r\nexport function createAutoUIConfig(): AutoUIConfig {\r\n  return {\r\n    appId: 'my-nextjs-app',\r\n    \r\n    llm: {\r\n      proxyUrl: process.env.NEXT_PUBLIC_PROXY_URL || 'http://localhost:3001',\r\n      sharedSecret: process.env.NEXT_PUBLIC_SHARED_SECRET,\r\n      appDescriptionPrompt: 'A Next.js application with an AI assistant.',\r\n    },\r\n    \r\n    runtime: {\r\n      validateLLMOutput: true,\r\n      storeChatToLocalStorage: true,\r\n      maxSteps: 20,\r\n    },\r\n  }\r\n}\n```\n\n## Step 4: Create Chat Component\n\nCreate `components/autoui-chat.tsx`:\n\n```tsx\n\"use client\"\r\n\r\nimport { ModalChat } from \"@autoai-ui/autoui\"\r\nimport dynamic from \"next/dynamic\"\r\nimport { useMemo } from \"react\"\r\nimport { createAutoUIConfig } from \"@/lib/autoui-config\"\r\n\r\nconst DynamicModalChat = dynamic(\r\n  () => import(\"@autoai-ui/autoui\").then(m => m.ModalChat),\r\n  { ssr: false }  // ← Critical: Must disable SSR\r\n)\r\n\r\nexport function AutoUIChat() {\r\n  const config = useMemo(() => createAutoUIConfig(), [])\r\n  \r\n  return <DynamicModalChat config={config} />\r\n}\n```\n\n## Step 5: Add to Layout\n\nAdd to your `app/layout.tsx`:\n\n```tsx\nimport { AutoUIChat } from \"@/components/autoui-chat\"\r\n\r\nexport default function RootLayout({ children }) {\r\n  return (\r\n    <html>\r\n      <body>\r\n        {children}\r\n        <AutoUIChat />\r\n      </body>\r\n    </html>\r\n  )\r\n}\n```\n\n## Step 6: Environment Variables\n\nCreate `.env.local`:\n\n```env\nNEXT_PUBLIC_PROXY_URL=http://localhost:3001\r\nNEXT_PUBLIC_SHARED_SECRET=your-shared-secret\n```\n\n## That's It!\n\nYou should now see a chat button in the bottom-right corner. Click it to start chatting!\n\n## Next Steps\n\n* Add [Functions](/docs/functions) to enable AI actions\n* Add [Components](/docs/components) for generative UI\n* Learn [Best Practices](/docs/best-practices/nextjs) for Next.js apps\n",
    "_searchMeta": {
      "cleanContent": "get autoui running in your next js app in 5 minutes step 1: install autoui step 2: set up backend proxy you ll need a backend proxy server see backend proxy setup for details for now you ll need: proxy_url - your proxy server url e g http: localhost:3001 shared_secret - your proxy shared secret step 3: create your config create lib autoui-config tsx note: tsx for client component : step 4: create chat component create components autoui-chat tsx: step 5: add to layout add to your app layout tsx: step 6: environment variables create env local: that s it you should now see a chat button in the bottom-right corner click it to start chatting next steps add functions to enable ai actions add components for generative ui learn best practices for next js apps",
      "headings": [
        "Step 1: Install AUTOUI",
        "Step 2: Set Up Backend Proxy",
        "Step 3: Create Your Config",
        "Step 4: Create Chat Component",
        "Step 5: Add to Layout",
        "Step 6: Environment Variables",
        "That's It!",
        "Next Steps"
      ],
      "keywords": [
        "nextjs",
        "next.js",
        "quickstart",
        "setup",
        "app router",
        "Step 1: Install AUTOUI",
        "Step 2: Set Up Backend Proxy",
        "Step 3: Create Your Config",
        "Step 4: Create Chat Component",
        "Step 5: Add to Layout",
        "Step 6: Environment Variables",
        "That's It!",
        "Next Steps",
        "bash\nnpm install @autoai-ui/autoui",
        "## Step 2: Set Up Backend Proxy\n\nYou'll need a backend proxy server. See [Backend Proxy Setup](/docs/backend-proxy) for details.\n\nFor now, you'll need:\n\n*",
        "- Your proxy server URL (e.g.,",
        ")\n*",
        "- Your proxy shared secret\n\n## Step 3: Create Your Config\n\nCreate",
        "(note:",
        "for client component):",
        "tsx\n\"use client\"\r\n\r\nimport { AutoUIConfig } from \"@autoai-ui/autoui\"\r\n\r\nexport function createAutoUIConfig(): AutoUIConfig {\r\n  return {\r\n    appId: 'my-nextjs-app',\r\n    \r\n    llm: {\r\n      proxyUrl: process.env.NEXT_PUBLIC_PROXY_URL || 'http://localhost:3001',\r\n      sharedSecret: process.env.NEXT_PUBLIC_SHARED_SECRET,\r\n      appDescriptionPrompt: 'A Next.js application with an AI assistant.',\r\n    },\r\n    \r\n    runtime: {\r\n      validateLLMOutput: true,\r\n      storeChatToLocalStorage: true,\r\n      maxSteps: 20,\r\n    },\r\n  }\r\n}",
        "## Step 4: Create Chat Component\n\nCreate",
        ":",
        "tsx\n\"use client\"\r\n\r\nimport { ModalChat } from \"@autoai-ui/autoui\"\r\nimport dynamic from \"next/dynamic\"\r\nimport { useMemo } from \"react\"\r\nimport { createAutoUIConfig } from \"@/lib/autoui-config\"\r\n\r\nconst DynamicModalChat = dynamic(\r\n  () => import(\"@autoai-ui/autoui\").then(m => m.ModalChat),\r\n  { ssr: false }  // ← Critical: Must disable SSR\r\n)\r\n\r\nexport function AutoUIChat() {\r\n  const config = useMemo(() => createAutoUIConfig(), [])\r\n  \r\n  return <DynamicModalChat config={config} />\r\n}",
        "## Step 5: Add to Layout\n\nAdd to your",
        "tsx\nimport { AutoUIChat } from \"@/components/autoui-chat\"\r\n\r\nexport default function RootLayout({ children }) {\r\n  return (\r\n    <html>\r\n      <body>\r\n        {children}\r\n        <AutoUIChat />\r\n      </body>\r\n    </html>\r\n  )\r\n}",
        "## Step 6: Environment Variables\n\nCreate",
        "env\nNEXT_PUBLIC_PROXY_URL=http://localhost:3001\r\nNEXT_PUBLIC_SHARED_SECRET=your-shared-secret"
      ]
    }
  },
  {
    "slug": "/quickstart/react",
    "title": "Quick Start - React",
    "description": "Get started with AUTOUI in a React application. Simple, step-by-step guide.",
    "content": "Get AUTOUI running in your React app in 5 minutes.\n\n## Step 1: Install AUTOUI\n\n```bash\nnpm install @autoai-ui/autoui\n```\n\n## Step 2: Set Up Backend Proxy\n\nYou'll need a backend proxy server. See [Backend Proxy Setup](/docs/backend-proxy) for details.\n\nFor now, you'll need:\n\n* `PROXY_URL` - Your proxy server URL (e.g., `http://localhost:3001`)\n* `SHARED_SECRET` - Your proxy shared secret\n\n## Step 3: Create Your Config\n\nCreate `lib/autoui-config.ts`:\n\n```tsx\nimport { AutoUIConfig } from \"@autoai-ui/autoui\"\r\n\r\nexport function createAutoUIConfig(): AutoUIConfig {\r\n  return {\r\n    appId: 'my-react-app',\r\n    \r\n    llm: {\r\n      proxyUrl: process.env.REACT_APP_PROXY_URL || 'http://localhost:3001',\r\n      sharedSecret: process.env.REACT_APP_SHARED_SECRET,\r\n      appDescriptionPrompt: 'A React application with an AI assistant.',\r\n    },\r\n    \r\n    runtime: {\r\n      validateLLMOutput: true,\r\n      storeChatToLocalStorage: true,\r\n      maxSteps: 20,\r\n    },\r\n  }\r\n}\n```\n\n## Step 4: Add ModalChat\n\nIn your main App component:\n\n```tsx\nimport { ModalChat } from \"@autoai-ui/autoui\"\r\nimport { createAutoUIConfig } from \"./lib/autoui-config\"\r\n\r\nfunction App() {\r\n  const config = createAutoUIConfig()\r\n  \r\n  return (\r\n    <div>\r\n      <h1>My App</h1>\r\n      <ModalChat config={config} />\r\n    </div>\r\n  )\r\n}\r\n\r\nexport default App\n```\n\n## Step 5: Environment Variables\n\nCreate `.env` file:\n\n```env\nREACT_APP_PROXY_URL=http://localhost:3001\r\nREACT_APP_SHARED_SECRET=your-shared-secret\n```\n\n## That's It!\n\nYou should now see a chat button in the bottom-right corner. Click it to start chatting!\n\n## Next Steps\n\n* Add [Functions](/docs/functions) to enable AI actions\n* Add [Components](/docs/components) for generative UI\n* Learn [Best Practices](/docs/best-practices/react) for React apps\n",
    "_searchMeta": {
      "cleanContent": "get autoui running in your react app in 5 minutes step 1: install autoui step 2: set up backend proxy you ll need a backend proxy server see backend proxy setup for details for now you ll need: proxy_url - your proxy server url e g http: localhost:3001 shared_secret - your proxy shared secret step 3: create your config create lib autoui-config ts: step 4: add modalchat in your main app component: step 5: environment variables create env file: that s it you should now see a chat button in the bottom-right corner click it to start chatting next steps add functions to enable ai actions add components for generative ui learn best practices for react apps",
      "headings": [
        "Step 1: Install AUTOUI",
        "Step 2: Set Up Backend Proxy",
        "Step 3: Create Your Config",
        "Step 4: Add ModalChat",
        "Step 5: Environment Variables",
        "That's It!",
        "Next Steps"
      ],
      "keywords": [
        "react",
        "quickstart",
        "setup",
        "create react app",
        "vite",
        "Step 1: Install AUTOUI",
        "Step 2: Set Up Backend Proxy",
        "Step 3: Create Your Config",
        "Step 4: Add ModalChat",
        "Step 5: Environment Variables",
        "That's It!",
        "Next Steps",
        "bash\nnpm install @autoai-ui/autoui",
        "## Step 2: Set Up Backend Proxy\n\nYou'll need a backend proxy server. See [Backend Proxy Setup](/docs/backend-proxy) for details.\n\nFor now, you'll need:\n\n*",
        "- Your proxy server URL (e.g.,",
        ")\n*",
        "- Your proxy shared secret\n\n## Step 3: Create Your Config\n\nCreate",
        ":",
        "tsx\nimport { AutoUIConfig } from \"@autoai-ui/autoui\"\r\n\r\nexport function createAutoUIConfig(): AutoUIConfig {\r\n  return {\r\n    appId: 'my-react-app',\r\n    \r\n    llm: {\r\n      proxyUrl: process.env.REACT_APP_PROXY_URL || 'http://localhost:3001',\r\n      sharedSecret: process.env.REACT_APP_SHARED_SECRET,\r\n      appDescriptionPrompt: 'A React application with an AI assistant.',\r\n    },\r\n    \r\n    runtime: {\r\n      validateLLMOutput: true,\r\n      storeChatToLocalStorage: true,\r\n      maxSteps: 20,\r\n    },\r\n  }\r\n}",
        "## Step 4: Add ModalChat\n\nIn your main App component:",
        "tsx\nimport { ModalChat } from \"@autoai-ui/autoui\"\r\nimport { createAutoUIConfig } from \"./lib/autoui-config\"\r\n\r\nfunction App() {\r\n  const config = createAutoUIConfig()\r\n  \r\n  return (\r\n    <div>\r\n      <h1>My App</h1>\r\n      <ModalChat config={config} />\r\n    </div>\r\n  )\r\n}\r\n\r\nexport default App",
        "## Step 5: Environment Variables\n\nCreate",
        "file:",
        "env\nREACT_APP_PROXY_URL=http://localhost:3001\r\nREACT_APP_SHARED_SECRET=your-shared-secret"
      ]
    }
  },
  {
    "slug": "/random",
    "title": "Introduction",
    "description": "This section provides an overview of Introduction.",
    "content": "Lorem ipsum dolor sit amet consectetur adipisicing elit. Numquam iste dolorum tempore consectetur explicabo tempora provident quia maxime, molestiae, facilis aperiam et, error illum vel ullam? Quis architecto dolore ullam\n\n* \\[x] Write the press release\n* \\[ ] Update the website\n* \\[ ] Contact the media\n\n| Syntax        | Description |   Test Text |\r\n| :------------ | :---------: | ----------: |\r\n| Header        |    Title    | Here's this |\r\n| Paragraph     |    Text     |    And more |\r\n| Strikethrough |             |    ~~Text~~ |\n\n## Getting Started\n\nTo begin using the Documentation Template, follow these simple steps:\n\n* Start by cloning the repository to your local machine.\n\nLorem ipsum dolor sit amet consectetur adipisicing elit. Reprehenderit quae iure nulla deserunt dolore quam pariatur minus sapiente accusantium. Optio, necessitatibus sequi. Veritatis, aspernatur? Possimus quis repellat eum vitae eveniet.\n\n## Blockquotes\n\nBlockquotes are useful for emphasizing key points or quoting external sources:\n\n> \"Documentation is a love letter that you write to your future self.\" - Damian Conway\n\nFeel free to use blockquotes to highlight important information or quotes relevant to your documentation.\n\n## Code Examples with switch\n\nHere a custom tab component from shadcn ui is used.\n\n## Conclusion\n\nAdding some random stuff to change the code\n",
    "_searchMeta": {
      "cleanContent": "lorem ipsum dolor sit amet consectetur adipisicing elit numquam iste dolorum tempore consectetur explicabo tempora provident quia maxime molestiae facilis aperiam et error illum vel ullam quis architecto dolore ullam x write the press release update the website contact the media syntax description test text :------------ :---------: ----------: header title here s this paragraph text and more strikethrough text getting started to begin using the documentation template follow these simple steps: start by cloning the repository to your local machine lorem ipsum dolor sit amet consectetur adipisicing elit reprehenderit quae iure nulla deserunt dolore quam pariatur minus sapiente accusantium optio necessitatibus sequi veritatis aspernatur possimus quis repellat eum vitae eveniet blockquotes blockquotes are useful for emphasizing key points or quoting external sources: documentation is a love letter that you write to your future self - damian conway feel free to use blockquotes to highlight important information or quotes relevant to your documentation code examples with switch here a custom tab component from shadcn ui is used conclusion adding some random stuff to change the code",
      "headings": [
        "Getting Started",
        "Blockquotes",
        "Code Examples with switch",
        "Conclusion"
      ],
      "keywords": [
        "Getting Started",
        "Blockquotes",
        "Code Examples with switch",
        "Conclusion"
      ]
    }
  },
  {
    "slug": "/reference/autouiconfig",
    "title": "AutoUIConfig Reference",
    "description": "Complete reference for the AutoUIConfig type, including all fields, types, and options.",
    "content": "Complete reference for the `AutoUIConfig` type.\n\n## Type Definition\n\n```tsx\nimport { AutoUIConfig } from \"@autoai-ui/autoui\"\n```\n\n## Top-Level Fields\n\n### `appId` (required)\n\n**Type:** `string`\n\nUnique identifier for your application.\n\n```tsx\nappId: 'tasks-demo'\n```\n\nUsed for:\n\n* Logging and analytics\n* localStorage keys (if not overridden)\n* Error tracking\n\n### `metadata` (optional)\n\n**Type:** `AutoUIMetadata`\n\nApplication metadata that describes your app to the LLM. This is optional but recommended for better LLM understanding.\n\n```tsx\nmetadata: {\r\n  appName: string\r\n  appVersion?: string\r\n  author?: string\r\n  createdAt?: string // ISO timestamp\r\n  description?: string // Detailed description for LLM\r\n  tags?: string[]\r\n}\n```\n\n**Fields:**\n\n* `appName`: Display name of your application (required)\n* `appVersion`: Version string (e.g., \"1.0.0\") (optional)\n* `author`: Author or team name (optional)\n* `createdAt`: ISO 8601 timestamp (optional)\n* `description`: Detailed description that tells the LLM what your app does (optional but recommended)\n* `tags`: Array of tags for categorization (optional)\n\n### `llm` (required)\n\n**Type:** `LLMConfig`\n\nLLM provider configuration.\n\n```tsx\nllm: {\r\n  proxyUrl: string              // Required: Backend proxy URL\r\n  sharedSecret?: string          // Optional: Shared secret for proxy auth\r\n  provider?: string              // Optional: LLM provider (informational)\r\n  model?: string                 // Optional: Model hint (actual model enforced by proxy)\r\n  temperature?: number           // Optional: Sampling temperature (0.0-2.0), default: 0.2\r\n  maxTokens?: number             // Optional: Max tokens hint, default: 2048\r\n  appDescriptionPrompt?: string  // Optional: App description context\r\n  requestHeaders?: Record<string, string> // Optional: Headers forwarded to proxy\r\n}\n```\n\n**Required fields:**\n\n* `proxyUrl`: URL of your proxy server (REQUIRED in production)\n\n**Optional fields:**\n\n* `sharedSecret`: Client key generated by proxy server (optional, for proxy auth)\n* `provider`: LLM provider name (informational, used by proxy)\n* `model`: Model hint (actual model enforced by proxy)\n* `temperature`: Randomness (0.0-2.0), default: 0.2\n* `maxTokens`: Maximum response length hint, default: 2048\n* `appDescriptionPrompt`: Concise description of app capabilities\n* `requestHeaders`: Optional headers forwarded to proxy\n\n### `runtime` (required)\n\n**Type:** `RuntimeConfig`\n\nRuntime execution configuration.\n\n```tsx\nruntime: {\r\n  validateLLMOutput?: boolean\r\n  storeChatToLocalStorage?: boolean\r\n  localStorageKey?: string\r\n  enableDebugLogs?: boolean\r\n  toolsSchema?: OpenAIToolSchema[]\r\n  maxSteps?: number\r\n  errorHandling?: {\r\n    showToUser?: boolean\r\n    retryOnFail?: boolean\r\n  }\r\n}\n```\n\n**Fields:**\n\n* `validateLLMOutput`: Validate plan JSON structure (recommended: `true`, optional)\n* `storeChatToLocalStorage`: Persist chat history (optional)\n* `localStorageKey`: Key for localStorage (default: `'autoui_chat'`, optional)\n* `enableDebugLogs`: Log execution details to console (optional)\n* `toolsSchema`: Optional OpenAI tool schema definitions (optional)\n* `maxSteps`: Maximum instruction steps allowed (optional)\n* `errorHandling.showToUser`: Display errors in chat UI (optional)\n* `errorHandling.retryOnFail`: Auto-retry failed function calls (optional)\n\n### `functions` (optional)\n\n**Type:** `Record<string, FunctionConfig>`\n\nRegistered functions that the assistant can call.\n\n```tsx\nfunctions: {\r\n  functionName: {\r\n    prompt: string                                    // Required: Description for LLM\r\n    params?: Record<string, string>                  // Optional: Parameter descriptions\r\n    callFunc: Function                               // Required: The actual function implementation\r\n    returns?: string                                 // Optional: Return type description\r\n    exampleUsage?: string                           // Optional: Example usage for LLM\r\n    tags?: string[]                                 // Optional: Tags for organization\r\n    canShareDataWithLLM?: boolean                   // Optional: Whether function can share data with LLM\r\n  }\r\n}\n```\n\n**Important:** Functions must return a value (not void) so the LLM can analyze the results.\n\nSee [Functions](/docs/functions) for detailed documentation.\n\n### `components` (optional)\n\n**Type:** `Record<string, ComponentConfig>`\n\nRegistered React components for generative UI.\n\n```tsx\ncomponents: {\r\n  componentName: {\r\n    prompt: string                                  // Required: Description for LLM\r\n    props?: Record<string, string>                  // Optional: Human-readable prop descriptions\r\n    callComponent: ComponentType<any>              // Required: React component reference\r\n    defaults?: Record<string, any>                   // Optional: Default prop values\r\n    exampleUsage?: string                           // Optional: Example JSX usage (string)\r\n    category?: string                               // Optional: Category (e.g., 'product-display', 'checkout')\r\n    tags?: string[]                                 // Optional: Tags for search or grouping\r\n  }\r\n}\n```\n\n**Note:** `callComponent` must be a React `ComponentType`, which can be a function component or class component.\n\nSee [Components](/docs/components) for detailed documentation.\n\n## Complete Example\n\n```tsx\nconst config: AutoUIConfig = {\r\n  appId: 'my-app',\r\n  \r\n  // Optional but recommended\r\n  metadata: {\r\n    appName: 'My Application',\r\n    appVersion: '1.0.0',\r\n    author: 'Your Name',\r\n    createdAt: new Date().toISOString(),\r\n    description: 'Detailed description of what your app does...',\r\n    tags: ['demo', 'react'],\r\n  },\r\n  \r\n  llm: {\r\n    proxyUrl: 'http://localhost:3001',  // Required\r\n    sharedSecret: 'your-client-key',    // Optional\r\n    provider: 'openrouter',             // Optional\r\n    model: 'openai/gpt-4o',             // Optional\r\n    temperature: 0.2,                   // Optional\r\n    maxTokens: 2048,                   // Optional\r\n    appDescriptionPrompt: 'A simple application.', // Optional\r\n    requestHeaders: {                   // Optional\r\n      'HTTP-Referer': 'https://myapp.com',\r\n    },\r\n  },\r\n  \r\n  runtime: {\r\n    validateLLMOutput: true,           // Optional\r\n    storeChatToLocalStorage: true,      // Optional\r\n    localStorageKey: 'autoui_chat',     // Optional\r\n    enableDebugLogs: false,             // Optional\r\n    maxSteps: 20,                      // Optional\r\n    errorHandling: {                    // Optional\r\n      showToUser: true,\r\n      retryOnFail: false,\r\n    },\r\n  },\r\n  \r\n  functions: {\r\n    // Optional\r\n    myFunction: {\r\n      prompt: 'Does something useful',\r\n      params: {\r\n        param1: 'string - Description of param1',\r\n      },\r\n      callFunc: ({ param1 }) => {\r\n        // Implementation\r\n        return { result: 'success' }\r\n      },\r\n      returns: 'Object with result',\r\n      canShareDataWithLLM: true,\r\n    },\r\n  },\r\n  \r\n  components: {\r\n    // Optional\r\n    MyComponent: {\r\n      prompt: 'Displays something useful',\r\n      props: {\r\n        title: 'string - Component title',\r\n      },\r\n      callComponent: ({ title }) => <div>{title}</div>,\r\n      defaults: {\r\n        title: 'Default Title',\r\n      },\r\n      category: 'display',\r\n    },\r\n  },\r\n}\n```\n\n## TypeScript Types\n\nIf you're using TypeScript, import the types:\n\n```tsx\nimport { AutoUIConfig, Metadata, LLMConfig, RuntimeConfig } from \"@autoai-ui/autoui\"\n```\n\n## Validation\n\nAUTOUI validates your config at runtime. Common validation errors:\n\n* Missing required fields (`appId`, `llm.proxyUrl`)\n* Invalid `proxyUrl` format\n* Invalid `maxSteps` (must be positive number if provided)\n* Invalid `temperature` (must be 0.0-2.0 if provided)\n* Functions that return `void` (functions must return a value)\n\n## Best Practices\n\n* Use descriptive `appId` values\n* Write detailed `metadata.description` for better LLM understanding\n* Keep `llm.appDescriptionPrompt` concise but informative\n* Enable `validateLLMOutput` in production\n* Use meaningful `localStorageKey` values\n* Set appropriate `maxSteps` based on app complexity\n\n## Related Documentation\n\n* [Installation & Configuration](/docs/installation) - Setup guide\n* [Functions](/docs/functions) - Function registration\n* [Components](/docs/components) - Component registration\n* [Runtime & Debugging](/docs/runtime) - Runtime behavior\n",
    "_searchMeta": {
      "cleanContent": "complete reference for the autouiconfig type type definition top-level fields appid required type: string unique identifier for your application used for: logging and analytics localstorage keys if not overridden error tracking metadata optional type: autouimetadata application metadata that describes your app to the llm this is optional but recommended for better llm understanding fields: appname: display name of your application required appversion: version string e g 1 0 0 optional author: author or team name optional createdat: iso 8601 timestamp optional description: detailed description that tells the llm what your app does optional but recommended tags: array of tags for categorization optional llm required type: llmconfig llm provider configuration required fields: proxyurl: url of your proxy server required in production optional fields: sharedsecret: client key generated by proxy server optional for proxy auth provider: llm provider name informational used by proxy model: model hint actual model enforced by proxy temperature: randomness 0 0-2 0 default: 0 2 maxtokens: maximum response length hint default: 2048 appdescriptionprompt: concise description of app capabilities requestheaders: optional headers forwarded to proxy runtime required type: runtimeconfig runtime execution configuration fields: validatellmoutput: validate plan json structure recommended: true optional storechattolocalstorage: persist chat history optional localstoragekey: key for localstorage default: autoui_chat optional enabledebuglogs: log execution details to console optional toolsschema: optional openai tool schema definitions optional maxsteps: maximum instruction steps allowed optional errorhandling showtouser: display errors in chat ui optional errorhandling retryonfail: auto-retry failed function calls optional functions optional type: record string functionconfig registered functions that the assistant can call important: functions must return a value not void so the llm can analyze the results see functions for detailed documentation components optional type: record string componentconfig registered react components for generative ui note: callcomponent must be a react componenttype which can be a function component or class component see components for detailed documentation complete example typescript types if you re using typescript import the types: validation autoui validates your config at runtime common validation errors: missing required fields appid llm proxyurl invalid proxyurl format invalid maxsteps must be positive number if provided invalid temperature must be 0 0-2 0 if provided functions that return void functions must return a value best practices use descriptive appid values write detailed metadata description for better llm understanding keep llm appdescriptionprompt concise but informative enable validatellmoutput in production use meaningful localstoragekey values set appropriate maxsteps based on app complexity related documentation installation configuration - setup guide functions - function registration components - component registration runtime debugging - runtime behavior",
      "headings": [
        "Type Definition",
        "Top-Level Fields",
        "Complete Example",
        "TypeScript Types",
        "Validation",
        "Best Practices",
        "Related Documentation"
      ],
      "keywords": [
        "reference",
        "autouiconfig",
        "api",
        "types",
        "config",
        "Type Definition",
        "Top-Level Fields",
        "Complete Example",
        "TypeScript Types",
        "Validation",
        "Best Practices",
        "Related Documentation",
        "Type:",
        "Fields:",
        "Required fields:",
        "Optional fields:",
        "Important:",
        "Note:",
        "AutoUIConfig",
        "tsx\nimport { AutoUIConfig } from \"@autoai-ui/autoui\"",
        "## Top-Level Fields\n\n###",
        "(required)\n\n**Type:**",
        "Unique identifier for your application.",
        "tsx\nappId: 'tasks-demo'",
        "Used for:\n\n* Logging and analytics\n* localStorage keys (if not overridden)\n* Error tracking\n\n###",
        "(optional)\n\n**Type:**",
        "Application metadata that describes your app to the LLM. This is optional but recommended for better LLM understanding.",
        "tsx\nmetadata: {\r\n  appName: string\r\n  appVersion?: string\r\n  author?: string\r\n  createdAt?: string // ISO timestamp\r\n  description?: string // Detailed description for LLM\r\n  tags?: string[]\r\n}",
        "**Fields:**\n\n*",
        ": Display name of your application (required)\n*",
        ": Version string (e.g., \"1.0.0\") (optional)\n*",
        ": Author or team name (optional)\n*",
        ": ISO 8601 timestamp (optional)\n*",
        ": Detailed description that tells the LLM what your app does (optional but recommended)\n*",
        ": Array of tags for categorization (optional)\n\n###",
        "LLM provider configuration.",
        "tsx\nllm: {\r\n  proxyUrl: string              // Required: Backend proxy URL\r\n  sharedSecret?: string          // Optional: Shared secret for proxy auth\r\n  provider?: string              // Optional: LLM provider (informational)\r\n  model?: string                 // Optional: Model hint (actual model enforced by proxy)\r\n  temperature?: number           // Optional: Sampling temperature (0.0-2.0), default: 0.2\r\n  maxTokens?: number             // Optional: Max tokens hint, default: 2048\r\n  appDescriptionPrompt?: string  // Optional: App description context\r\n  requestHeaders?: Record<string, string> // Optional: Headers forwarded to proxy\r\n}",
        "**Required fields:**\n\n*",
        ": URL of your proxy server (REQUIRED in production)\n\n**Optional fields:**\n\n*",
        ": Client key generated by proxy server (optional, for proxy auth)\n*",
        ": LLM provider name (informational, used by proxy)\n*",
        ": Model hint (actual model enforced by proxy)\n*",
        ": Randomness (0.0-2.0), default: 0.2\n*",
        ": Maximum response length hint, default: 2048\n*",
        ": Concise description of app capabilities\n*",
        ": Optional headers forwarded to proxy\n\n###",
        "Runtime execution configuration.",
        "tsx\nruntime: {\r\n  validateLLMOutput?: boolean\r\n  storeChatToLocalStorage?: boolean\r\n  localStorageKey?: string\r\n  enableDebugLogs?: boolean\r\n  toolsSchema?: OpenAIToolSchema[]\r\n  maxSteps?: number\r\n  errorHandling?: {\r\n    showToUser?: boolean\r\n    retryOnFail?: boolean\r\n  }\r\n}",
        ": Validate plan JSON structure (recommended:",
        ", optional)\n*",
        ": Persist chat history (optional)\n*",
        ": Key for localStorage (default:",
        ": Log execution details to console (optional)\n*",
        ": Optional OpenAI tool schema definitions (optional)\n*",
        ": Maximum instruction steps allowed (optional)\n*",
        ": Display errors in chat UI (optional)\n*",
        ": Auto-retry failed function calls (optional)\n\n###",
        "Registered functions that the assistant can call.",
        "tsx\nfunctions: {\r\n  functionName: {\r\n    prompt: string                                    // Required: Description for LLM\r\n    params?: Record<string, string>                  // Optional: Parameter descriptions\r\n    callFunc: Function                               // Required: The actual function implementation\r\n    returns?: string                                 // Optional: Return type description\r\n    exampleUsage?: string                           // Optional: Example usage for LLM\r\n    tags?: string[]                                 // Optional: Tags for organization\r\n    canShareDataWithLLM?: boolean                   // Optional: Whether function can share data with LLM\r\n  }\r\n}",
        "**Important:** Functions must return a value (not void) so the LLM can analyze the results.\n\nSee [Functions](/docs/functions) for detailed documentation.\n\n###",
        "Registered React components for generative UI.",
        "tsx\ncomponents: {\r\n  componentName: {\r\n    prompt: string                                  // Required: Description for LLM\r\n    props?: Record<string, string>                  // Optional: Human-readable prop descriptions\r\n    callComponent: ComponentType<any>              // Required: React component reference\r\n    defaults?: Record<string, any>                   // Optional: Default prop values\r\n    exampleUsage?: string                           // Optional: Example JSX usage (string)\r\n    category?: string                               // Optional: Category (e.g., 'product-display', 'checkout')\r\n    tags?: string[]                                 // Optional: Tags for search or grouping\r\n  }\r\n}",
        "**Note:**",
        "must be a React",
        ", which can be a function component or class component.\n\nSee [Components](/docs/components) for detailed documentation.\n\n## Complete Example",
        "tsx\nconst config: AutoUIConfig = {\r\n  appId: 'my-app',\r\n  \r\n  // Optional but recommended\r\n  metadata: {\r\n    appName: 'My Application',\r\n    appVersion: '1.0.0',\r\n    author: 'Your Name',\r\n    createdAt: new Date().toISOString(),\r\n    description: 'Detailed description of what your app does...',\r\n    tags: ['demo', 'react'],\r\n  },\r\n  \r\n  llm: {\r\n    proxyUrl: 'http://localhost:3001',  // Required\r\n    sharedSecret: 'your-client-key',    // Optional\r\n    provider: 'openrouter',             // Optional\r\n    model: 'openai/gpt-4o',             // Optional\r\n    temperature: 0.2,                   // Optional\r\n    maxTokens: 2048,                   // Optional\r\n    appDescriptionPrompt: 'A simple application.', // Optional\r\n    requestHeaders: {                   // Optional\r\n      'HTTP-Referer': 'https://myapp.com',\r\n    },\r\n  },\r\n  \r\n  runtime: {\r\n    validateLLMOutput: true,           // Optional\r\n    storeChatToLocalStorage: true,      // Optional\r\n    localStorageKey: 'autoui_chat',     // Optional\r\n    enableDebugLogs: false,             // Optional\r\n    maxSteps: 20,                      // Optional\r\n    errorHandling: {                    // Optional\r\n      showToUser: true,\r\n      retryOnFail: false,\r\n    },\r\n  },\r\n  \r\n  functions: {\r\n    // Optional\r\n    myFunction: {\r\n      prompt: 'Does something useful',\r\n      params: {\r\n        param1: 'string - Description of param1',\r\n      },\r\n      callFunc: ({ param1 }) => {\r\n        // Implementation\r\n        return { result: 'success' }\r\n      },\r\n      returns: 'Object with result',\r\n      canShareDataWithLLM: true,\r\n    },\r\n  },\r\n  \r\n  components: {\r\n    // Optional\r\n    MyComponent: {\r\n      prompt: 'Displays something useful',\r\n      props: {\r\n        title: 'string - Component title',\r\n      },\r\n      callComponent: ({ title }) => <div>{title}</div>,\r\n      defaults: {\r\n        title: 'Default Title',\r\n      },\r\n      category: 'display',\r\n    },\r\n  },\r\n}",
        "## TypeScript Types\n\nIf you're using TypeScript, import the types:",
        "tsx\nimport { AutoUIConfig, Metadata, LLMConfig, RuntimeConfig } from \"@autoai-ui/autoui\"",
        "## Validation\n\nAUTOUI validates your config at runtime. Common validation errors:\n\n* Missing required fields (",
        ",",
        ")\n* Invalid",
        "format\n* Invalid",
        "(must be positive number if provided)\n* Invalid",
        "(must be 0.0-2.0 if provided)\n* Functions that return",
        "(functions must return a value)\n\n## Best Practices\n\n* Use descriptive",
        "values\n* Write detailed",
        "for better LLM understanding\n* Keep",
        "concise but informative\n* Enable",
        "in production\n* Use meaningful",
        "values\n* Set appropriate"
      ]
    }
  },
  {
    "slug": "/reference/modalchat",
    "title": "ModalChat Props Reference",
    "description": "Complete reference for ModalChat component props and usage.",
    "content": "Complete reference for the `ModalChat` React component.\n\n## Import\n\n```tsx\nimport { ModalChat } from \"@autoai-ui/autoui\"\n```\n\nOr with dynamic import (recommended for Next.js):\n\n```tsx\nimport dynamic from \"next/dynamic\"\r\n\r\nconst ModalChat = dynamic(\r\n  () => import(\"@autoai-ui/autoui\").then(m => m.ModalChat),\r\n  { ssr: false }\r\n)\n```\n\n## Props\n\n### `config` (required)\n\n**Type:** `AutoUIConfig`\n\nThe AUTOUI configuration object.\n\n```tsx\n<ModalChat config={myConfig} />\n```\n\nSee [AutoUIConfig Reference](/docs/reference/autouiconfig) for details.\n\n### `open` (optional)\n\n**Type:** `boolean`\n\nControls whether the chat modal is open.\n\n```tsx\nconst [isOpen, setIsOpen] = useState(false)\r\n\r\n<ModalChat \r\n  config={config}\r\n  open={isOpen}\r\n  onOpenChange={setIsOpen}\r\n/>\n```\n\n**Default:** `undefined` (uncontrolled)\n\n**Use case:** Use when you want to control the modal state programmatically (e.g., with a custom trigger button).\n\n### `onOpenChange` (optional)\n\n**Type:** `(open: boolean) => void`\n\nCallback fired when the modal open state changes.\n\n```tsx\n<ModalChat \r\n  config={config}\r\n  open={isOpen}\r\n  onOpenChange={(open) => setIsOpen(open)}\r\n/>\n```\n\n**Use case:** Use with controlled `open` prop to sync modal state with your component state.\n\n### `className` (optional)\n\n**Type:** `string`\n\nAdditional CSS class names for the modal container.\n\n```tsx\n<ModalChat \r\n  config={config}\r\n  className=\"my-custom-modal\"\r\n/>\n```\n\n**Use case:** Apply custom styling to the modal container.\n\n### `style` (optional)\n\n**Type:** `React.CSSProperties`\n\nInline styles for the modal container.\n\n```tsx\n<ModalChat \r\n  config={config}\r\n  style={{ zIndex: 9999 }}\r\n/>\n```\n\n**Use case:** Apply inline styles for positioning or z-index.\n\n## Usage Examples\n\n### Basic Usage\n\n```tsx\nimport { ModalChat, AutoUIConfig } from \"@autoai-ui/autoui\"\r\n\r\nexport default function App() {\r\n  const config: AutoUIConfig = {\r\n    // ... your config\r\n  }\r\n\r\n  return <ModalChat config={config} />\r\n}\n```\n\n### With Dynamic Import (Next.js)\n\n```tsx\n\"use client\"\r\nimport dynamic from \"next/dynamic\"\r\nimport { AutoUIConfig } from \"@autoai-ui/autoui\"\r\n\r\nconst ModalChat = dynamic(\r\n  () => import(\"@autoai-ui/autoui\").then(m => m.ModalChat),\r\n  { ssr: false }\r\n)\r\n\r\nexport default function App() {\r\n  const config: AutoUIConfig = {\r\n    // ... your config\r\n  }\r\n\r\n  return <ModalChat config={config} />\r\n}\n```\n\n### Controlled State\n\n```tsx\nimport { useState } from \"react\"\r\nimport { ModalChat, AutoUIConfig } from \"@autoai-ui/autoui\"\r\n\r\nexport default function App() {\r\n  const [isOpen, setIsOpen] = useState(false)\r\n  const config: AutoUIConfig = {\r\n    // ... your config\r\n  }\r\n\r\n  return (\r\n    <>\r\n      <button onClick={() => setIsOpen(true)}>\r\n        Open Chat\r\n      </button>\r\n      <ModalChat \r\n        config={config}\r\n        open={isOpen}\r\n        onOpenChange={setIsOpen}\r\n      />\r\n    </>\r\n  )\r\n}\n```\n\n### With Custom Styling\n\n```tsx\n<ModalChat \r\n  config={config}\r\n  className=\"my-custom-chat\"\r\n  style={{ \r\n    position: 'fixed',\r\n    bottom: '20px',\r\n    right: '20px',\r\n    zIndex: 9999\r\n  }}\r\n/>\n```\n\n## Component Behavior\n\n### Default Trigger Button\n\nBy default, ModalChat renders a floating action button (FAB) that opens the chat modal when clicked. The button appears in the bottom-right corner.\n\n### Modal Behavior\n\n* Opens as a modal overlay\n* Closes when clicking outside or pressing Escape\n* Maintains chat history (if `storeChatToLocalStorage` is enabled)\n* Responsive design (adapts to mobile/desktop)\n\n### SSR Considerations\n\nModalChat must be dynamically imported with `ssr: false` in Next.js or similar SSR frameworks to prevent hydration mismatches.\n\n## Styling\n\nSee [ModalChat Styling](/docs/styling) for detailed styling options and customization.\n\n## Related Documentation\n\n* [AutoUIConfig Reference](/docs/reference/autouiconfig) - Config structure\n* [Installation & Configuration](/docs/installation) - Setup guide\n* [ModalChat Styling](/docs/styling) - Styling and theming\n",
    "_searchMeta": {
      "cleanContent": "complete reference for the modalchat react component import or with dynamic import recommended for next js : props config required type: autouiconfig the autoui configuration object see autouiconfig reference for details open optional type: boolean controls whether the chat modal is open default: undefined uncontrolled use case: use when you want to control the modal state programmatically e g with a custom trigger button onopenchange optional type: open: boolean void callback fired when the modal open state changes use case: use with controlled open prop to sync modal state with your component state classname optional type: string additional css class names for the modal container use case: apply custom styling to the modal container style optional type: react cssproperties inline styles for the modal container use case: apply inline styles for positioning or z-index usage examples basic usage with dynamic import next js controlled state with custom styling component behavior default trigger button by default modalchat renders a floating action button fab that opens the chat modal when clicked the button appears in the bottom-right corner modal behavior opens as a modal overlay closes when clicking outside or pressing escape maintains chat history if storechattolocalstorage is enabled responsive design adapts to mobile desktop ssr considerations modalchat must be dynamically imported with ssr: false in next js or similar ssr frameworks to prevent hydration mismatches styling see modalchat styling for detailed styling options and customization related documentation autouiconfig reference - config structure installation configuration - setup guide modalchat styling - styling and theming",
      "headings": [
        "Import",
        "Props",
        "Usage Examples",
        "Component Behavior",
        "Styling",
        "Related Documentation"
      ],
      "keywords": [
        "reference",
        "modalchat",
        "props",
        "component",
        "api",
        "Import",
        "Props",
        "Usage Examples",
        "Component Behavior",
        "Styling",
        "Related Documentation",
        "Type:",
        "Default:",
        "Use case:",
        "ModalChat",
        "tsx\nimport { ModalChat } from \"@autoai-ui/autoui\"",
        "Or with dynamic import (recommended for Next.js):",
        "tsx\nimport dynamic from \"next/dynamic\"\r\n\r\nconst ModalChat = dynamic(\r\n  () => import(\"@autoai-ui/autoui\").then(m => m.ModalChat),\r\n  { ssr: false }\r\n)",
        "## Props\n\n###",
        "(required)\n\n**Type:**",
        "The AUTOUI configuration object.",
        "tsx\n<ModalChat config={myConfig} />",
        "See [AutoUIConfig Reference](/docs/reference/autouiconfig) for details.\n\n###",
        "(optional)\n\n**Type:**",
        "Controls whether the chat modal is open.",
        "tsx\nconst [isOpen, setIsOpen] = useState(false)\r\n\r\n<ModalChat \r\n  config={config}\r\n  open={isOpen}\r\n  onOpenChange={setIsOpen}\r\n/>",
        "**Default:**",
        "(uncontrolled)\n\n**Use case:** Use when you want to control the modal state programmatically (e.g., with a custom trigger button).\n\n###",
        "Callback fired when the modal open state changes.",
        "tsx\n<ModalChat \r\n  config={config}\r\n  open={isOpen}\r\n  onOpenChange={(open) => setIsOpen(open)}\r\n/>",
        "**Use case:** Use with controlled",
        "prop to sync modal state with your component state.\n\n###",
        "Additional CSS class names for the modal container.",
        "tsx\n<ModalChat \r\n  config={config}\r\n  className=\"my-custom-modal\"\r\n/>",
        "**Use case:** Apply custom styling to the modal container.\n\n###",
        "Inline styles for the modal container.",
        "tsx\n<ModalChat \r\n  config={config}\r\n  style={{ zIndex: 9999 }}\r\n/>",
        "**Use case:** Apply inline styles for positioning or z-index.\n\n## Usage Examples\n\n### Basic Usage",
        "tsx\nimport { ModalChat, AutoUIConfig } from \"@autoai-ui/autoui\"\r\n\r\nexport default function App() {\r\n  const config: AutoUIConfig = {\r\n    // ... your config\r\n  }\r\n\r\n  return <ModalChat config={config} />\r\n}",
        "### With Dynamic Import (Next.js)",
        "tsx\n\"use client\"\r\nimport dynamic from \"next/dynamic\"\r\nimport { AutoUIConfig } from \"@autoai-ui/autoui\"\r\n\r\nconst ModalChat = dynamic(\r\n  () => import(\"@autoai-ui/autoui\").then(m => m.ModalChat),\r\n  { ssr: false }\r\n)\r\n\r\nexport default function App() {\r\n  const config: AutoUIConfig = {\r\n    // ... your config\r\n  }\r\n\r\n  return <ModalChat config={config} />\r\n}",
        "### Controlled State",
        "tsx\nimport { useState } from \"react\"\r\nimport { ModalChat, AutoUIConfig } from \"@autoai-ui/autoui\"\r\n\r\nexport default function App() {\r\n  const [isOpen, setIsOpen] = useState(false)\r\n  const config: AutoUIConfig = {\r\n    // ... your config\r\n  }\r\n\r\n  return (\r\n    <>\r\n      <button onClick={() => setIsOpen(true)}>\r\n        Open Chat\r\n      </button>\r\n      <ModalChat \r\n        config={config}\r\n        open={isOpen}\r\n        onOpenChange={setIsOpen}\r\n      />\r\n    </>\r\n  )\r\n}",
        "### With Custom Styling",
        "tsx\n<ModalChat \r\n  config={config}\r\n  className=\"my-custom-chat\"\r\n  style={{ \r\n    position: 'fixed',\r\n    bottom: '20px',\r\n    right: '20px',\r\n    zIndex: 9999\r\n  }}\r\n/>",
        "## Component Behavior\n\n### Default Trigger Button\n\nBy default, ModalChat renders a floating action button (FAB) that opens the chat modal when clicked. The button appears in the bottom-right corner.\n\n### Modal Behavior\n\n* Opens as a modal overlay\n* Closes when clicking outside or pressing Escape\n* Maintains chat history (if",
        "is enabled)\n* Responsive design (adapts to mobile/desktop)\n\n### SSR Considerations\n\nModalChat must be dynamically imported with"
      ]
    }
  },
  {
    "slug": "/runtime",
    "title": "Runtime & Debugging",
    "description": "Understand AUTOUI runtime behavior, debugging options, error handling, and execution limits.",
    "content": "The AUTOUI runtime orchestrates plan execution, manages conversation state, and handles errors. Understanding runtime behavior is crucial for debugging and optimizing your integration.\n\n## Runtime Overview\n\nThe runtime:\n\n1. Receives plans (structured JSON) from the LLM\n2. Validates plan structure (if enabled)\n3. Executes steps in order (function calls, component renders)\n4. Collects results and sends context back to the LLM\n5. Handles errors and retries\n6. Manages conversation state and persistence\n\n## Configuration\n\nRuntime behavior is controlled by the `runtime` section of your config:\n\n```tsx\nruntime: {\r\n  validateLLMOutput: true,\r\n  storeChatToLocalStorage: true,\r\n  localStorageKey: 'autoui_chat',\r\n  enableDebugLogs: true,\r\n  maxSteps: 20,\r\n  errorHandling: {\r\n    showToUser: true,\r\n    retryOnFail: false,\r\n  },\r\n}\n```\n\n## validateLLMOutput\n\nValidates that the LLM returns properly structured plan JSON.\n\n```tsx\nvalidateLLMOutput: true\n```\n\n**What it does:**\n\n* Checks that the response is valid JSON\n* Validates plan structure (steps, actions, parameters)\n* Rejects malformed plans before execution\n\n**When to enable:**\n\n* **Always in production** to prevent execution errors\n* Useful during development to catch LLM output issues early\n\n**When to disable:**\n\n* Only if you're debugging LLM output format issues\n* Not recommended for production\n\n## storeChatToLocalStorage\n\nPersists conversation history in the browser's localStorage.\n\n```tsx\nstoreChatToLocalStorage: true\r\nlocalStorageKey: 'autoui_chat'\n```\n\n**What it stores:**\n\n* Conversation messages (user and assistant)\n* Plan execution history\n* Function call results\n* Component render states\n\n**Benefits:**\n\n* Chat history persists across page reloads\n* Users can continue conversations\n* Useful for debugging (inspect stored state)\n\n**Considerations:**\n\n* localStorage has size limits (~5-10MB)\n* Sensitive data may be stored (be mindful of privacy)\n* Clear localStorage if you change config structure\n\n## enableDebugLogs\n\nLogs detailed execution information to the browser console.\n\n```tsx\nenableDebugLogs: true\n```\n\n**What gets logged:**\n\n* Incoming plans from LLM\n* Function call parameters and results\n* Component render props\n* Error messages and stack traces\n* Execution timing\n\n**Example console output:**\n\n```\n[AUTOUI] Plan received: { steps: [...] }\r\n[AUTOUI] Executing step 1: callFunction('createTask', { draft: {...} })\r\n[AUTOUI] Function result: { id: '123', title: '...' }\r\n[AUTOUI] Executing step 2: renderComponent('TaskCard', { task: {...} })\r\n[AUTOUI] Plan execution complete\n```\n\n**When to enable:**\n\n* During development and debugging\n* When troubleshooting execution issues\n* When optimizing performance\n\n**When to disable:**\n\n* In production (to reduce console noise)\n* When performance is critical\n\n## maxSteps\n\nLimits the number of steps in a single plan execution.\n\n```tsx\nmaxSteps: 20\n```\n\n**Purpose:**\n\n* Prevents infinite loops\n* Limits execution time\n* Controls resource usage\n\n**How it works:**\n\n* Each function call or component render counts as one step\n* If a plan exceeds `maxSteps`, execution stops\n* The runtime returns an error to the LLM\n\n**Choosing a value:**\n\n* **Simple apps**: 5-10 steps\n* **Medium complexity**: 10-20 steps\n* **Complex workflows**: 20-50 steps\n* **Very complex**: 50+ steps (use with caution)\n\n## errorHandling\n\nControls how errors are displayed and handled.\n\n```tsx\nerrorHandling: {\r\n  showToUser: true,\r\n  retryOnFail: false,\r\n}\n```\n\n### showToUser\n\nWhether to display error messages in the chat UI.\n\n```tsx\nshowToUser: true\n```\n\n**When enabled:**\n\n* Errors are shown as chat messages\n* Users see what went wrong\n* Useful for debugging and transparency\n\n**When disabled:**\n\n* Errors are only logged to console\n* Users see generic \"something went wrong\" messages\n* Better for production (hides technical details)\n\n### retryOnFail\n\nWhether to automatically retry failed function calls.\n\n```tsx\nretryOnFail: false\n```\n\n**When enabled:**\n\n* Failed function calls are retried once\n* Useful for transient errors (network, API timeouts)\n* May cause duplicate operations\n\n**When disabled:**\n\n* Errors stop execution immediately\n* LLM can decide to retry in the next turn\n* More predictable behavior\n\n## Debugging Workflow\n\n### 1. Enable Debug Logs\n\n```tsx\nruntime: {\r\n  enableDebugLogs: true,\r\n}\n```\n\n### 2. Open Browser Console\n\nOpen DevTools (F12) and check the Console tab for AUTOUI logs.\n\n### 3. Inspect Plans\n\nLook for `[AUTOUI] Plan received` logs to see what the LLM is generating.\n\n### 4. Check Function Calls\n\nVerify function parameters and return values:\n\n```\n[AUTOUI] Executing step 1: callFunction('createTask', { draft: {...} })\r\n[AUTOUI] Function result: { id: '123', ... }\n```\n\n### 5. Review Errors\n\nCheck for error messages and stack traces:\n\n```\n[AUTOUI] Error: Task not found\r\n[AUTOUI] Stack: ...\n```\n\n### 6. Inspect localStorage\n\nCheck stored conversation state:\n\n```javascript\n// In browser console\r\nconst stored = localStorage.getItem('autoui_chat')\r\nconsole.log(JSON.parse(stored))\n```\n\n## Common Issues\n\n### Plan Validation Fails\n\n**Symptom:** `[AUTOUI] Plan validation failed`\n\n**Causes:**\n\n* LLM returned malformed JSON\n* Plan structure doesn't match expected format\n* Network issues corrupted response\n\n**Solutions:**\n\n* Check LLM response in network tab\n* Verify `validateLLMOutput` is enabled\n* Review LLM provider status\n* Check proxy server logs\n\n### Function Execution Fails\n\n**Symptom:** `[AUTOUI] Error executing function: ...`\n\n**Causes:**\n\n* Function threw an exception\n* Invalid parameters passed\n* Missing dependencies or state\n\n**Solutions:**\n\n* Check function implementation\n* Verify parameters match function signature\n* Add error handling in functions\n* Check console for detailed error messages\n\n### maxSteps Exceeded\n\n**Symptom:** `[AUTOUI] Plan exceeded maxSteps limit`\n\n**Causes:**\n\n* Plan has too many steps\n* Infinite loop in function calls\n* LLM generating overly complex plans\n\n**Solutions:**\n\n* Increase `maxSteps` (if appropriate)\n* Review function prompts to avoid recursion\n* Simplify component structure\n* Break complex operations into smaller functions\n\n### localStorage Quota Exceeded\n\n**Symptom:** `QuotaExceededError` in console\n\n**Causes:**\n\n* Chat history too large\n* Too many stored conversations\n* localStorage near capacity\n\n**Solutions:**\n\n* Clear old chat history\n* Reduce `storeChatToLocalStorage` scope\n* Implement history cleanup\n* Use sessionStorage instead (cleared on tab close)\n\n## Performance Optimization\n\n### Reduce Debug Logging\n\n```tsx\nruntime: {\r\n  enableDebugLogs: false, // Disable in production\r\n}\n```\n\n### Limit Conversation History\n\nImplement history cleanup:\n\n```tsx\n// Clear old messages periodically\r\nif (chatHistory.length > 100) {\r\n  chatHistory = chatHistory.slice(-50) // Keep last 50 messages\r\n}\n```\n\n### Optimize Function Calls\n\n* Cache expensive operations\n* Batch multiple operations\n* Use async functions for I/O\n\n### Monitor Execution Time\n\nCheck console logs for timing information:\n\n```\n[AUTOUI] Plan execution time: 234ms\n```\n\n## Next Steps\n\n* Learn about functions: [Functions](/docs/functions)\n* Explore components: [Components](/docs/components)\n* Troubleshoot issues: [Troubleshooting](/docs/troubleshooting)\n",
    "_searchMeta": {
      "cleanContent": "the autoui runtime orchestrates plan execution manages conversation state and handles errors understanding runtime behavior is crucial for debugging and optimizing your integration runtime overview the runtime: receives plans structured json from the llm validates plan structure if enabled executes steps in order function calls component renders collects results and sends context back to the llm handles errors and retries manages conversation state and persistence configuration runtime behavior is controlled by the runtime section of your config: validatellmoutput validates that the llm returns properly structured plan json what it does: checks that the response is valid json validates plan structure steps actions parameters rejects malformed plans before execution when to enable: always in production to prevent execution errors useful during development to catch llm output issues early when to disable: only if you re debugging llm output format issues not recommended for production storechattolocalstorage persists conversation history in the browser s localstorage what it stores: conversation messages user and assistant plan execution history function call results component render states benefits: chat history persists across page reloads users can continue conversations useful for debugging inspect stored state considerations: localstorage has size limits 5-10mb sensitive data may be stored be mindful of privacy clear localstorage if you change config structure enabledebuglogs logs detailed execution information to the browser console what gets logged: incoming plans from llm function call parameters and results component render props error messages and stack traces execution timing example console output: when to enable: during development and debugging when troubleshooting execution issues when optimizing performance when to disable: in production to reduce console noise when performance is critical maxsteps limits the number of steps in a single plan execution purpose: prevents infinite loops limits execution time controls resource usage how it works: each function call or component render counts as one step if a plan exceeds maxsteps execution stops the runtime returns an error to the llm choosing a value: simple apps: 5-10 steps medium complexity: 10-20 steps complex workflows: 20-50 steps very complex: 50 steps use with caution errorhandling controls how errors are displayed and handled showtouser whether to display error messages in the chat ui when enabled: errors are shown as chat messages users see what went wrong useful for debugging and transparency when disabled: errors are only logged to console users see generic something went wrong messages better for production hides technical details retryonfail whether to automatically retry failed function calls when enabled: failed function calls are retried once useful for transient errors network api timeouts may cause duplicate operations when disabled: errors stop execution immediately llm can decide to retry in the next turn more predictable behavior debugging workflow enable debug logs open browser console open devtools f12 and check the console tab for autoui logs inspect plans look for autoui plan received logs to see what the llm is generating check function calls verify function parameters and return values: review errors check for error messages and stack traces: inspect localstorage check stored conversation state: common issues plan validation fails symptom: autoui plan validation failed causes: llm returned malformed json plan structure doesn t match expected format network issues corrupted response solutions: check llm response in network tab verify validatellmoutput is enabled review llm provider status check proxy server logs function execution fails symptom: autoui error executing function: causes: function threw an exception invalid parameters passed missing dependencies or state solutions: check function implementation verify parameters match function signature add error handling in functions check console for detailed error messages maxsteps exceeded symptom: autoui plan exceeded maxsteps limit causes: plan has too many steps infinite loop in function calls llm generating overly complex plans solutions: increase maxsteps if appropriate review function prompts to avoid recursion simplify component structure break complex operations into smaller functions localstorage quota exceeded symptom: quotaexceedederror in console causes: chat history too large too many stored conversations localstorage near capacity solutions: clear old chat history reduce storechattolocalstorage scope implement history cleanup use sessionstorage instead cleared on tab close performance optimization reduce debug logging limit conversation history implement history cleanup: optimize function calls cache expensive operations batch multiple operations use async functions for i o monitor execution time check console logs for timing information: next steps learn about functions: functions explore components: components troubleshoot issues: troubleshooting",
      "headings": [
        "Runtime Overview",
        "Configuration",
        "validateLLMOutput",
        "storeChatToLocalStorage",
        "enableDebugLogs",
        "maxSteps",
        "errorHandling",
        "Debugging Workflow",
        "Common Issues",
        "Performance Optimization",
        "Next Steps"
      ],
      "keywords": [
        "runtime",
        "debugging",
        "validateLLMOutput",
        "maxSteps",
        "error handling",
        "localStorage",
        "Runtime Overview",
        "Configuration",
        "storeChatToLocalStorage",
        "enableDebugLogs",
        "errorHandling",
        "Debugging Workflow",
        "Common Issues",
        "Performance Optimization",
        "Next Steps",
        "What it does:",
        "When to enable:",
        "Always in production",
        "When to disable:",
        "What it stores:",
        "Benefits:",
        "Considerations:",
        "What gets logged:",
        "Example console output:",
        "Purpose:",
        "How it works:",
        "Choosing a value:",
        "Simple apps",
        "Medium complexity",
        "Complex workflows",
        "Very complex",
        "When enabled:",
        "When disabled:",
        "Symptom:",
        "Causes:",
        "Solutions:",
        "tsx\nruntime: {\r\n  validateLLMOutput: true,\r\n  storeChatToLocalStorage: true,\r\n  localStorageKey: 'autoui_chat',\r\n  enableDebugLogs: true,\r\n  maxSteps: 20,\r\n  errorHandling: {\r\n    showToUser: true,\r\n    retryOnFail: false,\r\n  },\r\n}",
        "## validateLLMOutput\n\nValidates that the LLM returns properly structured plan JSON.",
        "tsx\nvalidateLLMOutput: true",
        "**What it does:**\n\n* Checks that the response is valid JSON\n* Validates plan structure (steps, actions, parameters)\n* Rejects malformed plans before execution\n\n**When to enable:**\n\n* **Always in production** to prevent execution errors\n* Useful during development to catch LLM output issues early\n\n**When to disable:**\n\n* Only if you're debugging LLM output format issues\n* Not recommended for production\n\n## storeChatToLocalStorage\n\nPersists conversation history in the browser's localStorage.",
        "tsx\nstoreChatToLocalStorage: true\r\nlocalStorageKey: 'autoui_chat'",
        "**What it stores:**\n\n* Conversation messages (user and assistant)\n* Plan execution history\n* Function call results\n* Component render states\n\n**Benefits:**\n\n* Chat history persists across page reloads\n* Users can continue conversations\n* Useful for debugging (inspect stored state)\n\n**Considerations:**\n\n* localStorage has size limits (~5-10MB)\n* Sensitive data may be stored (be mindful of privacy)\n* Clear localStorage if you change config structure\n\n## enableDebugLogs\n\nLogs detailed execution information to the browser console.",
        "tsx\nenableDebugLogs: true",
        "**What gets logged:**\n\n* Incoming plans from LLM\n* Function call parameters and results\n* Component render props\n* Error messages and stack traces\n* Execution timing\n\n**Example console output:**",
        "[AUTOUI] Plan received: { steps: [...] }\r\n[AUTOUI] Executing step 1: callFunction('createTask', { draft: {...} })\r\n[AUTOUI] Function result: { id: '123', title: '...' }\r\n[AUTOUI] Executing step 2: renderComponent('TaskCard', { task: {...} })\r\n[AUTOUI] Plan execution complete",
        "**When to enable:**\n\n* During development and debugging\n* When troubleshooting execution issues\n* When optimizing performance\n\n**When to disable:**\n\n* In production (to reduce console noise)\n* When performance is critical\n\n## maxSteps\n\nLimits the number of steps in a single plan execution.",
        "tsx\nmaxSteps: 20",
        "**Purpose:**\n\n* Prevents infinite loops\n* Limits execution time\n* Controls resource usage\n\n**How it works:**\n\n* Each function call or component render counts as one step\n* If a plan exceeds",
        ", execution stops\n* The runtime returns an error to the LLM\n\n**Choosing a value:**\n\n* **Simple apps**: 5-10 steps\n* **Medium complexity**: 10-20 steps\n* **Complex workflows**: 20-50 steps\n* **Very complex**: 50+ steps (use with caution)\n\n## errorHandling\n\nControls how errors are displayed and handled.",
        "tsx\nerrorHandling: {\r\n  showToUser: true,\r\n  retryOnFail: false,\r\n}",
        "### showToUser\n\nWhether to display error messages in the chat UI.",
        "tsx\nshowToUser: true",
        "**When enabled:**\n\n* Errors are shown as chat messages\n* Users see what went wrong\n* Useful for debugging and transparency\n\n**When disabled:**\n\n* Errors are only logged to console\n* Users see generic \"something went wrong\" messages\n* Better for production (hides technical details)\n\n### retryOnFail\n\nWhether to automatically retry failed function calls.",
        "tsx\nretryOnFail: false",
        "**When enabled:**\n\n* Failed function calls are retried once\n* Useful for transient errors (network, API timeouts)\n* May cause duplicate operations\n\n**When disabled:**\n\n* Errors stop execution immediately\n* LLM can decide to retry in the next turn\n* More predictable behavior\n\n## Debugging Workflow\n\n### 1. Enable Debug Logs",
        "tsx\nruntime: {\r\n  enableDebugLogs: true,\r\n}",
        "### 2. Open Browser Console\n\nOpen DevTools (F12) and check the Console tab for AUTOUI logs.\n\n### 3. Inspect Plans\n\nLook for",
        "logs to see what the LLM is generating.\n\n### 4. Check Function Calls\n\nVerify function parameters and return values:",
        "[AUTOUI] Executing step 1: callFunction('createTask', { draft: {...} })\r\n[AUTOUI] Function result: { id: '123', ... }",
        "### 5. Review Errors\n\nCheck for error messages and stack traces:",
        "[AUTOUI] Error: Task not found\r\n[AUTOUI] Stack: ...",
        "### 6. Inspect localStorage\n\nCheck stored conversation state:",
        "javascript\n// In browser console\r\nconst stored = localStorage.getItem('autoui_chat')\r\nconsole.log(JSON.parse(stored))",
        "## Common Issues\n\n### Plan Validation Fails\n\n**Symptom:**",
        "**Causes:**\n\n* LLM returned malformed JSON\n* Plan structure doesn't match expected format\n* Network issues corrupted response\n\n**Solutions:**\n\n* Check LLM response in network tab\n* Verify",
        "is enabled\n* Review LLM provider status\n* Check proxy server logs\n\n### Function Execution Fails\n\n**Symptom:**",
        "**Causes:**\n\n* Function threw an exception\n* Invalid parameters passed\n* Missing dependencies or state\n\n**Solutions:**\n\n* Check function implementation\n* Verify parameters match function signature\n* Add error handling in functions\n* Check console for detailed error messages\n\n### maxSteps Exceeded\n\n**Symptom:**",
        "**Causes:**\n\n* Plan has too many steps\n* Infinite loop in function calls\n* LLM generating overly complex plans\n\n**Solutions:**\n\n* Increase",
        "(if appropriate)\n* Review function prompts to avoid recursion\n* Simplify component structure\n* Break complex operations into smaller functions\n\n### localStorage Quota Exceeded\n\n**Symptom:**",
        "in console\n\n**Causes:**\n\n* Chat history too large\n* Too many stored conversations\n* localStorage near capacity\n\n**Solutions:**\n\n* Clear old chat history\n* Reduce",
        "scope\n* Implement history cleanup\n* Use sessionStorage instead (cleared on tab close)\n\n## Performance Optimization\n\n### Reduce Debug Logging",
        "tsx\nruntime: {\r\n  enableDebugLogs: false, // Disable in production\r\n}",
        "### Limit Conversation History\n\nImplement history cleanup:",
        "tsx\n// Clear old messages periodically\r\nif (chatHistory.length > 100) {\r\n  chatHistory = chatHistory.slice(-50) // Keep last 50 messages\r\n}",
        "### Optimize Function Calls\n\n* Cache expensive operations\n* Batch multiple operations\n* Use async functions for I/O\n\n### Monitor Execution Time\n\nCheck console logs for timing information:",
        "[AUTOUI] Plan execution time: 234ms"
      ]
    }
  },
  {
    "slug": "/structure/deep/deeper/even-deeper",
    "title": "Introduction",
    "description": "This section provides an overview of Introduction.",
    "content": "Lorem ipsum dolor sit amet consectetur adipisicing elit. Numquam iste dolorum tempore consectetur explicabo tempora provident quia maxime, molestiae, facilis aperiam et, error illum vel ullam? Quis architecto dolore ullam\n\n* \\[x] Write the press release\n* \\[ ] Update the website\n* \\[ ] Contact the media\n\n| Syntax        | Description |   Test Text |\r\n| :------------ | :---------: | ----------: |\r\n| Header        |    Title    | Here's this |\r\n| Paragraph     |    Text     |    And more |\r\n| Strikethrough |             |    ~~Text~~ |\n",
    "_searchMeta": {
      "cleanContent": "lorem ipsum dolor sit amet consectetur adipisicing elit numquam iste dolorum tempore consectetur explicabo tempora provident quia maxime molestiae facilis aperiam et error illum vel ullam quis architecto dolore ullam x write the press release update the website contact the media syntax description test text :------------ :---------: ----------: header title here s this paragraph text and more strikethrough text",
      "headings": [],
      "keywords": []
    }
  },
  {
    "slug": "/structure/deep/deeper",
    "title": "Introduction",
    "description": "This section provides an overview of Introduction.",
    "content": "Lorem ipsum dolor sit amet consectetur adipisicing elit. Numquam iste dolorum tempore consectetur explicabo tempora provident quia maxime, molestiae, facilis aperiam et, error illum vel ullam? Quis architecto dolore ullam\n\n* \\[x] Write the press release\n* \\[ ] Update the website\n* \\[ ] Contact the media\n\n| Syntax        | Description |   Test Text |\r\n| :------------ | :---------: | ----------: |\r\n| Header        |    Title    | Here's this |\r\n| Paragraph     |    Text     |    And more |\r\n| Strikethrough |             |    ~~Text~~ |\n\n## Getting Started\n\nTo begin using the Documentation Template, follow these simple steps:\n\n* Start by cloning the repository to your local machine.\n\nLorem ipsum dolor sit amet consectetur adipisicing elit. Reprehenderit quae iure nulla deserunt dolore quam pariatur minus sapiente accusantium. Optio, necessitatibus sequi. Veritatis, aspernatur? Possimus quis repellat eum vitae eveniet.\n\n## Blockquotes\n\nBlockquotes are useful for emphasizing key points or quoting external sources:\n\n> \"Documentation is a love letter that you write to your future self.\" - Damian Conway\n\nFeel free to use blockquotes to highlight important information or quotes relevant to your documentation.\n\n## Code Examples with switch\n\nHere a custom tab component from shadcn ui is used.\n\n## Conclusion\n\nThank you for choosing the Documentation Template for your project. Whether you're documenting software, APIs, or processes, we're here to support you in creating clear and effective documentation. Happy documenting!\n\n## Tabs Example\n",
    "_searchMeta": {
      "cleanContent": "lorem ipsum dolor sit amet consectetur adipisicing elit numquam iste dolorum tempore consectetur explicabo tempora provident quia maxime molestiae facilis aperiam et error illum vel ullam quis architecto dolore ullam x write the press release update the website contact the media syntax description test text :------------ :---------: ----------: header title here s this paragraph text and more strikethrough text getting started to begin using the documentation template follow these simple steps: start by cloning the repository to your local machine lorem ipsum dolor sit amet consectetur adipisicing elit reprehenderit quae iure nulla deserunt dolore quam pariatur minus sapiente accusantium optio necessitatibus sequi veritatis aspernatur possimus quis repellat eum vitae eveniet blockquotes blockquotes are useful for emphasizing key points or quoting external sources: documentation is a love letter that you write to your future self - damian conway feel free to use blockquotes to highlight important information or quotes relevant to your documentation code examples with switch here a custom tab component from shadcn ui is used conclusion thank you for choosing the documentation template for your project whether you re documenting software apis or processes we re here to support you in creating clear and effective documentation happy documenting tabs example",
      "headings": [
        "Getting Started",
        "Blockquotes",
        "Code Examples with switch",
        "Conclusion",
        "Tabs Example"
      ],
      "keywords": [
        "Getting Started",
        "Blockquotes",
        "Code Examples with switch",
        "Conclusion",
        "Tabs Example"
      ]
    }
  },
  {
    "slug": "/structure/deep",
    "title": "Introduction",
    "description": "This section provides an overview of Introduction.",
    "content": "Lorem ipsum dolor sit amet consectetur adipisicing elit. Numquam iste dolorum tempore consectetur explicabo tempora provident quia maxime, molestiae, facilis aperiam et, error illum vel ullam? Quis architecto dolore ullam\n\n* \\[x] Write the press release\n* \\[ ] Update the website\n* \\[ ] Contact the media\n\n| Syntax        | Description |   Test Text |\r\n| :------------ | :---------: | ----------: |\r\n| Header        |    Title    | Here's this |\r\n| Paragraph     |    Text     |    And more |\r\n| Strikethrough |             |    ~~Text~~ |\n\n## Getting Started\n\nTo begin using the Documentation Template, follow these simple steps:\n\n* Start by cloning the repository to your local machine.\n\nLorem ipsum dolor sit amet consectetur adipisicing elit. Reprehenderit quae iure nulla deserunt dolore quam pariatur minus sapiente accusantium. Optio, necessitatibus sequi. Veritatis, aspernatur? Possimus quis repellat eum vitae eveniet.\n\n## Blockquotes\n\nBlockquotes are useful for emphasizing key points or quoting external sources:\n\n> \"Documentation is a love letter that you write to your future self.\" - Damian Conway\n\nFeel free to use blockquotes to highlight important information or quotes relevant to your documentation.\n\n## Code Examples with switch\n\nHere a custom tab component from shadcn ui is used.\n\n## Conclusion\n\nThank you for choosing the Documentation Template for your project. Whether you're documenting software, APIs, or processes, we're here to support you in creating clear and effective documentation. Happy documenting!\n\n## Tabs Example\n",
    "_searchMeta": {
      "cleanContent": "lorem ipsum dolor sit amet consectetur adipisicing elit numquam iste dolorum tempore consectetur explicabo tempora provident quia maxime molestiae facilis aperiam et error illum vel ullam quis architecto dolore ullam x write the press release update the website contact the media syntax description test text :------------ :---------: ----------: header title here s this paragraph text and more strikethrough text getting started to begin using the documentation template follow these simple steps: start by cloning the repository to your local machine lorem ipsum dolor sit amet consectetur adipisicing elit reprehenderit quae iure nulla deserunt dolore quam pariatur minus sapiente accusantium optio necessitatibus sequi veritatis aspernatur possimus quis repellat eum vitae eveniet blockquotes blockquotes are useful for emphasizing key points or quoting external sources: documentation is a love letter that you write to your future self - damian conway feel free to use blockquotes to highlight important information or quotes relevant to your documentation code examples with switch here a custom tab component from shadcn ui is used conclusion thank you for choosing the documentation template for your project whether you re documenting software apis or processes we re here to support you in creating clear and effective documentation happy documenting tabs example",
      "headings": [
        "Getting Started",
        "Blockquotes",
        "Code Examples with switch",
        "Conclusion",
        "Tabs Example"
      ],
      "keywords": [
        "Getting Started",
        "Blockquotes",
        "Code Examples with switch",
        "Conclusion",
        "Tabs Example"
      ]
    }
  },
  {
    "slug": "/structure",
    "title": "Structure",
    "description": "This section provides an overview of Introduction.",
    "content": "Lorem ipsum dolor sit amet consectetur adipisicing elit. Numquam iste dolorum tempore consectetur explicabo tempora provident quia maxime, molestiae, facilis aperiam et, error illum vel ullam? Quis architecto dolore ullam\n\n* \\[x] Write the press release\n* \\[ ] Update the website\n* \\[ ] Contact the media\n\n| Syntax        | Description |   Test Text |\r\n| :------------ | :---------: | ----------: |\r\n| Header        |    Title    | Here's this |\r\n| Paragraph     |    Text     |    And more |\r\n| Strikethrough |             |    ~~Text~~ |\n\n## Getting Started\n\nTo begin using the Documentation Template, follow these simple steps:\n\n* Start by cloning the repository to your local machine.\n\nLorem ipsum dolor sit amet consectetur adipisicing elit. Reprehenderit quae iure nulla deserunt dolore quam pariatur minus sapiente accusantium. Optio, necessitatibus sequi. Veritatis, aspernatur? Possimus quis repellat eum vitae eveniet.\n\n## Blockquotes\n\nBlockquotes are useful for emphasizing key points or quoting external sources:\n\n> \"Documentation is a love letter that you write to your future self.\" - Damian Conway\n\nFeel free to use blockquotes to highlight important information or quotes relevant to your documentation.\n\n## Code Examples with switch\n\nHere a custom tab component from shadcn ui is used.\n\n## Conclusion\n\nThank you for choosing the Documentation Template for your project. Whether you're documenting software, APIs, or processes, we're here to support you in creating clear and effective documentation. Happy documenting!\n",
    "_searchMeta": {
      "cleanContent": "lorem ipsum dolor sit amet consectetur adipisicing elit numquam iste dolorum tempore consectetur explicabo tempora provident quia maxime molestiae facilis aperiam et error illum vel ullam quis architecto dolore ullam x write the press release update the website contact the media syntax description test text :------------ :---------: ----------: header title here s this paragraph text and more strikethrough text getting started to begin using the documentation template follow these simple steps: start by cloning the repository to your local machine lorem ipsum dolor sit amet consectetur adipisicing elit reprehenderit quae iure nulla deserunt dolore quam pariatur minus sapiente accusantium optio necessitatibus sequi veritatis aspernatur possimus quis repellat eum vitae eveniet blockquotes blockquotes are useful for emphasizing key points or quoting external sources: documentation is a love letter that you write to your future self - damian conway feel free to use blockquotes to highlight important information or quotes relevant to your documentation code examples with switch here a custom tab component from shadcn ui is used conclusion thank you for choosing the documentation template for your project whether you re documenting software apis or processes we re here to support you in creating clear and effective documentation happy documenting",
      "headings": [
        "Getting Started",
        "Blockquotes",
        "Code Examples with switch",
        "Conclusion"
      ],
      "keywords": [
        "Getting Started",
        "Blockquotes",
        "Code Examples with switch",
        "Conclusion"
      ]
    }
  },
  {
    "slug": "/styling",
    "title": "ModalChat Styling",
    "description": "Customize ModalChat appearance, positioning, theming, and responsive behavior.",
    "content": "ModalChat provides a ready-to-use chat interface, but you can customize its appearance to match your application's design.\n\n## What Can Be Customized?\n\nModalChat supports customization through:\n\n* **Container styles**: Override default container classes\n* **Positioning**: Control where the chat button appears\n* **Theme tokens**: CSS variables for colors and spacing\n* **Responsive behavior**: Mobile and desktop layouts\n* **Custom trigger button**: Replace the default floating button\n\n## Basic Styling\n\n### Container Styles\n\nWrap ModalChat in a container and apply custom styles:\n\n```tsx\n<div className=\"autoui-wrapper\">\r\n  <ModalChat config={config} />\r\n</div>\n```\n\n```css\n.autoui-wrapper {\r\n  /* Override default positioning */\r\n  position: fixed;\r\n  bottom: 24px;\r\n  right: 24px;\r\n  z-index: 1000;\r\n}\r\n\r\n/* Customize the trigger button */\r\n.autoui-wrapper button {\r\n  background-color: #007bff;\r\n  border-radius: 50%;\r\n  width: 56px;\r\n  height: 56px;\r\n  box-shadow: 0 4px 12px rgba(0, 0, 0, 0.15);\r\n}\n```\n\n### Positioning\n\nControl where the chat button appears:\n\n```tsx\n<div style={{ position: 'fixed', bottom: '20px', right: '20px', zIndex: 1000 }}>\r\n  <ModalChat config={config} />\r\n</div>\n```\n\n**Common positions:**\n\n* Bottom-right (default): `bottom: 20px; right: 20px;`\n* Bottom-left: `bottom: 20px; left: 20px;`\n* Top-right: `top: 20px; right: 20px;`\n* Top-left: `top: 20px; left: 20px;`\n\n## Theming\n\n### CSS Variables\n\nIf ModalChat supports CSS variables, you can customize theme tokens:\n\n```css\n:root {\r\n  --autoui-primary: #007bff;\r\n  --autoui-background: #ffffff;\r\n  --autoui-text: #333333;\r\n  --autoui-border: #e0e0e0;\r\n  --autoui-radius: 8px;\r\n  --autoui-shadow: 0 4px 12px rgba(0, 0, 0, 0.15);\r\n}\r\n\r\n[data-theme=\"dark\"] {\r\n  --autoui-primary: #4a9eff;\r\n  --autoui-background: #1a1a1a;\r\n  --autoui-text: #ffffff;\r\n  --autoui-border: #333333;\r\n}\n```\n\n### Dark Mode\n\nModalChat should respect your app's theme. If you're using a theme provider (like `next-themes`), ensure ModalChat is wrapped in the provider:\n\n```tsx\nimport { ThemeProvider } from \"next-themes\"\r\n\r\nexport default function App() {\r\n  return (\r\n    <ThemeProvider attribute=\"class\" defaultTheme=\"system\">\r\n      <ModalChat config={config} />\r\n    </ThemeProvider>\r\n  )\r\n}\n```\n\n## Custom Trigger Button\n\nReplace the default floating button with your own:\n\n```tsx\nimport { useState } from 'react'\r\nimport { ModalChat } from \"@autoai-ui/autoui\"\r\n\r\nexport default function MyApp() {\r\n  const [isOpen, setIsOpen] = useState(false)\r\n\r\n  return (\r\n    <>\r\n      {/* Your custom trigger */}\r\n      <button \r\n        onClick={() => setIsOpen(true)}\r\n        className=\"my-custom-chat-button\"\r\n      >\r\n        Chat with AI\r\n      </button>\r\n\r\n      {/* ModalChat with controlled open state */}\r\n      <ModalChat \r\n        config={config} \r\n        open={isOpen}\r\n        onOpenChange={setIsOpen}\r\n      />\r\n    </>\r\n  )\r\n}\n```\n\n## Responsive Design\n\n### Mobile Optimization\n\nModalChat should be responsive by default, but you can add custom breakpoints:\n\n```css\n@media (max-width: 768px) {\r\n  .autoui-wrapper {\r\n    bottom: 16px;\r\n    right: 16px;\r\n  }\r\n\r\n  .autoui-wrapper button {\r\n    width: 48px;\r\n    height: 48px;\r\n  }\r\n}\n```\n\n### Full-Screen on Mobile\n\nMake the chat modal full-screen on mobile:\n\n```css\n@media (max-width: 768px) {\r\n  .autoui-modal {\r\n    width: 100vw;\r\n    height: 100vh;\r\n    max-width: 100vw;\r\n    max-height: 100vh;\r\n    border-radius: 0;\r\n  }\r\n}\n```\n\n## Advanced Customization\n\n### Custom Modal Container\n\nIf ModalChat accepts a `className` prop, you can style the modal container:\n\n```tsx\n<ModalChat \r\n  config={config}\r\n  className=\"my-custom-modal\"\r\n/>\n```\n\n```css\n.my-custom-modal {\r\n  border-radius: 16px;\r\n  box-shadow: 0 20px 60px rgba(0, 0, 0, 0.3);\r\n}\r\n\r\n.my-custom-modal .chat-header {\r\n  background: linear-gradient(135deg, #667eea 0%, #764ba2 100%);\r\n  color: white;\r\n  padding: 20px;\r\n}\n```\n\n### Z-Index Management\n\nEnsure ModalChat appears above other UI elements:\n\n```tsx\n<div style={{ zIndex: 9999 }}>\r\n  <ModalChat config={config} />\r\n</div>\n```\n\nOr use CSS:\n\n```css\n.autoui-wrapper {\r\n  z-index: 9999;\r\n}\n```\n\n## Styling Examples\n\n### Minimal Style\n\n```css\n.autoui-wrapper button {\r\n  background: #000;\r\n  color: #fff;\r\n  border: none;\r\n  border-radius: 50%;\r\n  width: 56px;\r\n  height: 56px;\r\n  cursor: pointer;\r\n  transition: transform 0.2s;\r\n}\r\n\r\n.autoui-wrapper button:hover {\r\n  transform: scale(1.1);\r\n}\n```\n\n### Branded Style\n\n```css\n.autoui-wrapper button {\r\n  background: linear-gradient(135deg, #667eea 0%, #764ba2 100%);\r\n  color: white;\r\n  border-radius: 50%;\r\n  width: 64px;\r\n  height: 64px;\r\n  box-shadow: 0 8px 24px rgba(102, 126, 234, 0.4);\r\n}\r\n\r\n.autoui-wrapper button::before {\r\n  content: \"💬\";\r\n  font-size: 24px;\r\n}\n```\n\n### Compact Style\n\n```css\n.autoui-wrapper button {\r\n  background: #007bff;\r\n  color: white;\r\n  border-radius: 12px;\r\n  width: auto;\r\n  height: 40px;\r\n  padding: 0 16px;\r\n  font-size: 14px;\r\n  font-weight: 500;\r\n}\n```\n\n## Best Practices\n\n<Note title=\"Performance\" type=\"warning\">\n  * Avoid heavy CSS animations that impact performance\n  * Use CSS transforms for animations (GPU-accelerated)\n  * Minimize re-renders with proper React patterns\n</Note>\n\n## Troubleshooting\n\n### Styles Not Applying\n\n* Check CSS specificity (use `!important` sparingly)\n* Verify class names match ModalChat's internal structure\n* Inspect the DOM to see actual class names\n* Ensure styles are loaded after ModalChat's default styles\n\n### Z-Index Issues\n\n* Increase z-index value\n* Check parent containers for `position` and `z-index`\n* Use browser DevTools to inspect stacking context\n\n### Dark Mode Not Working\n\n* Verify theme provider is wrapping ModalChat\n* Check CSS variable names match ModalChat's expectations\n* Inspect computed styles in DevTools\n* Ensure `data-theme` or `class` attributes are set correctly\n\n## Next Steps\n\n* Learn about functions: [Functions](/docs/functions)\n* Explore components registry: [Components](/docs/components)\n* Configure runtime: [Runtime & Debugging](/docs/runtime)\n",
    "_searchMeta": {
      "cleanContent": "modalchat provides a ready-to-use chat interface but you can customize its appearance to match your application s design what can be customized modalchat supports customization through: container styles: override default container classes positioning: control where the chat button appears theme tokens: css variables for colors and spacing responsive behavior: mobile and desktop layouts custom trigger button: replace the default floating button basic styling container styles wrap modalchat in a container and apply custom styles: positioning control where the chat button appears: common positions: bottom-right default : bottom: 20px right: 20px bottom-left: bottom: 20px left: 20px top-right: top: 20px right: 20px top-left: top: 20px left: 20px theming css variables if modalchat supports css variables you can customize theme tokens: dark mode modalchat should respect your app s theme if you re using a theme provider like next-themes ensure modalchat is wrapped in the provider: custom trigger button replace the default floating button with your own: responsive design mobile optimization modalchat should be responsive by default but you can add custom breakpoints: full-screen on mobile make the chat modal full-screen on mobile: advanced customization custom modal container if modalchat accepts a classname prop you can style the modal container: z-index management ensure modalchat appears above other ui elements: or use css: styling examples minimal style branded style compact style best practices avoid heavy css animations that impact performance use css transforms for animations gpu-accelerated minimize re-renders with proper react patterns troubleshooting styles not applying check css specificity use important sparingly verify class names match modalchat s internal structure inspect the dom to see actual class names ensure styles are loaded after modalchat s default styles z-index issues increase z-index value check parent containers for position and z-index use browser devtools to inspect stacking context dark mode not working verify theme provider is wrapping modalchat check css variable names match modalchat s expectations inspect computed styles in devtools ensure data-theme or class attributes are set correctly next steps learn about functions: functions explore components registry: components configure runtime: runtime debugging",
      "headings": [
        "What Can Be Customized?",
        "Basic Styling",
        "Theming",
        "Custom Trigger Button",
        "Responsive Design",
        "Advanced Customization",
        "Styling Examples",
        "Best Practices",
        "Troubleshooting",
        "Next Steps"
      ],
      "keywords": [
        "styling",
        "theming",
        "modalchat",
        "css",
        "customization",
        "dark mode",
        "What Can Be Customized?",
        "Basic Styling",
        "Theming",
        "Custom Trigger Button",
        "Responsive Design",
        "Advanced Customization",
        "Styling Examples",
        "Best Practices",
        "Troubleshooting",
        "Next Steps",
        "Container styles",
        "Positioning",
        "Theme tokens",
        "Responsive behavior",
        "Custom trigger button",
        "Common positions:",
        "tsx\n<div className=\"autoui-wrapper\">\r\n  <ModalChat config={config} />\r\n</div>",
        "",
        "css\n.autoui-wrapper {\r\n  /* Override default positioning */\r\n  position: fixed;\r\n  bottom: 24px;\r\n  right: 24px;\r\n  z-index: 1000;\r\n}\r\n\r\n/* Customize the trigger button */\r\n.autoui-wrapper button {\r\n  background-color: #007bff;\r\n  border-radius: 50%;\r\n  width: 56px;\r\n  height: 56px;\r\n  box-shadow: 0 4px 12px rgba(0, 0, 0, 0.15);\r\n}",
        "### Positioning\n\nControl where the chat button appears:",
        "tsx\n<div style={{ position: 'fixed', bottom: '20px', right: '20px', zIndex: 1000 }}>\r\n  <ModalChat config={config} />\r\n</div>",
        "**Common positions:**\n\n* Bottom-right (default):",
        "* Bottom-left:",
        "* Top-right:",
        "* Top-left:",
        "## Theming\n\n### CSS Variables\n\nIf ModalChat supports CSS variables, you can customize theme tokens:",
        "css\n:root {\r\n  --autoui-primary: #007bff;\r\n  --autoui-background: #ffffff;\r\n  --autoui-text: #333333;\r\n  --autoui-border: #e0e0e0;\r\n  --autoui-radius: 8px;\r\n  --autoui-shadow: 0 4px 12px rgba(0, 0, 0, 0.15);\r\n}\r\n\r\n[data-theme=\"dark\"] {\r\n  --autoui-primary: #4a9eff;\r\n  --autoui-background: #1a1a1a;\r\n  --autoui-text: #ffffff;\r\n  --autoui-border: #333333;\r\n}",
        "### Dark Mode\n\nModalChat should respect your app's theme. If you're using a theme provider (like",
        "), ensure ModalChat is wrapped in the provider:",
        "tsx\nimport { ThemeProvider } from \"next-themes\"\r\n\r\nexport default function App() {\r\n  return (\r\n    <ThemeProvider attribute=\"class\" defaultTheme=\"system\">\r\n      <ModalChat config={config} />\r\n    </ThemeProvider>\r\n  )\r\n}",
        "## Custom Trigger Button\n\nReplace the default floating button with your own:",
        "tsx\nimport { useState } from 'react'\r\nimport { ModalChat } from \"@autoai-ui/autoui\"\r\n\r\nexport default function MyApp() {\r\n  const [isOpen, setIsOpen] = useState(false)\r\n\r\n  return (\r\n    <>\r\n      {/* Your custom trigger */}\r\n      <button \r\n        onClick={() => setIsOpen(true)}\r\n        className=\"my-custom-chat-button\"\r\n      >\r\n        Chat with AI\r\n      </button>\r\n\r\n      {/* ModalChat with controlled open state */}\r\n      <ModalChat \r\n        config={config} \r\n        open={isOpen}\r\n        onOpenChange={setIsOpen}\r\n      />\r\n    </>\r\n  )\r\n}",
        "## Responsive Design\n\n### Mobile Optimization\n\nModalChat should be responsive by default, but you can add custom breakpoints:",
        "css\n@media (max-width: 768px) {\r\n  .autoui-wrapper {\r\n    bottom: 16px;\r\n    right: 16px;\r\n  }\r\n\r\n  .autoui-wrapper button {\r\n    width: 48px;\r\n    height: 48px;\r\n  }\r\n}",
        "### Full-Screen on Mobile\n\nMake the chat modal full-screen on mobile:",
        "css\n@media (max-width: 768px) {\r\n  .autoui-modal {\r\n    width: 100vw;\r\n    height: 100vh;\r\n    max-width: 100vw;\r\n    max-height: 100vh;\r\n    border-radius: 0;\r\n  }\r\n}",
        "## Advanced Customization\n\n### Custom Modal Container\n\nIf ModalChat accepts a",
        "prop, you can style the modal container:",
        "tsx\n<ModalChat \r\n  config={config}\r\n  className=\"my-custom-modal\"\r\n/>",
        "css\n.my-custom-modal {\r\n  border-radius: 16px;\r\n  box-shadow: 0 20px 60px rgba(0, 0, 0, 0.3);\r\n}\r\n\r\n.my-custom-modal .chat-header {\r\n  background: linear-gradient(135deg, #667eea 0%, #764ba2 100%);\r\n  color: white;\r\n  padding: 20px;\r\n}",
        "### Z-Index Management\n\nEnsure ModalChat appears above other UI elements:",
        "tsx\n<div style={{ zIndex: 9999 }}>\r\n  <ModalChat config={config} />\r\n</div>",
        "Or use CSS:",
        "css\n.autoui-wrapper {\r\n  z-index: 9999;\r\n}",
        "## Styling Examples\n\n### Minimal Style",
        "css\n.autoui-wrapper button {\r\n  background: #000;\r\n  color: #fff;\r\n  border: none;\r\n  border-radius: 50%;\r\n  width: 56px;\r\n  height: 56px;\r\n  cursor: pointer;\r\n  transition: transform 0.2s;\r\n}\r\n\r\n.autoui-wrapper button:hover {\r\n  transform: scale(1.1);\r\n}",
        "### Branded Style",
        "css\n.autoui-wrapper button {\r\n  background: linear-gradient(135deg, #667eea 0%, #764ba2 100%);\r\n  color: white;\r\n  border-radius: 50%;\r\n  width: 64px;\r\n  height: 64px;\r\n  box-shadow: 0 8px 24px rgba(102, 126, 234, 0.4);\r\n}\r\n\r\n.autoui-wrapper button::before {\r\n  content: \"💬\";\r\n  font-size: 24px;\r\n}",
        "### Compact Style",
        "css\n.autoui-wrapper button {\r\n  background: #007bff;\r\n  color: white;\r\n  border-radius: 12px;\r\n  width: auto;\r\n  height: 40px;\r\n  padding: 0 16px;\r\n  font-size: 14px;\r\n  font-weight: 500;\r\n}",
        "## Best Practices\n\n<Note title=\"Performance\" type=\"warning\">\n  * Avoid heavy CSS animations that impact performance\n  * Use CSS transforms for animations (GPU-accelerated)\n  * Minimize re-renders with proper React patterns\n</Note>\n\n## Troubleshooting\n\n### Styles Not Applying\n\n* Check CSS specificity (use",
        "sparingly)\n* Verify class names match ModalChat's internal structure\n* Inspect the DOM to see actual class names\n* Ensure styles are loaded after ModalChat's default styles\n\n### Z-Index Issues\n\n* Increase z-index value\n* Check parent containers for",
        "and",
        "* Use browser DevTools to inspect stacking context\n\n### Dark Mode Not Working\n\n* Verify theme provider is wrapping ModalChat\n* Check CSS variable names match ModalChat's expectations\n* Inspect computed styles in DevTools\n* Ensure",
        "or"
      ]
    }
  },
  {
    "slug": "/troubleshooting",
    "title": "Troubleshooting & FAQ",
    "description": "Common issues, solutions, and frequently asked questions about AUTOUI.",
    "content": "This guide covers common issues and solutions when working with AUTOUI.\n\n## Common Issues\n\n### ModalChat Not Rendering\n\n**Symptom:** ModalChat component doesn't appear on the page.\n\n**Possible causes:**\n\n* SSR mismatch (Next.js)\n* Missing dynamic import\n* CSS z-index issues\n* Config validation errors\n\n**Solutions:**\n\n### Proxy Server Connection Errors\n\n**Symptom:** `Failed to connect to proxy server` or CORS errors.\n\n**Possible causes:**\n\n* Proxy server not running\n* Incorrect `proxyUrl` in config\n* CORS not configured\n* Network/firewall issues\n\n**Solutions:**\n\n### LLM Not Responding\n\n**Symptom:** Chat messages are sent but no response is received.\n\n**Possible causes:**\n\n* Invalid OpenRouter API key\n* Proxy server not forwarding requests\n* LLM provider errors\n* Network timeouts\n\n**Solutions:**\n\n### Functions Not Being Called\n\n**Symptom:** Functions are registered but the LLM never calls them.\n\n**Possible causes:**\n\n* Unclear function prompts\n* Missing or incorrect params descriptions\n* LLM doesn't understand when to use the function\n\n**Solutions:**\n\n### Components Not Rendering\n\n**Symptom:** Components are registered but never rendered by the LLM.\n\n**Possible causes:**\n\n* Unclear component prompts\n* Missing or incorrect defaults\n* LLM doesn't understand when to render\n\n**Solutions:**\n\n### Plan Execution Errors\n\n**Symptom:** Plans are received but execution fails.\n\n**Possible causes:**\n\n* Invalid plan structure\n* Function errors\n* Missing state or dependencies\n* maxSteps exceeded\n\n**Solutions:**\n\n## FAQ\n\n### Do I need a proxy server?\n\n**Answer:** Yes, for production. The proxy server keeps your OpenRouter API key secure. For development, you may be able to use direct API key mode (not recommended for production).\n\n### Can I use AUTOUI without React?\n\n**Answer:** No, AUTOUI is built specifically for React applications. ModalChat is a React component.\n\n### How do I customize the chat UI?\n\n**Answer:** See the [ModalChat Styling](/docs/styling) guide. You can customize positioning, theming, and appearance through CSS.\n\n### Can I use my own LLM provider?\n\n**Answer:** AUTOUI is designed to work with OpenRouter, which provides access to multiple LLM providers. You may be able to configure other providers through the proxy server.\n\n### How do I handle authentication?\n\n**Answer:** Authentication should be handled in your functions. For example:\n\n```tsx\nfunctions: {\r\n  getCurrentUser: {\r\n    prompt: 'Get the currently authenticated user.',\r\n    callFunc: () => {\r\n      return auth.getCurrentUser()\r\n    },\r\n  },\r\n}\n```\n\n### Can I stream responses?\n\n**Answer:** AUTOUI uses a request/response pattern, not streaming. Each turn sends a message and receives a complete response.\n\n### How do I clear chat history?\n\n**Answer:** Clear localStorage:\n\n```javascript\nlocalStorage.removeItem('autoui_chat')\n```\n\nOr change the `localStorageKey` in your config.\n\n### What's the difference between functions and components?\n\n**Answer:**\n\n* **Functions**: Execute JavaScript code, modify state, trigger side effects\n* **Components**: Render React UI elements dynamically\n\nSee [Functions](/docs/functions) and [Components](/docs/components) for details.\n\n### How do I debug plan execution?\n\n**Answer:** Enable debug logs:\n\n```tsx\nruntime: {\r\n  enableDebugLogs: true,\r\n}\n```\n\nThen check the browser console for detailed logs. See [Runtime & Debugging](/docs/runtime) for more.\n\n### Can I use TypeScript?\n\n**Answer:** Yes! AUTOUI is written in TypeScript and provides type definitions. Import types:\n\n```tsx\nimport { AutoUIConfig } from \"@autoai-ui/autoui\"\n```\n\n## Getting Help\n\nIf you're still experiencing issues:\n\n1. **Check the documentation**: Review relevant guides\n2. **Enable debug logs**: See [Runtime & Debugging](/docs/runtime)\n3. **Check browser console**: Look for error messages\n4. **Review proxy server logs**: Check server-side errors\n5. **Search GitHub issues**: Check for similar problems\n6. **Contact support**: Reach out via GitHub or project channels\n\n## Next Steps\n\n* Review configuration: [Installation & Configuration](/docs/installation)\n* Understand runtime: [Runtime & Debugging](/docs/runtime)\n* Learn about functions: [Functions](/docs/functions)\n* Explore components: [Components](/docs/components)\n",
    "_searchMeta": {
      "cleanContent": "this guide covers common issues and solutions when working with autoui common issues modalchat not rendering symptom: modalchat component doesn t appear on the page possible causes: ssr mismatch next js missing dynamic import css z-index issues config validation errors solutions: proxy server connection errors symptom: failed to connect to proxy server or cors errors possible causes: proxy server not running incorrect proxyurl in config cors not configured network firewall issues solutions: llm not responding symptom: chat messages are sent but no response is received possible causes: invalid openrouter api key proxy server not forwarding requests llm provider errors network timeouts solutions: functions not being called symptom: functions are registered but the llm never calls them possible causes: unclear function prompts missing or incorrect params descriptions llm doesn t understand when to use the function solutions: components not rendering symptom: components are registered but never rendered by the llm possible causes: unclear component prompts missing or incorrect defaults llm doesn t understand when to render solutions: plan execution errors symptom: plans are received but execution fails possible causes: invalid plan structure function errors missing state or dependencies maxsteps exceeded solutions: faq do i need a proxy server answer: yes for production the proxy server keeps your openrouter api key secure for development you may be able to use direct api key mode not recommended for production can i use autoui without react answer: no autoui is built specifically for react applications modalchat is a react component how do i customize the chat ui answer: see the modalchat styling guide you can customize positioning theming and appearance through css can i use my own llm provider answer: autoui is designed to work with openrouter which provides access to multiple llm providers you may be able to configure other providers through the proxy server how do i handle authentication answer: authentication should be handled in your functions for example: can i stream responses answer: autoui uses a request response pattern not streaming each turn sends a message and receives a complete response how do i clear chat history answer: clear localstorage: or change the localstoragekey in your config what s the difference between functions and components answer: functions: execute javascript code modify state trigger side effects components: render react ui elements dynamically see functions and components for details how do i debug plan execution answer: enable debug logs: then check the browser console for detailed logs see runtime debugging for more can i use typescript answer: yes autoui is written in typescript and provides type definitions import types: getting help if you re still experiencing issues: check the documentation: review relevant guides enable debug logs: see runtime debugging check browser console: look for error messages review proxy server logs: check server-side errors search github issues: check for similar problems contact support: reach out via github or project channels next steps review configuration: installation configuration understand runtime: runtime debugging learn about functions: functions explore components: components",
      "headings": [
        "Common Issues",
        "FAQ",
        "Getting Help",
        "Next Steps"
      ],
      "keywords": [
        "troubleshooting",
        "faq",
        "errors",
        "debugging",
        "common issues",
        "Common Issues",
        "FAQ",
        "Getting Help",
        "Next Steps",
        "Symptom:",
        "Possible causes:",
        "Solutions:",
        "Answer:",
        "Functions",
        "Components",
        "Check the documentation",
        "Enable debug logs",
        "Check browser console",
        "Review proxy server logs",
        "Search GitHub issues",
        "Contact support",
        "Failed to connect to proxy server",
        "proxyUrl",
        "tsx\nfunctions: {\r\n  getCurrentUser: {\r\n    prompt: 'Get the currently authenticated user.',\r\n    callFunc: () => {\r\n      return auth.getCurrentUser()\r\n    },\r\n  },\r\n}",
        "### Can I stream responses?\n\n**Answer:** AUTOUI uses a request/response pattern, not streaming. Each turn sends a message and receives a complete response.\n\n### How do I clear chat history?\n\n**Answer:** Clear localStorage:",
        "javascript\nlocalStorage.removeItem('autoui_chat')",
        "Or change the",
        "in your config.\n\n### What's the difference between functions and components?\n\n**Answer:**\n\n* **Functions**: Execute JavaScript code, modify state, trigger side effects\n* **Components**: Render React UI elements dynamically\n\nSee [Functions](/docs/functions) and [Components](/docs/components) for details.\n\n### How do I debug plan execution?\n\n**Answer:** Enable debug logs:",
        "tsx\nruntime: {\r\n  enableDebugLogs: true,\r\n}",
        "Then check the browser console for detailed logs. See [Runtime & Debugging](/docs/runtime) for more.\n\n### Can I use TypeScript?\n\n**Answer:** Yes! AUTOUI is written in TypeScript and provides type definitions. Import types:",
        "tsx\nimport { AutoUIConfig } from \"@autoai-ui/autoui\""
      ]
    }
  }
]