[
  {
    "slug": "/backend-proxy",
    "title": "Backend Proxy: Clone, Run, Connect",
    "description": "Set up the AUTOUI proxy server to securely handle LLM API keys and manage client authentication.",
    "content": "The AUTOUI proxy server is a **backend component** that keeps your OpenRouter API key secure on the server while allowing your frontend to communicate with LLM providers. You can either use AutoUI's deployed service or run your own proxy server.\n\n## Why Use a Proxy?\n\nThe proxy server provides:\n\n* **API Key Security**: Your OpenRouter API key stays on the server, never exposed to browsers\n* **Unified Authentication**: Single client key (shared secret) for all frontend instances\n* **Rate Limiting**: Centralized control over request rates\n* **CORS Management**: Proper CORS headers for cross-origin requests\n* **Request Logging**: Server-side logging for debugging and monitoring\n\n## Architecture\n\n```\nFrontend (Browser)\n  │\n  │ Sends: config + user message + sharedSecret\n  ▼\nProxy Server (Your Backend)\n  │\n  │ Adds: OPENROUTER_API_KEY\n  ▼\nOpenRouter API\n  │\n  │ Returns: Plan JSON\n  ▼\nProxy Server\n  │\n  │ Forwards: Plan JSON\n  ▼\nFrontend Runtime\n```\n\n## Setup Steps\n\n## Production Checklist\n\nBefore deploying to production, ensure:\n\n## Security Best Practices\n\n<Note title=\"Client Key Security\" type=\"warning\">\n  * Client keys (shared secrets) can be included in frontend code, but:\n    * Use different keys for different environments\n    * Rotate keys periodically\n    * Monitor for unauthorized usage\n    * Consider IP whitelisting for production\n</Note>\n\n## Troubleshooting\n\n### Proxy Server Won't Start\n\n* Check that `PORT` is not already in use\n* Verify `OPENROUTER_API_KEY` is set correctly\n* Check server logs for error messages\n* Ensure all dependencies are installed\n\n### Frontend Can't Connect to Proxy\n\n* Verify `proxyUrl` matches the server URL\n* Check CORS configuration allows your frontend origin\n* Ensure proxy server is running\n* Check browser console for CORS errors\n\n### Client Key Not Working\n\n* Verify the key was copied correctly (no extra spaces)\n* Ensure the key was generated with the same OpenRouter API key\n* Check proxy server logs for authentication errors\n* Regenerate the key if needed\n\n### OpenRouter API Errors\n\n* Verify your OpenRouter API key is valid\n* Check your OpenRouter account balance/limits\n* Review OpenRouter API documentation for error codes\n* Check proxy server logs for detailed error messages\n\n## Next Steps\n\n* Configure your frontend: See [Installation & Configuration](/docs/installation)\n* Add functions: See [Functions](/docs/functions)\n* Customize styling: See [ModalChat Styling](/docs/styling)\n",
    "_searchMeta": {
      "cleanContent": "the autoui proxy server is a backend component that keeps your openrouter api key secure on the server while allowing your frontend to communicate with llm providers you can either use autoui s deployed service or run your own proxy server why use a proxy the proxy server provides: api key security: your openrouter api key stays on the server never exposed to browsers unified authentication: single client key shared secret for all frontend instances rate limiting: centralized control over request rates cors management: proper cors headers for cross-origin requests request logging: server-side logging for debugging and monitoring architecture setup steps production checklist before deploying to production ensure: security best practices client keys shared secrets can be included in frontend code but: use different keys for different environments rotate keys periodically monitor for unauthorized usage consider ip whitelisting for production troubleshooting proxy server won t start check that port is not already in use verify openrouterapikey is set correctly check server logs for error messages ensure all dependencies are installed frontend can t connect to proxy verify proxyurl matches the server url check cors configuration allows your frontend origin ensure proxy server is running check browser console for cors errors client key not working verify the key was copied correctly no extra spaces ensure the key was generated with the same openrouter api key check proxy server logs for authentication errors regenerate the key if needed openrouter api errors verify your openrouter api key is valid check your openrouter account balance limits review openrouter api documentation for error codes check proxy server logs for detailed error messages next steps configure your frontend: see installation configuration add functions: see functions customize styling: see modalchat styling",
      "headings": [
        "Why Use a Proxy?",
        "Architecture",
        "Setup Steps",
        "Production Checklist",
        "Security Best Practices",
        "Troubleshooting",
        "Next Steps"
      ],
      "keywords": [
        "proxy",
        "backend",
        "openrouter",
        "security",
        "api key",
        "client key",
        "Why Use a Proxy?",
        "Architecture",
        "Setup Steps",
        "Production Checklist",
        "Security Best Practices",
        "Troubleshooting",
        "Next Steps",
        "backend component",
        "API Key Security",
        "Unified Authentication",
        "Rate Limiting",
        "CORS Management",
        "Request Logging",
        "Frontend (Browser)\n  │\n  │ Sends: config + user message + sharedSecret\n  ▼\nProxy Server (Your Backend)\n  │\n  │ Adds: OPENROUTER_API_KEY\n  ▼\nOpenRouter API\n  │\n  │ Returns: Plan JSON\n  ▼\nProxy Server\n  │\n  │ Forwards: Plan JSON\n  ▼\nFrontend Runtime",
        "## Setup Steps\n\n## Production Checklist\n\nBefore deploying to production, ensure:\n\n## Security Best Practices\n\n<Note title=\"Client Key Security\" type=\"warning\">\n  * Client keys (shared secrets) can be included in frontend code, but:\n    * Use different keys for different environments\n    * Rotate keys periodically\n    * Monitor for unauthorized usage\n    * Consider IP whitelisting for production\n</Note>\n\n## Troubleshooting\n\n### Proxy Server Won't Start\n\n* Check that",
        "is not already in use\n* Verify",
        "is set correctly\n* Check server logs for error messages\n* Ensure all dependencies are installed\n\n### Frontend Can't Connect to Proxy\n\n* Verify"
      ]
    }
  },
  {
    "slug": "/basic-setup/changelog",
    "title": "Changelog",
    "description": "Changelogs and improvements to the Documents projects.",
    "content": "## Added\n\n**Linting and Formatting**:\n\n* Added `pnpm run lint` and `pnpm run lint:fix` scripts to automate linting tasks.\n* Added `pnpm run format` and `pnpm run format:check` scripts to ensure consistent code formatting.\n\n**SEO Enhancements**:\n\n* Added an SEO component to MDX pages to dynamically include `keywords` and `lastModified` metadata for improved SEO generation.\n\n## Updated\n\n**Next.js Upgrade**:\n\n* Upgraded the project from **Next.js 14** to **Next.js 15**, leveraging the latest features and performance improvements.\n\n**Codebase Improvements**:\n\n* Reordered imports across the project files for better consistency and readability.\n\n**Mermaid Component**:\n\n* Fixed an ID bug that caused rendering issues when multiple Mermaid diagrams were included in MDX pages.\n* Improved initialization and rendering logic to prevent duplicate diagram rendering.\n",
    "_searchMeta": {
      "cleanContent": "added linting and formatting: added pnpm run lint and pnpm run lint:fix scripts to automate linting tasks added pnpm run format and pnpm run format:check scripts to ensure consistent code formatting seo enhancements: added an seo component to mdx pages to dynamically include keywords and lastmodified metadata for improved seo generation updated next js upgrade: upgraded the project from next js 14 to next js 15 leveraging the latest features and performance improvements codebase improvements: reordered imports across the project files for better consistency and readability mermaid component: fixed an id bug that caused rendering issues when multiple mermaid diagrams were included in mdx pages improved initialization and rendering logic to prevent duplicate diagram rendering",
      "headings": [
        "Added",
        "Updated"
      ],
      "keywords": [
        "changelog",
        "guide",
        "nextjs",
        "documents",
        "Added",
        "Updated",
        "Linting and Formatting",
        "SEO Enhancements",
        "Next.js Upgrade",
        "Next.js 14",
        "Next.js 15",
        "Codebase Improvements",
        "Mermaid Component",
        "pnpm run lint",
        "pnpm run lint:fix",
        "pnpm run format",
        "pnpm run format:check",
        "keywords",
        "lastModified"
      ]
    }
  },
  {
    "slug": "/basic-setup",
    "title": "Introduction",
    "description": "This section provides an overview of how to get started with the Documents, Next.js Document Starter Kit.",
    "content": "![Banner](/images/banner.png \"Documents\")\n\n## Documents\n\n**Documents** is a lightweight, modular starter kit built with **Next.js**, **React**, **Tailwind CSS**, and **TypeScript**. It’s designed to help you\nlaunch structured, professional documentation without spending time on boilerplate.\n\nWhether you're building product manuals, internal systems guides, or dev documentation, Documents gives you a clean foundation that’s easy to\nextend and maintain.\n\n## Why use Documents?\n\nThis kit was built to simplify how teams manage and publish documentation. It works across projects of all sizes—from a single\nreadme to enterprise knowledge bases.\n\nWith MDX, reusable components, and Tailwind styling, it keeps your workflow efficient without compromising flexibility.\n\nUse it for:\n\n* **Product Guides** – Setup, usage, and troubleshooting\n* **Internal Docs** – Processes, policies, and team references\n* **Technical Manuals** – APIs, SDKs, architecture walkthroughs\n\nCustomize the UI and structure to match your brand or workflow—no lock-in.\n\n## Core Features\n\n| Feature                              | Description                                                                 |\n| ------------------------------------ | --------------------------------------------------------------------------- |\n| **Write in Markdown/MDX**            | Combine Markdown with components and Mermaid.js for rich content.           |\n| **Flexible Navigation**              | Multi-level menus, page hierarchy, and auto-generated TOCs.                 |\n| **Code Support**                     | Syntax highlighting, code tabs, and one-click copy.                         |\n| **Search**                           | Fuzzy matching with highlight and instant results.                          |\n| **Responsive Design**                | Built-in light/dark mode with mobile support.                               |\n| **Math + Tables**                    | LaTeX rendering and clean table styling.                                    |\n| **SEO Defaults**                     | Preconfigured meta, Open Graph, and structured data.                        |\n| **AI Docs (Upcoming)**               | AI tools for smart search and content generation (coming soon).             |\n\n## Using This Kit\n\nNavigation is on the left. Pages flow from setup to advanced features, but you're free to jump around.\n\nUse the table of contents on the right to skip through sections.\n\nStart with the [Installation Guide](/docs/basic-setup/installation).\n\n## Community Support\n\nGot questions? Reach out via:\n\n* [GitHub](https://github.com/autoai-ui/autoui)\n* [NPM](https://www.npmjs.com/package/@autoai-ui/autoui)\n",
    "_searchMeta": {
      "cleanContent": "banner documents documents is a lightweight modular starter kit built with next js react tailwind css and typescript it s designed to help you launch structured professional documentation without spending time on boilerplate whether you re building product manuals internal systems guides or dev documentation documents gives you a clean foundation that s easy to extend and maintain why use documents this kit was built to simplify how teams manage and publish documentation it works across projects of all sizes from a single readme to enterprise knowledge bases with mdx reusable components and tailwind styling it keeps your workflow efficient without compromising flexibility use it for: product guides setup usage and troubleshooting internal docs processes policies and team references technical manuals apis sdks architecture walkthroughs customize the ui and structure to match your brand or workflow no lock-in core features feature description------------------------------------ ---------------------------------------------------------------------------write in markdown mdx combine markdown with components and mermaid js for rich content flexible navigation multi-level menus page hierarchy and auto-generated tocs code support syntax highlighting code tabs and one-click copy search fuzzy matching with highlight and instant results responsive design built-in light dark mode with mobile support math tables latex rendering and clean table styling seo defaults preconfigured meta open graph and structured data ai docs upcoming ai tools for smart search and content generation coming soon using this kit navigation is on the left pages flow from setup to advanced features but you re free to jump around use the table of contents on the right to skip through sections start with the installation guide community support got questions reach out via: github npm",
      "headings": [
        "Documents",
        "Why use Documents?",
        "Core Features",
        "Using This Kit",
        "Community Support"
      ],
      "keywords": [
        "introduction",
        "guide",
        "nextjs",
        "documents",
        "Documents",
        "Why use Documents?",
        "Core Features",
        "Using This Kit",
        "Community Support",
        "Next.js",
        "React",
        "Tailwind CSS",
        "TypeScript",
        "Product Guides",
        "Internal Docs",
        "Technical Manuals",
        "Write in Markdown/MDX",
        "Flexible Navigation",
        "Code Support",
        "Search",
        "Responsive Design",
        "Math + Tables",
        "SEO Defaults",
        "AI Docs (Upcoming)"
      ]
    }
  },
  {
    "slug": "/basic-setup/installation",
    "title": "Installation",
    "description": "This guide covers the installation of Documents and how to edit your new project.",
    "content": "To install and edit the Documents, you need to have several prerequisites in place. Here's a list of all the essential pre-requisites\nfor setting up and working on this project.\n\n[![Deploy with Vercel](https://vercel.com/button)](https://vercel.com/new/clone?repository-url=https%3A%2F%2Fgithub.com%2Fautoai-ui%2Fautoui\\&project-name=autoui-docs\\&repository-name=autoui-docs)\n\n## Prerequisites\n\n## Installation\n\n## Optional\n\n## Important Information\n\nThe project's search functionality relies on the Husky's automation to build `search-data/documents.json` ensure git commit is performed to generate this file.\n",
    "_searchMeta": {
      "cleanContent": "to install and edit the documents you need to have several prerequisites in place here s a list of all the essential pre-requisites for setting up and working on this project deploy with vercel https: vercel com new clone repository-url https 3a 2f 2fgithub com 2fautoai-ui 2fautoui project-name autoui-docs repository-name autoui-docs prerequisites installation optional important information the project s search functionality relies on the husky s automation to build search-data documents json ensure git commit is performed to generate this file",
      "headings": [
        "Prerequisites",
        "Installation",
        "Optional",
        "Important Information"
      ],
      "keywords": [
        "installation",
        "github",
        "node",
        "guide",
        "nextjs",
        "documents",
        "Prerequisites",
        "Installation",
        "Optional",
        "Important Information",
        "search-data/documents.json"
      ]
    }
  },
  {
    "slug": "/basic-setup/setup",
    "title": "Setup",
    "description": "Setting up and configuring your documentation project",
    "content": "Setting up your new documentation project is straightforward. Most of the essential project settings can be configured within the `settings` folder.\n\n## Settings\n\nThis section provides the core settings for your documentation site, such as defining the site's URL, site icon and title.\n\n```tsx showLineNumbers\nexport const url = \"\"                 // The URL for your documentation site\r\nexport const siteicon = \"\"            // Icon displayed next to the site name in the header\r\nexport const sitename = \"\"            // Title of your documentation site\n```\n\n## Google Tags\n\nThis section allows you to integrate Google Tag Manager into your documentation project. You can add your GTM code and configure whether it's connected.\n\n```tsx showLineNumbers\nexport const gtm = \"\"                 // Add your Google Tag Manager code here\r\nexport const gtmconnected = true      // Set to true if GTM is connected, otherwise set to false\n```\n\n## Search Engine\n\nConfigure essential SEO settings to ensure your documentation site is optimized for search engines. This includes meta descriptions, keywords and social media sharing details like images and alt text.\n\n```tsx showLineNumbers\nexport const description = \"\"         // Description of your documentation site for SEO\r\nexport const keywords = [\"\", \"\"]      // List of SEO keywords for your documentation site\r\nexport const urlimage = \"\"            // The URL of the image used when sharing on social media)\r\nexport const imagealt = \"\"            // Alt text for shared images, helpful for screen readers\r\nexport const twitterhandle = \"\"       // Your company’s Twitter handle for social sharing\n```\n\n## Footer Branding\n\nThe footer settings allow you to customize the company information displayed at the bottom of the site. You can add the company name and the URL that the name will link to.\n\n```tsx showLineNumbers\nexport const companyname = \"\"         // The company name displayed in the copyright section\r\nexport const companylink = \"\"         // The URL your company name should link to\n```\n\n## General Layout\n\nThe layout settings control the appearance and functionality of various elements of the documentation site, such as branding, the right sidebar, feedback options, table of contents, and scroll-to-top functionality.\n\n```tsx showLineNumbers\nexport const branding = true          // Set to true to display our branding elements\r\nexport const rightsidebar = true      // Set to true to enable the right sidebar with feedback, table of contents and scroll-to-top\r\nexport const feedbackedit = true      // Control to enable/disable feedback on GitHub\r\nexport const tableofcontent = true    // Control to enable/disable the generated table of contents\r\nexport const totopscroll = true       // Control to enable/disable scroll-to-top button\n```\n\n## Github Control\n\nIf your MDX files are hosted on GitHub, you can configure the project to load documents directly from there. This option can be useful for syncing documentation updates directly with your repository.\n\n```tsx showLineNumbers\nexport const loadfromgithub = false   // Set to true to load your MDX documents directly from GitHub\n```\n\n## Project Structure\n",
    "_searchMeta": {
      "cleanContent": "setting up your new documentation project is straightforward most of the essential project settings can be configured within the settings folder settings this section provides the core settings for your documentation site such as defining the site s url site icon and title google tags this section allows you to integrate google tag manager into your documentation project you can add your gtm code and configure whether it s connected search engine configure essential seo settings to ensure your documentation site is optimized for search engines this includes meta descriptions keywords and social media sharing details like images and alt text footer branding the footer settings allow you to customize the company information displayed at the bottom of the site you can add the company name and the url that the name will link to general layout the layout settings control the appearance and functionality of various elements of the documentation site such as branding the right sidebar feedback options table of contents and scroll-to-top functionality github control if your mdx files are hosted on github you can configure the project to load documents directly from there this option can be useful for syncing documentation updates directly with your repository project structure",
      "headings": [
        "Settings",
        "Google Tags",
        "Search Engine",
        "Footer Branding",
        "General Layout",
        "Github Control",
        "Project Structure"
      ],
      "keywords": [
        "setup",
        "configuration",
        "layout",
        "Google",
        "SEO",
        "nextjs",
        "documents",
        "Settings",
        "Google Tags",
        "Search Engine",
        "Footer Branding",
        "General Layout",
        "Github Control",
        "Project Structure",
        "settings",
        "tsx showLineNumbers\nexport const url = \"\"                 // The URL for your documentation site\r\nexport const siteicon = \"\"            // Icon displayed next to the site name in the header\r\nexport const sitename = \"\"            // Title of your documentation site",
        "## Google Tags\n\nThis section allows you to integrate Google Tag Manager into your documentation project. You can add your GTM code and configure whether it's connected.",
        "tsx showLineNumbers\nexport const gtm = \"\"                 // Add your Google Tag Manager code here\r\nexport const gtmconnected = true      // Set to true if GTM is connected, otherwise set to false",
        "## Search Engine\n\nConfigure essential SEO settings to ensure your documentation site is optimized for search engines. This includes meta descriptions, keywords and social media sharing details like images and alt text.",
        "tsx showLineNumbers\nexport const description = \"\"         // Description of your documentation site for SEO\r\nexport const keywords = [\"\", \"\"]      // List of SEO keywords for your documentation site\r\nexport const urlimage = \"\"            // The URL of the image used when sharing on social media)\r\nexport const imagealt = \"\"            // Alt text for shared images, helpful for screen readers\r\nexport const twitterhandle = \"\"       // Your company’s Twitter handle for social sharing",
        "## Footer Branding\n\nThe footer settings allow you to customize the company information displayed at the bottom of the site. You can add the company name and the URL that the name will link to.",
        "tsx showLineNumbers\nexport const companyname = \"\"         // The company name displayed in the copyright section\r\nexport const companylink = \"\"         // The URL your company name should link to",
        "## General Layout\n\nThe layout settings control the appearance and functionality of various elements of the documentation site, such as branding, the right sidebar, feedback options, table of contents, and scroll-to-top functionality.",
        "tsx showLineNumbers\nexport const branding = true          // Set to true to display our branding elements\r\nexport const rightsidebar = true      // Set to true to enable the right sidebar with feedback, table of contents and scroll-to-top\r\nexport const feedbackedit = true      // Control to enable/disable feedback on GitHub\r\nexport const tableofcontent = true    // Control to enable/disable the generated table of contents\r\nexport const totopscroll = true       // Control to enable/disable scroll-to-top button",
        "## Github Control\n\nIf your MDX files are hosted on GitHub, you can configure the project to load documents directly from there. This option can be useful for syncing documentation updates directly with your repository.",
        "tsx showLineNumbers\nexport const loadfromgithub = false   // Set to true to load your MDX documents directly from GitHub"
      ]
    }
  },
  {
    "slug": "/best-practices/nextjs",
    "title": "Best Practices for Next.js Apps",
    "description": "Learn the best approaches for using AUTOUI in Next.js applications, including SSR considerations, App Router patterns, and performance optimization.",
    "content": "This guide covers best practices for integrating AUTOUI into Next.js applications, with special attention to Server-Side Rendering (SSR), the App Router, and Next.js-specific patterns.\n\n## SSR Considerations\n\n### Always Use Dynamic Imports\n\nModalChat must be dynamically imported with `ssr: false` to prevent hydration mismatches:\n\n```tsx\n// app/layout.tsx or app/page.tsx\n\"use client\"\n\nimport dynamic from \"next/dynamic\"\n\nconst ModalChat = dynamic(\n  () => import(\"@autoai-ui/autoui\").then(m => m.ModalChat),\n  { ssr: false }  // ← Critical: Must disable SSR\n)\n\nexport default function Layout({ children }) {\n  const config = createAutoUIConfig()\n  \n  return (\n    <html>\n      <body>\n        {children}\n        <ModalChat config={config} />\n      </body>\n    </html>\n  )\n}\n```\n\n### Client Component Boundary\n\nSince ModalChat requires client-side features, ensure your config is created in a client component:\n\n```tsx\n// ✅ Good: Config in client component\n\"use client\"\n\nimport { useMemo } from 'react'\nimport { createAutoUIConfig } from '@/lib/autoui-config'\n\nexport default function ClientLayout() {\n  const config = useMemo(() => createAutoUIConfig(), [])\n  return <ModalChat config={config} />\n}\n\n// ❌ Bad: Config in server component\n// This won't work because server components can't use browser APIs\nexport default function ServerLayout() {\n  const config = createAutoUIConfig() // Error: Can't access window/localStorage\n  return <ModalChat config={config} />\n}\n```\n\n## App Router Patterns\n\n### Global ModalChat in Root Layout\n\nAdd ModalChat to your root layout for app-wide access:\n\n```tsx\n// app/layout.tsx\nimport { AutoUIChat } from '@/components/autoui-chat'\n\nexport default function RootLayout({ children }) {\n  return (\n    <html>\n      <body>\n        {children}\n        <AutoUIChat /> {/* Global chat component */}\n      </body>\n    </html>\n  )\n}\n```\n\n### Create a Wrapper Component\n\nCreate a dedicated client component wrapper:\n\n```tsx\n// components/autoui-chat.tsx\n\"use client\"\n\nimport { ModalChat } from \"@autoai-ui/autoui\"\nimport dynamic from \"next/dynamic\"\nimport { useMemo } from \"react\"\nimport { createAutoUIConfig } from \"@/lib/autoui-config\"\n\nconst DynamicModalChat = dynamic(\n  () => Promise.resolve(ModalChat),\n  { ssr: false }\n)\n\nexport function AutoUIChat() {\n  const config = useMemo(() => createAutoUIConfig(), [])\n  \n  return (\n    <DynamicModalChat \n      config={config}\n      style={{\n        position: 'fixed',\n        bottom: '24px',\n        right: '24px',\n        zIndex: 1000,\n      }}\n    />\n  )\n}\n```\n\n## Configuration Management\n\n### Environment Variables\n\nUse Next.js environment variables (no `NEXT_PUBLIC_` prefix needed for server, required for client):\n\n```tsx\n// .env.local\nNEXT_PUBLIC_PROXY_URL=http://localhost:3001\nNEXT_PUBLIC_SHARED_SECRET=your-secret-key\n```\n\n```tsx\n// lib/autoui-config.tsx\n\"use client\"\n\nexport function createAutoUIConfig(): AutoUIConfig {\n  return {\n    appId: 'my-nextjs-app',\n    llm: {\n      proxyUrl: process.env.NEXT_PUBLIC_PROXY_URL!,\n      sharedSecret: process.env.NEXT_PUBLIC_SHARED_SECRET,\n    },\n    // ... rest of config\n  }\n}\n```\n\n### Use Next.js Router in Functions\n\nAccess Next.js router through closure:\n\n```tsx\n// lib/autoui-config.tsx\n\"use client\"\n\nimport { useRouter } from 'next/navigation'\nimport type { AppRouterInstance } from 'next/dist/shared/lib/app-router-context.shared-runtime'\n\nexport function createAutoUIConfig(router: AppRouterInstance): AutoUIConfig {\n  return {\n    // ... other config\n    functions: {\n      navigateToPage: {\n        prompt: 'Navigate to a page',\n        callFunc: ({ path }: { path: string }) => {\n          router.push(path)\n          return { success: true, path }\n        },\n        returns: 'Navigation result',\n      },\n    },\n  }\n}\n```\n\n```tsx\n// components/autoui-chat.tsx\n\"use client\"\n\nimport { useRouter } from 'next/navigation'\nimport { useMemo } from 'react'\n\nexport function AutoUIChat() {\n  const router = useRouter()\n  const config = useMemo(() => createAutoUIConfig(router), [router])\n  \n  return <ModalChat config={config} />\n}\n```\n\n## Server Actions Integration\n\n### Use Server Actions for Backend Operations\n\nLeverage Next.js Server Actions for secure backend operations:\n\n```tsx\n// app/actions.ts\n\"use server\"\n\nexport async function fetchUserData(userId: string) {\n  // Server-side operation - secure, can access database\n  const user = await db.user.findUnique({ where: { id: userId } })\n  return { user }\n}\n```\n\n```tsx\n// lib/autoui-config.tsx\n\"use client\"\n\nimport { fetchUserData } from '@/app/actions'\n\nexport function createAutoUIConfig(): AutoUIConfig {\n  return {\n    // ... other config\n    functions: {\n      getUserData: {\n        prompt: 'Get user data',\n        callFunc: async ({ userId }: { userId: string }) => {\n          return await fetchUserData(userId)\n        },\n        returns: 'User data object',\n        canShareDataWithLLM: false,\n      },\n    },\n  }\n}\n```\n\n## Performance Optimization\n\n### Code Splitting\n\nModalChat is automatically code-split when using dynamic imports:\n\n```tsx\n// This automatically code-splits ModalChat\nconst ModalChat = dynamic(\n  () => import(\"@autoai-ui/autoui\").then(m => m.ModalChat),\n  { ssr: false }\n)\n```\n\n### Memoize Config with Dependencies\n\nIf your config depends on props or state, memoize it properly:\n\n```tsx\n\"use client\"\n\nimport { useMemo } from 'react'\nimport { useRouter } from 'next/navigation'\nimport { useSession } from '@/hooks/use-session'\n\nexport function AutoUIChat() {\n  const router = useRouter()\n  const session = useSession()\n  \n  const config = useMemo(() => createAutoUIConfig(router, session), [router, session])\n  \n  return <ModalChat config={config} />\n}\n```\n\n### Optimize Bundle Size\n\nOnly import what you need:\n\n```tsx\n// ✅ Good: Import only ModalChat\nimport { ModalChat } from \"@autoai-ui/autoui\"\n\n// ❌ Avoid: Importing entire library if not needed\nimport * as AutoUI from \"@autoai-ui/autoui\"\n```\n\n## TypeScript Best Practices\n\n### Use Proper Types\n\nImport types from the library:\n\n```tsx\nimport type { AutoUIConfig, AutoUIFunction, AutoUIComponent } from \"@autoai-ui/autoui\"\n\nexport function createAutoUIConfig(): AutoUIConfig {\n  // TypeScript will validate your config\n  return {\n    appId: 'my-app',\n    // ... rest of config\n  }\n}\n```\n\n### Type Your Functions\n\nType your function parameters and return values:\n\n```tsx\nimport type { AutoUIConfig } from \"@autoai-ui/autoui\"\n\nconst config: AutoUIConfig = {\n  // ... other config\n  functions: {\n    searchProducts: {\n      prompt: 'Search products',\n      callFunc: ({ query }: { query: string }): { results: any[]; count: number } => {\n        const results = searchProducts(query)\n        return { results, count: results.length }\n      },\n      returns: 'Object with results array and count',\n    },\n  },\n}\n```\n\n## Middleware Integration\n\n### Protect Routes with Middleware\n\nIf you need authentication, use Next.js middleware:\n\n```tsx\n// middleware.ts\nimport { NextResponse } from 'next/server'\nimport type { NextRequest } from 'next/server'\n\nexport function middleware(request: NextRequest) {\n  // Your auth logic\n  const token = request.cookies.get('token')\n  \n  if (!token && request.nextUrl.pathname.startsWith('/protected')) {\n    return NextResponse.redirect(new URL('/login', request.url))\n  }\n  \n  return NextResponse.next()\n}\n```\n\nYour AutoUIConfig functions can then check authentication:\n\n```tsx\nfunctions: {\n  getProtectedData: {\n    prompt: 'Get protected data',\n    callFunc: async () => {\n      // Check auth in function\n      const response = await fetch('/api/protected', {\n        headers: { 'Authorization': `Bearer ${getToken()}` }\n      })\n      return response.json()\n    },\n  },\n}\n```\n\n## API Routes Integration\n\n### Use API Routes for Backend Logic\n\nCreate API routes for complex backend operations:\n\n```tsx\n// app/api/search/route.ts\nexport async function POST(request: Request) {\n  const { query } = await request.json()\n  \n  // Server-side search logic\n  const results = await searchDatabase(query)\n  \n  return Response.json({ results })\n}\n```\n\n```tsx\n// lib/autoui-config.tsx\nfunctions: {\n  search: {\n    prompt: 'Search the database',\n    callFunc: async ({ query }: { query: string }) => {\n      const response = await fetch('/api/search', {\n        method: 'POST',\n        headers: { 'Content-Type': 'application/json' },\n        body: JSON.stringify({ query }),\n      })\n      return response.json()\n    },\n    returns: 'Search results',\n    canShareDataWithLLM: true,\n  },\n}\n```\n\n## Error Handling\n\n### Use Next.js Error Boundaries\n\nWrap ModalChat in an error boundary:\n\n```tsx\n// app/error-boundary.tsx\n\"use client\"\n\nimport { Component, type ReactNode } from 'react'\n\ninterface Props {\n  children: ReactNode\n}\n\ninterface State {\n  hasError: boolean\n}\n\nexport class ErrorBoundary extends Component<Props, State> {\n  constructor(props: Props) {\n    super(props)\n    this.state = { hasError: false }\n  }\n\n  static getDerivedStateFromError() {\n    return { hasError: true }\n  }\n\n  render() {\n    if (this.state.hasError) {\n      return <div>Something went wrong with the chat.</div>\n    }\n\n    return this.props.children\n  }\n}\n```\n\n```tsx\n// app/layout.tsx\nimport { ErrorBoundary } from './error-boundary'\nimport { AutoUIChat } from '@/components/autoui-chat'\n\nexport default function RootLayout({ children }) {\n  return (\n    <html>\n      <body>\n        {children}\n        <ErrorBoundary>\n          <AutoUIChat />\n        </ErrorBoundary>\n      </body>\n    </html>\n  )\n}\n```\n\n## Deployment Considerations\n\n### Environment Variables in Production\n\nSet environment variables in your deployment platform:\n\n```bash\n# Vercel\nvercel env add NEXT_PUBLIC_PROXY_URL\nvercel env add NEXT_PUBLIC_SHARED_SECRET\n\n# Other platforms\n# Set NEXT_PUBLIC_* variables in your platform's environment settings\n```\n\n### Build Optimization\n\nEnsure your build includes ModalChat correctly:\n\n```json\n// next.config.js\n/** @type {import('next').NextConfig} */\nconst nextConfig = {\n  // Your config\n}\n\nmodule.exports = nextConfig\n```\n\nModalChat will be automatically code-split and won't affect your initial bundle size.\n\n## Common Patterns\n\n### Route Navigation Pattern\n\n```tsx\n\"use client\"\n\nimport { useRouter, usePathname } from 'next/navigation'\n\nexport function createAutoUIConfig(router: AppRouterInstance): AutoUIConfig {\n  return {\n    // ... other config\n    functions: {\n      navigateToPage: {\n        prompt: 'Navigate to a page',\n        callFunc: ({ path }: { path: string }) => {\n          router.push(path)\n          return { success: true, currentPath: path }\n        },\n        returns: 'Navigation result',\n      },\n      getCurrentPage: {\n        prompt: 'Get current page path',\n        callFunc: () => {\n          return { path: window.location.pathname }\n        },\n        returns: 'Current page path',\n      },\n    },\n  }\n}\n```\n\n### Data Fetching with Server Components\n\nCombine server components with client-side ModalChat:\n\n```tsx\n// app/products/page.tsx (Server Component)\nasync function ProductsPage() {\n  const products = await fetchProducts() // Server-side fetch\n  \n  return (\n    <div>\n      <ProductsList products={products} />\n      <AutoUIChat /> {/* Client component */}\n    </div>\n  )\n}\n```\n\n## Testing\n\n### Mock Next.js Router\n\nMock the Next.js router in tests:\n\n```tsx\n// __mocks__/next/navigation.ts\nexport const useRouter = () => ({\n  push: jest.fn(),\n  replace: jest.fn(),\n  refresh: jest.fn(),\n})\n\nexport const usePathname = () => '/test-path'\n```\n\n## Security Best Practices\n\n### Never Expose Server Secrets\n\nServer-side secrets should never be in `NEXT_PUBLIC_*` variables:\n\n```tsx\n// ❌ Bad: Exposing server secret\nNEXT_PUBLIC_DATABASE_PASSWORD=secret123\n\n// ✅ Good: Server-only variable\nDATABASE_PASSWORD=secret123\n\n// Use in Server Actions or API Routes (not in client components)\n```\n\n### Validate Input in API Routes\n\nAlways validate input in your API routes:\n\n```tsx\n// app/api/search/route.ts\nimport { z } from 'zod'\n\nconst searchSchema = z.object({\n  query: z.string().min(1).max(100),\n})\n\nexport async function POST(request: Request) {\n  const body = await request.json()\n  const { query } = searchSchema.parse(body) // Validates and throws if invalid\n  \n  // Safe to use query\n  return Response.json({ results: await search(query) })\n}\n```\n\n## Next Steps\n\n* Review [React best practices](/docs/best-practices/react) for general React patterns\n* Learn about [Functions](/docs/functions) for advanced function registration\n* Check [Components](/docs/components) for component patterns\n* See [Troubleshooting](/docs/troubleshooting) for common Next.js issues\n",
    "_searchMeta": {
      "cleanContent": "this guide covers best practices for integrating autoui into next js applications with special attention to server-side rendering ssr the app router and next js-specific patterns ssr considerations always use dynamic imports modalchat must be dynamically imported with ssr: false to prevent hydration mismatches: client component boundary since modalchat requires client-side features ensure your config is created in a client component: app router patterns global modalchat in root layout add modalchat to your root layout for app-wide access: create a wrapper component create a dedicated client component wrapper: configuration management environment variables use next js environment variables no nextpublic prefix needed for server required for client : use next js router in functions access next js router through closure: server actions integration use server actions for backend operations leverage next js server actions for secure backend operations: performance optimization code splitting modalchat is automatically code-split when using dynamic imports: memoize config with dependencies if your config depends on props or state memoize it properly: optimize bundle size only import what you need: typescript best practices use proper types import types from the library: type your functions type your function parameters and return values: middleware integration protect routes with middleware if you need authentication use next js middleware: your autouiconfig functions can then check authentication: api routes integration use api routes for backend logic create api routes for complex backend operations: error handling use next js error boundaries wrap modalchat in an error boundary: deployment considerations environment variables in production set environment variables in your deployment platform: build optimization ensure your build includes modalchat correctly: modalchat will be automatically code-split and won t affect your initial bundle size common patterns route navigation pattern data fetching with server components combine server components with client-side modalchat: testing mock next js router mock the next js router in tests: security best practices never expose server secrets server-side secrets should never be in nextpublic variables: validate input in api routes always validate input in your api routes: next steps review react best practices for general react patterns learn about functions for advanced function registration check components for component patterns see troubleshooting for common next js issues",
      "headings": [
        "SSR Considerations",
        "App Router Patterns",
        "Configuration Management",
        "Server Actions Integration",
        "Performance Optimization",
        "TypeScript Best Practices",
        "Middleware Integration",
        "API Routes Integration",
        "Error Handling",
        "Deployment Considerations",
        "Common Patterns",
        "Testing",
        "Security Best Practices",
        "Next Steps"
      ],
      "keywords": [
        "best practices",
        "nextjs",
        "next.js",
        "ssr",
        "app router",
        "server components",
        "SSR Considerations",
        "App Router Patterns",
        "Configuration Management",
        "Server Actions Integration",
        "Performance Optimization",
        "TypeScript Best Practices",
        "Middleware Integration",
        "API Routes Integration",
        "Error Handling",
        "Deployment Considerations",
        "Common Patterns",
        "Testing",
        "Security Best Practices",
        "Next Steps",
        "ssr: false",
        "tsx\n// app/layout.tsx or app/page.tsx\n\"use client\"\n\nimport dynamic from \"next/dynamic\"\n\nconst ModalChat = dynamic(\n  () => import(\"@autoai-ui/autoui\").then(m => m.ModalChat),\n  { ssr: false }  // ← Critical: Must disable SSR\n)\n\nexport default function Layout({ children }) {\n  const config = createAutoUIConfig()\n  \n  return (\n    <html>\n      <body>\n        {children}\n        <ModalChat config={config} />\n      </body>\n    </html>\n  )\n}",
        "### Client Component Boundary\n\nSince ModalChat requires client-side features, ensure your config is created in a client component:",
        "tsx\n// ✅ Good: Config in client component\n\"use client\"\n\nimport { useMemo } from 'react'\nimport { createAutoUIConfig } from '@/lib/autoui-config'\n\nexport default function ClientLayout() {\n  const config = useMemo(() => createAutoUIConfig(), [])\n  return <ModalChat config={config} />\n}\n\n// ❌ Bad: Config in server component\n// This won't work because server components can't use browser APIs\nexport default function ServerLayout() {\n  const config = createAutoUIConfig() // Error: Can't access window/localStorage\n  return <ModalChat config={config} />\n}",
        "## App Router Patterns\n\n### Global ModalChat in Root Layout\n\nAdd ModalChat to your root layout for app-wide access:",
        "tsx\n// app/layout.tsx\nimport { AutoUIChat } from '@/components/autoui-chat'\n\nexport default function RootLayout({ children }) {\n  return (\n    <html>\n      <body>\n        {children}\n        <AutoUIChat /> {/* Global chat component */}\n      </body>\n    </html>\n  )\n}",
        "### Create a Wrapper Component\n\nCreate a dedicated client component wrapper:",
        "tsx\n// components/autoui-chat.tsx\n\"use client\"\n\nimport { ModalChat } from \"@autoai-ui/autoui\"\nimport dynamic from \"next/dynamic\"\nimport { useMemo } from \"react\"\nimport { createAutoUIConfig } from \"@/lib/autoui-config\"\n\nconst DynamicModalChat = dynamic(\n  () => Promise.resolve(ModalChat),\n  { ssr: false }\n)\n\nexport function AutoUIChat() {\n  const config = useMemo(() => createAutoUIConfig(), [])\n  \n  return (\n    <DynamicModalChat \n      config={config}\n      style={{\n        position: 'fixed',\n        bottom: '24px',\n        right: '24px',\n        zIndex: 1000,\n      }}\n    />\n  )\n}",
        "## Configuration Management\n\n### Environment Variables\n\nUse Next.js environment variables (no",
        "prefix needed for server, required for client):",
        "tsx\n// .env.local\nNEXT_PUBLIC_PROXY_URL=http://localhost:3001\nNEXT_PUBLIC_SHARED_SECRET=your-secret-key",
        "",
        "tsx\n// lib/autoui-config.tsx\n\"use client\"\n\nexport function createAutoUIConfig(): AutoUIConfig {\n  return {\n    appId: 'my-nextjs-app',\n    llm: {\n      proxyUrl: process.env.NEXT_PUBLIC_PROXY_URL!,\n      sharedSecret: process.env.NEXT_PUBLIC_SHARED_SECRET,\n    },\n    // ... rest of config\n  }\n}",
        "### Use Next.js Router in Functions\n\nAccess Next.js router through closure:",
        "tsx\n// lib/autoui-config.tsx\n\"use client\"\n\nimport { useRouter } from 'next/navigation'\nimport type { AppRouterInstance } from 'next/dist/shared/lib/app-router-context.shared-runtime'\n\nexport function createAutoUIConfig(router: AppRouterInstance): AutoUIConfig {\n  return {\n    // ... other config\n    functions: {\n      navigateToPage: {\n        prompt: 'Navigate to a page',\n        callFunc: ({ path }: { path: string }) => {\n          router.push(path)\n          return { success: true, path }\n        },\n        returns: 'Navigation result',\n      },\n    },\n  }\n}",
        "tsx\n// components/autoui-chat.tsx\n\"use client\"\n\nimport { useRouter } from 'next/navigation'\nimport { useMemo } from 'react'\n\nexport function AutoUIChat() {\n  const router = useRouter()\n  const config = useMemo(() => createAutoUIConfig(router), [router])\n  \n  return <ModalChat config={config} />\n}",
        "## Server Actions Integration\n\n### Use Server Actions for Backend Operations\n\nLeverage Next.js Server Actions for secure backend operations:",
        "tsx\n// app/actions.ts\n\"use server\"\n\nexport async function fetchUserData(userId: string) {\n  // Server-side operation - secure, can access database\n  const user = await db.user.findUnique({ where: { id: userId } })\n  return { user }\n}",
        "tsx\n// lib/autoui-config.tsx\n\"use client\"\n\nimport { fetchUserData } from '@/app/actions'\n\nexport function createAutoUIConfig(): AutoUIConfig {\n  return {\n    // ... other config\n    functions: {\n      getUserData: {\n        prompt: 'Get user data',\n        callFunc: async ({ userId }: { userId: string }) => {\n          return await fetchUserData(userId)\n        },\n        returns: 'User data object',\n        canShareDataWithLLM: false,\n      },\n    },\n  }\n}",
        "## Performance Optimization\n\n### Code Splitting\n\nModalChat is automatically code-split when using dynamic imports:",
        "tsx\n// This automatically code-splits ModalChat\nconst ModalChat = dynamic(\n  () => import(\"@autoai-ui/autoui\").then(m => m.ModalChat),\n  { ssr: false }\n)",
        "### Memoize Config with Dependencies\n\nIf your config depends on props or state, memoize it properly:",
        "tsx\n\"use client\"\n\nimport { useMemo } from 'react'\nimport { useRouter } from 'next/navigation'\nimport { useSession } from '@/hooks/use-session'\n\nexport function AutoUIChat() {\n  const router = useRouter()\n  const session = useSession()\n  \n  const config = useMemo(() => createAutoUIConfig(router, session), [router, session])\n  \n  return <ModalChat config={config} />\n}",
        "### Optimize Bundle Size\n\nOnly import what you need:",
        "tsx\n// ✅ Good: Import only ModalChat\nimport { ModalChat } from \"@autoai-ui/autoui\"\n\n// ❌ Avoid: Importing entire library if not needed\nimport * as AutoUI from \"@autoai-ui/autoui\"",
        "## TypeScript Best Practices\n\n### Use Proper Types\n\nImport types from the library:",
        "tsx\nimport type { AutoUIConfig, AutoUIFunction, AutoUIComponent } from \"@autoai-ui/autoui\"\n\nexport function createAutoUIConfig(): AutoUIConfig {\n  // TypeScript will validate your config\n  return {\n    appId: 'my-app',\n    // ... rest of config\n  }\n}",
        "### Type Your Functions\n\nType your function parameters and return values:",
        "tsx\nimport type { AutoUIConfig } from \"@autoai-ui/autoui\"\n\nconst config: AutoUIConfig = {\n  // ... other config\n  functions: {\n    searchProducts: {\n      prompt: 'Search products',\n      callFunc: ({ query }: { query: string }): { results: any[]; count: number } => {\n        const results = searchProducts(query)\n        return { results, count: results.length }\n      },\n      returns: 'Object with results array and count',\n    },\n  },\n}",
        "## Middleware Integration\n\n### Protect Routes with Middleware\n\nIf you need authentication, use Next.js middleware:",
        "tsx\n// middleware.ts\nimport { NextResponse } from 'next/server'\nimport type { NextRequest } from 'next/server'\n\nexport function middleware(request: NextRequest) {\n  // Your auth logic\n  const token = request.cookies.get('token')\n  \n  if (!token && request.nextUrl.pathname.startsWith('/protected')) {\n    return NextResponse.redirect(new URL('/login', request.url))\n  }\n  \n  return NextResponse.next()\n}",
        "Your AutoUIConfig functions can then check authentication:",
        "tsx\nfunctions: {\n  getProtectedData: {\n    prompt: 'Get protected data',\n    callFunc: async () => {\n      // Check auth in function\n      const response = await fetch('/api/protected', {\n        headers: { 'Authorization':",
        "}\n      })\n      return response.json()\n    },\n  },\n}",
        "## API Routes Integration\n\n### Use API Routes for Backend Logic\n\nCreate API routes for complex backend operations:",
        "tsx\n// app/api/search/route.ts\nexport async function POST(request: Request) {\n  const { query } = await request.json()\n  \n  // Server-side search logic\n  const results = await searchDatabase(query)\n  \n  return Response.json({ results })\n}",
        "tsx\n// lib/autoui-config.tsx\nfunctions: {\n  search: {\n    prompt: 'Search the database',\n    callFunc: async ({ query }: { query: string }) => {\n      const response = await fetch('/api/search', {\n        method: 'POST',\n        headers: { 'Content-Type': 'application/json' },\n        body: JSON.stringify({ query }),\n      })\n      return response.json()\n    },\n    returns: 'Search results',\n    canShareDataWithLLM: true,\n  },\n}",
        "## Error Handling\n\n### Use Next.js Error Boundaries\n\nWrap ModalChat in an error boundary:",
        "tsx\n// app/error-boundary.tsx\n\"use client\"\n\nimport { Component, type ReactNode } from 'react'\n\ninterface Props {\n  children: ReactNode\n}\n\ninterface State {\n  hasError: boolean\n}\n\nexport class ErrorBoundary extends Component<Props, State> {\n  constructor(props: Props) {\n    super(props)\n    this.state = { hasError: false }\n  }\n\n  static getDerivedStateFromError() {\n    return { hasError: true }\n  }\n\n  render() {\n    if (this.state.hasError) {\n      return <div>Something went wrong with the chat.</div>\n    }\n\n    return this.props.children\n  }\n}",
        "tsx\n// app/layout.tsx\nimport { ErrorBoundary } from './error-boundary'\nimport { AutoUIChat } from '@/components/autoui-chat'\n\nexport default function RootLayout({ children }) {\n  return (\n    <html>\n      <body>\n        {children}\n        <ErrorBoundary>\n          <AutoUIChat />\n        </ErrorBoundary>\n      </body>\n    </html>\n  )\n}",
        "## Deployment Considerations\n\n### Environment Variables in Production\n\nSet environment variables in your deployment platform:",
        "bash\n# Vercel\nvercel env add NEXT_PUBLIC_PROXY_URL\nvercel env add NEXT_PUBLIC_SHARED_SECRET\n\n# Other platforms\n# Set NEXT_PUBLIC_* variables in your platform's environment settings",
        "### Build Optimization\n\nEnsure your build includes ModalChat correctly:",
        "json\n// next.config.js\n/** @type {import('next').NextConfig} */\nconst nextConfig = {\n  // Your config\n}\n\nmodule.exports = nextConfig",
        "ModalChat will be automatically code-split and won't affect your initial bundle size.\n\n## Common Patterns\n\n### Route Navigation Pattern",
        "tsx\n\"use client\"\n\nimport { useRouter, usePathname } from 'next/navigation'\n\nexport function createAutoUIConfig(router: AppRouterInstance): AutoUIConfig {\n  return {\n    // ... other config\n    functions: {\n      navigateToPage: {\n        prompt: 'Navigate to a page',\n        callFunc: ({ path }: { path: string }) => {\n          router.push(path)\n          return { success: true, currentPath: path }\n        },\n        returns: 'Navigation result',\n      },\n      getCurrentPage: {\n        prompt: 'Get current page path',\n        callFunc: () => {\n          return { path: window.location.pathname }\n        },\n        returns: 'Current page path',\n      },\n    },\n  }\n}",
        "### Data Fetching with Server Components\n\nCombine server components with client-side ModalChat:",
        "tsx\n// app/products/page.tsx (Server Component)\nasync function ProductsPage() {\n  const products = await fetchProducts() // Server-side fetch\n  \n  return (\n    <div>\n      <ProductsList products={products} />\n      <AutoUIChat /> {/* Client component */}\n    </div>\n  )\n}",
        "## Testing\n\n### Mock Next.js Router\n\nMock the Next.js router in tests:",
        "tsx\n// __mocks__/next/navigation.ts\nexport const useRouter = () => ({\n  push: jest.fn(),\n  replace: jest.fn(),\n  refresh: jest.fn(),\n})\n\nexport const usePathname = () => '/test-path'",
        "## Security Best Practices\n\n### Never Expose Server Secrets\n\nServer-side secrets should never be in",
        "variables:",
        "tsx\n// ❌ Bad: Exposing server secret\nNEXT_PUBLIC_DATABASE_PASSWORD=secret123\n\n// ✅ Good: Server-only variable\nDATABASE_PASSWORD=secret123\n\n// Use in Server Actions or API Routes (not in client components)",
        "### Validate Input in API Routes\n\nAlways validate input in your API routes:",
        "tsx\n// app/api/search/route.ts\nimport { z } from 'zod'\n\nconst searchSchema = z.object({\n  query: z.string().min(1).max(100),\n})\n\nexport async function POST(request: Request) {\n  const body = await request.json()\n  const { query } = searchSchema.parse(body) // Validates and throws if invalid\n  \n  // Safe to use query\n  return Response.json({ results: await search(query) })\n}"
      ]
    }
  },
  {
    "slug": "/best-practices/react",
    "title": "Best Practices for React Apps",
    "description": "Learn the best approaches for using AUTOUI in React applications, including configuration, performance, and common patterns.",
    "content": "This guide covers best practices for integrating AUTOUI into React applications, helping you build robust, performant, and maintainable AI-powered features.\n\n## Configuration Management\n\n### Centralize Your Config\n\nCreate a dedicated config file to keep your AutoUIConfig organized and maintainable:\n\n```tsx\n// lib/autoui-config.ts\nimport { AutoUIConfig } from \"@autoai-ui/autoui\"\n\nexport function createAutoUIConfig(): AutoUIConfig {\n  return {\n    appId: 'my-react-app',\n    llm: {\n      proxyUrl: process.env.REACT_APP_PROXY_URL || 'http://localhost:3001',\n      sharedSecret: process.env.REACT_APP_SHARED_SECRET,\n      // ... rest of config\n    },\n    // ... rest of config\n  }\n}\n```\n\n### Use Environment Variables\n\nAlways use environment variables for sensitive configuration:\n\n```tsx\n// .env\nREACT_APP_PROXY_URL=http://localhost:3001\nREACT_APP_SHARED_SECRET=your-secret-key\n```\n\n```tsx\n// In your config\nllm: {\n  proxyUrl: process.env.REACT_APP_PROXY_URL!,\n  sharedSecret: process.env.REACT_APP_SHARED_SECRET,\n}\n```\n\n## Component Integration\n\n### Use Dynamic Imports for Code Splitting\n\nIf you're using a bundler that supports code splitting, dynamically import ModalChat to reduce initial bundle size:\n\n```tsx\nimport { lazy, Suspense } from 'react'\n\nconst ModalChat = lazy(() => import('@autoai-ui/autoui').then(m => ({ default: m.ModalChat })))\n\nfunction App() {\n  const config = createAutoUIConfig()\n  \n  return (\n    <div>\n      <Suspense fallback={<div>Loading chat...</div>}>\n        <ModalChat config={config} />\n      </Suspense>\n    </div>\n  )\n}\n```\n\n### Memoize Your Config\n\nIf your config is expensive to create, memoize it to avoid recreating it on every render:\n\n```tsx\nimport { useMemo } from 'react'\n\nfunction App() {\n  const config = useMemo(() => createAutoUIConfig(), [])\n  \n  return <ModalChat config={config} />\n}\n```\n\n## Function Registration\n\n### Keep Functions Pure When Possible\n\nFunctions that don't depend on external state are easier to test and reason about:\n\n```tsx\n// ✅ Good: Pure function\nfunctions: {\n  calculateTotal: {\n    prompt: 'Calculate the total price',\n    callFunc: ({ items }: { items: Array<{ price: number }> }) => {\n      return items.reduce((sum, item) => sum + item.price, 0)\n    },\n    returns: 'number - Total price',\n    canShareDataWithLLM: true,\n  },\n}\n\n// ⚠️ Acceptable: Function with side effects (when necessary)\nfunctions: {\n  navigateToPage: {\n    prompt: 'Navigate to a page',\n    callFunc: ({ path }: { path: string }) => {\n      window.location.href = path\n      return { success: true }\n    },\n    returns: 'Object with success status',\n  },\n}\n```\n\n### Always Return Values\n\nFunctions must return a value so the LLM can analyze results:\n\n```tsx\n// ✅ Good: Returns a value\ncallFunc: ({ query }: { query: string }) => {\n  const results = searchItems(query)\n  return { results, count: results.length }\n}\n\n// ❌ Bad: Returns void\ncallFunc: ({ query }: { query: string }) => {\n  searchItems(query) // Missing return!\n}\n```\n\n### Use canShareDataWithLLM Appropriately\n\nSet `canShareDataWithLLM: true` for functions that return safe, shareable data:\n\n```tsx\nfunctions: {\n  // ✅ Safe to share - public data\n  getPublicProducts: {\n    prompt: 'Get list of products',\n    callFunc: () => fetchProducts(),\n    canShareDataWithLLM: true,\n  },\n  \n  // ❌ Don't share - sensitive data\n  getUserProfile: {\n    prompt: 'Get user profile',\n    callFunc: () => getCurrentUser(),\n    canShareDataWithLLM: false, // Contains sensitive info\n  },\n}\n```\n\n## Component Registration\n\n### Use Proper Component Types\n\nComponents should be React `ComponentType`, which can be function components or class components:\n\n```tsx\n// ✅ Good: Function component\nconst MyComponent = ({ title }: { title: string }) => (\n  <div>{title}</div>\n)\n\ncomponents: {\n  MyComponent: {\n    prompt: 'Displays a title',\n    callComponent: MyComponent,\n    props: {\n      title: 'string - The title to display',\n    },\n  },\n}\n\n// ✅ Also good: Inline function component\ncomponents: {\n  MyComponent: {\n    prompt: 'Displays a title',\n    callComponent: ({ title }: { title: string }) => <div>{title}</div>,\n  },\n}\n```\n\n### Provide Default Props\n\nDefault props help the LLM understand what values to use:\n\n```tsx\ncomponents: {\n  ProductCard: {\n    prompt: 'Displays a product card',\n    props: {\n      name: 'string - Product name',\n      price: 'number - Product price',\n    },\n    defaults: {\n      name: 'Untitled Product',\n      price: 0,\n    },\n    callComponent: ProductCard,\n  },\n}\n```\n\n### Document Props Clearly\n\nClear prop descriptions help the LLM use components correctly:\n\n```tsx\ncomponents: {\n  UserProfile: {\n    prompt: 'Displays user profile information',\n    props: {\n      userId: 'string (required) - Unique user identifier',\n      showEmail: 'boolean (optional) - Whether to show email address',\n      theme: 'string (optional) - Color theme: \"light\" | \"dark\"',\n    },\n    callComponent: UserProfile,\n  },\n}\n```\n\n## State Management\n\n### Access React Context in Functions\n\nIf you need to access React context or state in functions, pass them through closure:\n\n```tsx\nimport { useContext } from 'react'\nimport { UserContext } from './contexts/UserContext'\n\nfunction App() {\n  const user = useContext(UserContext)\n  \n  const config = useMemo(() => ({\n    // ... other config\n    functions: {\n      getUserData: {\n        prompt: 'Get current user data',\n        callFunc: () => {\n          // Access user from closure\n          return { name: user.name, email: user.email }\n        },\n        returns: 'User object',\n        canShareDataWithLLM: false,\n      },\n    },\n  }), [user])\n  \n  return <ModalChat config={config} />\n}\n```\n\n### Use Callbacks for State Updates\n\nWhen functions need to update React state, use callbacks:\n\n```tsx\nfunction App() {\n  const [cart, setCart] = useState([])\n  \n  const config = useMemo(() => ({\n    // ... other config\n    functions: {\n      addToCart: {\n        prompt: 'Add item to cart',\n        callFunc: ({ itemId }: { itemId: string }) => {\n          setCart(prev => [...prev, itemId])\n          return { success: true, cartSize: cart.length + 1 }\n        },\n        returns: 'Object with success status and cart size',\n      },\n    },\n  }), [cart])\n  \n  return <ModalChat config={config} />\n}\n```\n\n## Performance Optimization\n\n### Limit Function Complexity\n\nKeep functions focused and performant:\n\n```tsx\n// ✅ Good: Simple, focused function\nfunctions: {\n  getItemCount: {\n    prompt: 'Get number of items',\n    callFunc: () => items.length,\n    returns: 'number',\n  },\n}\n\n// ⚠️ Avoid: Complex operations that block the UI\nfunctions: {\n  processLargeDataset: {\n    prompt: 'Process large dataset',\n    callFunc: async () => {\n      // This might block the UI - consider using Web Workers\n      return processData(largeDataset)\n    },\n  },\n}\n```\n\n### Use Appropriate maxSteps\n\nSet `maxSteps` based on your app's complexity:\n\n```tsx\nruntime: {\n  maxSteps: 10,  // Simple apps\n  // maxSteps: 20,  // Medium complexity\n  // maxSteps: 30,  // Complex apps with many functions\n}\n```\n\n### Enable Debug Logs in Development\n\nUse debug logs during development, disable in production:\n\n```tsx\nruntime: {\n  enableDebugLogs: process.env.NODE_ENV === 'development',\n}\n```\n\n## Error Handling\n\n### Provide Meaningful Error Messages\n\nFunctions should return helpful error information:\n\n```tsx\nfunctions: {\n  fetchData: {\n    prompt: 'Fetch data from API',\n    callFunc: async ({ url }: { url: string }) => {\n      try {\n        const response = await fetch(url)\n        if (!response.ok) {\n          return { \n            error: true, \n            message: `HTTP ${response.status}: ${response.statusText}` \n          }\n        }\n        return { data: await response.json() }\n      } catch (error) {\n        return { \n          error: true, \n          message: error instanceof Error ? error.message : 'Unknown error' \n        }\n      }\n    },\n    returns: 'Object with data or error information',\n  },\n}\n```\n\n### Configure Error Handling\n\nSet appropriate error handling based on your needs:\n\n```tsx\nruntime: {\n  errorHandling: {\n    showToUser: true,        // Show errors in chat UI\n    retryOnFail: false,     // Don't auto-retry (user can retry manually)\n  },\n}\n```\n\n## Testing\n\n### Mock Functions for Testing\n\nCreate mock implementations for testing:\n\n```tsx\n// __mocks__/autoui-config.ts\nexport function createAutoUIConfig(): AutoUIConfig {\n  return {\n    appId: 'test-app',\n    llm: {\n      proxyUrl: 'http://localhost:3001',\n    },\n    runtime: {\n      validateLLMOutput: false, // Disable validation in tests\n      enableDebugLogs: false,\n    },\n    functions: {\n      // Mock functions for testing\n      testFunction: {\n        prompt: 'Test function',\n        callFunc: () => ({ test: true }),\n      },\n    },\n  }\n}\n```\n\n## Security Best Practices\n\n### Never Expose Secrets\n\nNever hardcode API keys or secrets in your config:\n\n```tsx\n// ❌ Bad: Hardcoded secret\nllm: {\n  proxyUrl: 'http://localhost:3001',\n  sharedSecret: 'my-secret-key', // Don't do this!\n}\n\n// ✅ Good: Use environment variables\nllm: {\n  proxyUrl: process.env.REACT_APP_PROXY_URL!,\n  sharedSecret: process.env.REACT_APP_SHARED_SECRET,\n}\n```\n\n### Validate User Input in Functions\n\nAlways validate and sanitize user input:\n\n```tsx\nfunctions: {\n  searchItems: {\n    prompt: 'Search for items',\n    callFunc: ({ query }: { query: string }) => {\n      // Validate input\n      if (!query || typeof query !== 'string') {\n        return { error: 'Invalid query' }\n      }\n      \n      // Sanitize (remove dangerous characters)\n      const sanitized = query.replace(/[<>]/g, '')\n      \n      return searchItems(sanitized)\n    },\n  },\n}\n```\n\n## Common Patterns\n\n### Navigation Pattern\n\n```tsx\nimport { useNavigate } from 'react-router-dom'\n\nfunction App() {\n  const navigate = useNavigate()\n  \n  const config = useMemo(() => ({\n    // ... other config\n    functions: {\n      navigateToPage: {\n        prompt: 'Navigate to a page',\n        callFunc: ({ path }: { path: string }) => {\n          navigate(path)\n          return { success: true, path }\n        },\n        returns: 'Navigation result',\n      },\n    },\n  }), [navigate])\n  \n  return <ModalChat config={config} />\n}\n```\n\n### Data Fetching Pattern\n\n```tsx\nfunctions: {\n  fetchUserData: {\n    prompt: 'Fetch user data from API',\n    callFunc: async ({ userId }: { userId: string }) => {\n      const response = await fetch(`/api/users/${userId}`)\n      if (!response.ok) {\n        return { error: 'Failed to fetch user' }\n      }\n      const data = await response.json()\n      return { user: data, fetchedAt: new Date().toISOString() }\n    },\n    returns: 'User data object',\n    canShareDataWithLLM: false, // User data is sensitive\n  },\n}\n```\n\n## Next Steps\n\n* Learn about [Next.js best practices](/docs/best-practices/nextjs) for server-side rendering\n* Review [Functions documentation](/docs/functions) for advanced function patterns\n* Check [Components documentation](/docs/components) for component registration details\n",
    "_searchMeta": {
      "cleanContent": "this guide covers best practices for integrating autoui into react applications helping you build robust performant and maintainable ai-powered features configuration management centralize your config create a dedicated config file to keep your autouiconfig organized and maintainable: use environment variables always use environment variables for sensitive configuration: component integration use dynamic imports for code splitting if you re using a bundler that supports code splitting dynamically import modalchat to reduce initial bundle size: memoize your config if your config is expensive to create memoize it to avoid recreating it on every render: function registration keep functions pure when possible functions that don t depend on external state are easier to test and reason about: always return values functions must return a value so the llm can analyze results: use cansharedatawithllm appropriately set cansharedatawithllm: true for functions that return safe shareable data: component registration use proper component types components should be react componenttype which can be function components or class components: provide default props default props help the llm understand what values to use: document props clearly clear prop descriptions help the llm use components correctly: state management access react context in functions if you need to access react context or state in functions pass them through closure: use callbacks for state updates when functions need to update react state use callbacks: performance optimization limit function complexity keep functions focused and performant: use appropriate maxsteps set maxsteps based on your app s complexity: enable debug logs in development use debug logs during development disable in production: error handling provide meaningful error messages functions should return helpful error information: configure error handling set appropriate error handling based on your needs: testing mock functions for testing create mock implementations for testing: security best practices never expose secrets never hardcode api keys or secrets in your config: validate user input in functions always validate and sanitize user input: common patterns navigation pattern data fetching pattern next steps learn about next js best practices for server-side rendering review functions documentation for advanced function patterns check components documentation for component registration details",
      "headings": [
        "Configuration Management",
        "Component Integration",
        "Function Registration",
        "Component Registration",
        "State Management",
        "Performance Optimization",
        "Error Handling",
        "Testing",
        "Security Best Practices",
        "Common Patterns",
        "Next Steps"
      ],
      "keywords": [
        "best practices",
        "react",
        "patterns",
        "performance",
        "configuration",
        "Configuration Management",
        "Component Integration",
        "Function Registration",
        "Component Registration",
        "State Management",
        "Performance Optimization",
        "Error Handling",
        "Testing",
        "Security Best Practices",
        "Common Patterns",
        "Next Steps",
        "tsx\n// lib/autoui-config.ts\nimport { AutoUIConfig } from \"@autoai-ui/autoui\"\n\nexport function createAutoUIConfig(): AutoUIConfig {\n  return {\n    appId: 'my-react-app',\n    llm: {\n      proxyUrl: process.env.REACT_APP_PROXY_URL || 'http://localhost:3001',\n      sharedSecret: process.env.REACT_APP_SHARED_SECRET,\n      // ... rest of config\n    },\n    // ... rest of config\n  }\n}",
        "### Use Environment Variables\n\nAlways use environment variables for sensitive configuration:",
        "tsx\n// .env\nREACT_APP_PROXY_URL=http://localhost:3001\nREACT_APP_SHARED_SECRET=your-secret-key",
        "",
        "tsx\n// In your config\nllm: {\n  proxyUrl: process.env.REACT_APP_PROXY_URL!,\n  sharedSecret: process.env.REACT_APP_SHARED_SECRET,\n}",
        "## Component Integration\n\n### Use Dynamic Imports for Code Splitting\n\nIf you're using a bundler that supports code splitting, dynamically import ModalChat to reduce initial bundle size:",
        "tsx\nimport { lazy, Suspense } from 'react'\n\nconst ModalChat = lazy(() => import('@autoai-ui/autoui').then(m => ({ default: m.ModalChat })))\n\nfunction App() {\n  const config = createAutoUIConfig()\n  \n  return (\n    <div>\n      <Suspense fallback={<div>Loading chat...</div>}>\n        <ModalChat config={config} />\n      </Suspense>\n    </div>\n  )\n}",
        "### Memoize Your Config\n\nIf your config is expensive to create, memoize it to avoid recreating it on every render:",
        "tsx\nimport { useMemo } from 'react'\n\nfunction App() {\n  const config = useMemo(() => createAutoUIConfig(), [])\n  \n  return <ModalChat config={config} />\n}",
        "## Function Registration\n\n### Keep Functions Pure When Possible\n\nFunctions that don't depend on external state are easier to test and reason about:",
        "tsx\n// ✅ Good: Pure function\nfunctions: {\n  calculateTotal: {\n    prompt: 'Calculate the total price',\n    callFunc: ({ items }: { items: Array<{ price: number }> }) => {\n      return items.reduce((sum, item) => sum + item.price, 0)\n    },\n    returns: 'number - Total price',\n    canShareDataWithLLM: true,\n  },\n}\n\n// ⚠️ Acceptable: Function with side effects (when necessary)\nfunctions: {\n  navigateToPage: {\n    prompt: 'Navigate to a page',\n    callFunc: ({ path }: { path: string }) => {\n      window.location.href = path\n      return { success: true }\n    },\n    returns: 'Object with success status',\n  },\n}",
        "### Always Return Values\n\nFunctions must return a value so the LLM can analyze results:",
        "tsx\n// ✅ Good: Returns a value\ncallFunc: ({ query }: { query: string }) => {\n  const results = searchItems(query)\n  return { results, count: results.length }\n}\n\n// ❌ Bad: Returns void\ncallFunc: ({ query }: { query: string }) => {\n  searchItems(query) // Missing return!\n}",
        "### Use canShareDataWithLLM Appropriately\n\nSet",
        "for functions that return safe, shareable data:",
        "tsx\nfunctions: {\n  // ✅ Safe to share - public data\n  getPublicProducts: {\n    prompt: 'Get list of products',\n    callFunc: () => fetchProducts(),\n    canShareDataWithLLM: true,\n  },\n  \n  // ❌ Don't share - sensitive data\n  getUserProfile: {\n    prompt: 'Get user profile',\n    callFunc: () => getCurrentUser(),\n    canShareDataWithLLM: false, // Contains sensitive info\n  },\n}",
        "## Component Registration\n\n### Use Proper Component Types\n\nComponents should be React",
        ", which can be function components or class components:",
        "tsx\n// ✅ Good: Function component\nconst MyComponent = ({ title }: { title: string }) => (\n  <div>{title}</div>\n)\n\ncomponents: {\n  MyComponent: {\n    prompt: 'Displays a title',\n    callComponent: MyComponent,\n    props: {\n      title: 'string - The title to display',\n    },\n  },\n}\n\n// ✅ Also good: Inline function component\ncomponents: {\n  MyComponent: {\n    prompt: 'Displays a title',\n    callComponent: ({ title }: { title: string }) => <div>{title}</div>,\n  },\n}",
        "### Provide Default Props\n\nDefault props help the LLM understand what values to use:",
        "tsx\ncomponents: {\n  ProductCard: {\n    prompt: 'Displays a product card',\n    props: {\n      name: 'string - Product name',\n      price: 'number - Product price',\n    },\n    defaults: {\n      name: 'Untitled Product',\n      price: 0,\n    },\n    callComponent: ProductCard,\n  },\n}",
        "### Document Props Clearly\n\nClear prop descriptions help the LLM use components correctly:",
        "tsx\ncomponents: {\n  UserProfile: {\n    prompt: 'Displays user profile information',\n    props: {\n      userId: 'string (required) - Unique user identifier',\n      showEmail: 'boolean (optional) - Whether to show email address',\n      theme: 'string (optional) - Color theme: \"light\" | \"dark\"',\n    },\n    callComponent: UserProfile,\n  },\n}",
        "## State Management\n\n### Access React Context in Functions\n\nIf you need to access React context or state in functions, pass them through closure:",
        "tsx\nimport { useContext } from 'react'\nimport { UserContext } from './contexts/UserContext'\n\nfunction App() {\n  const user = useContext(UserContext)\n  \n  const config = useMemo(() => ({\n    // ... other config\n    functions: {\n      getUserData: {\n        prompt: 'Get current user data',\n        callFunc: () => {\n          // Access user from closure\n          return { name: user.name, email: user.email }\n        },\n        returns: 'User object',\n        canShareDataWithLLM: false,\n      },\n    },\n  }), [user])\n  \n  return <ModalChat config={config} />\n}",
        "### Use Callbacks for State Updates\n\nWhen functions need to update React state, use callbacks:",
        "tsx\nfunction App() {\n  const [cart, setCart] = useState([])\n  \n  const config = useMemo(() => ({\n    // ... other config\n    functions: {\n      addToCart: {\n        prompt: 'Add item to cart',\n        callFunc: ({ itemId }: { itemId: string }) => {\n          setCart(prev => [...prev, itemId])\n          return { success: true, cartSize: cart.length + 1 }\n        },\n        returns: 'Object with success status and cart size',\n      },\n    },\n  }), [cart])\n  \n  return <ModalChat config={config} />\n}",
        "## Performance Optimization\n\n### Limit Function Complexity\n\nKeep functions focused and performant:",
        "tsx\n// ✅ Good: Simple, focused function\nfunctions: {\n  getItemCount: {\n    prompt: 'Get number of items',\n    callFunc: () => items.length,\n    returns: 'number',\n  },\n}\n\n// ⚠️ Avoid: Complex operations that block the UI\nfunctions: {\n  processLargeDataset: {\n    prompt: 'Process large dataset',\n    callFunc: async () => {\n      // This might block the UI - consider using Web Workers\n      return processData(largeDataset)\n    },\n  },\n}",
        "### Use Appropriate maxSteps\n\nSet",
        "based on your app's complexity:",
        "tsx\nruntime: {\n  maxSteps: 10,  // Simple apps\n  // maxSteps: 20,  // Medium complexity\n  // maxSteps: 30,  // Complex apps with many functions\n}",
        "### Enable Debug Logs in Development\n\nUse debug logs during development, disable in production:",
        "tsx\nruntime: {\n  enableDebugLogs: process.env.NODE_ENV === 'development',\n}",
        "## Error Handling\n\n### Provide Meaningful Error Messages\n\nFunctions should return helpful error information:",
        "tsx\nfunctions: {\n  fetchData: {\n    prompt: 'Fetch data from API',\n    callFunc: async ({ url }: { url: string }) => {\n      try {\n        const response = await fetch(url)\n        if (!response.ok) {\n          return { \n            error: true, \n            message:",
        "}\n        }\n        return { data: await response.json() }\n      } catch (error) {\n        return { \n          error: true, \n          message: error instanceof Error ? error.message : 'Unknown error' \n        }\n      }\n    },\n    returns: 'Object with data or error information',\n  },\n}",
        "### Configure Error Handling\n\nSet appropriate error handling based on your needs:",
        "tsx\nruntime: {\n  errorHandling: {\n    showToUser: true,        // Show errors in chat UI\n    retryOnFail: false,     // Don't auto-retry (user can retry manually)\n  },\n}",
        "## Testing\n\n### Mock Functions for Testing\n\nCreate mock implementations for testing:",
        "tsx\n// __mocks__/autoui-config.ts\nexport function createAutoUIConfig(): AutoUIConfig {\n  return {\n    appId: 'test-app',\n    llm: {\n      proxyUrl: 'http://localhost:3001',\n    },\n    runtime: {\n      validateLLMOutput: false, // Disable validation in tests\n      enableDebugLogs: false,\n    },\n    functions: {\n      // Mock functions for testing\n      testFunction: {\n        prompt: 'Test function',\n        callFunc: () => ({ test: true }),\n      },\n    },\n  }\n}",
        "## Security Best Practices\n\n### Never Expose Secrets\n\nNever hardcode API keys or secrets in your config:",
        "tsx\n// ❌ Bad: Hardcoded secret\nllm: {\n  proxyUrl: 'http://localhost:3001',\n  sharedSecret: 'my-secret-key', // Don't do this!\n}\n\n// ✅ Good: Use environment variables\nllm: {\n  proxyUrl: process.env.REACT_APP_PROXY_URL!,\n  sharedSecret: process.env.REACT_APP_SHARED_SECRET,\n}",
        "### Validate User Input in Functions\n\nAlways validate and sanitize user input:",
        "tsx\nfunctions: {\n  searchItems: {\n    prompt: 'Search for items',\n    callFunc: ({ query }: { query: string }) => {\n      // Validate input\n      if (!query || typeof query !== 'string') {\n        return { error: 'Invalid query' }\n      }\n      \n      // Sanitize (remove dangerous characters)\n      const sanitized = query.replace(/[<>]/g, '')\n      \n      return searchItems(sanitized)\n    },\n  },\n}",
        "## Common Patterns\n\n### Navigation Pattern",
        "tsx\nimport { useNavigate } from 'react-router-dom'\n\nfunction App() {\n  const navigate = useNavigate()\n  \n  const config = useMemo(() => ({\n    // ... other config\n    functions: {\n      navigateToPage: {\n        prompt: 'Navigate to a page',\n        callFunc: ({ path }: { path: string }) => {\n          navigate(path)\n          return { success: true, path }\n        },\n        returns: 'Navigation result',\n      },\n    },\n  }), [navigate])\n  \n  return <ModalChat config={config} />\n}",
        "### Data Fetching Pattern",
        "tsx\nfunctions: {\n  fetchUserData: {\n    prompt: 'Fetch user data from API',\n    callFunc: async ({ userId }: { userId: string }) => {\n      const response = await fetch(",
        ")\n      if (!response.ok) {\n        return { error: 'Failed to fetch user' }\n      }\n      const data = await response.json()\n      return { user: data, fetchedAt: new Date().toISOString() }\n    },\n    returns: 'User data object',\n    canShareDataWithLLM: false, // User data is sensitive\n  },\n}"
      ]
    }
  },
  {
    "slug": "/components",
    "title": "Components Registry",
    "description": "Register React components for generative UI. Enable the AI assistant to render custom components dynamically.",
    "content": "The Components Registry allows you to register React components that the AI assistant can render dynamically. This enables **generative UI**—the assistant can compose new interfaces on the fly based on user requests.\n\n## How Components Work\n\nWhen you register a component, the LLM can:\n\n1. Decide to render it based on user requests\n2. Pass props based on the component's `defaults` and `prompt`\n3. Compose multiple components together\n4. Update component props through conversation\n\n## Component Structure\n\nEach component in your config has this structure:\n\n```tsx\ncomponents: {\r\n  ComponentName: {\r\n    prompt: 'Description of what this component displays...',\r\n    defaults: {\r\n      propName: 'default value',\r\n    },\r\n    callComponent: (props) => <YourComponent {...props} />,\r\n    category: 'optional-category',\r\n  },\r\n}\n```\n\n## Key Concepts\n\n### Prompt\n\nThe `prompt` field describes what the component does and when to render it:\n\n```tsx\nprompt: 'Shows cart items with quantities and total; triggers checkout when requested.'\n```\n\nThe LLM uses this to decide:\n\n* When to render the component\n* What props to pass\n* How to describe it to the user\n\n### Defaults\n\nThe `defaults` object provides example/default props that help the LLM understand the component's structure:\n\n```tsx\ndefaults: {\r\n  items: [\r\n    { id: '1', name: 'Beige Coat', price: 89.99, quantity: 2 },\r\n    { id: '2', name: 'Denim Jacket', price: 69.99, quantity: 1 },\r\n  ],\r\n}\n```\n\n**Purpose:**\n\n* Shows the LLM what props the component expects\n* Provides example data structure\n* Helps the LLM generate appropriate props\n\n### callComponent\n\nA function that returns your React component with the provided props:\n\n```tsx\ncallComponent: (props) => <CartSummary {...props} />\n```\n\n**Important:**\n\n* Must return a valid React element\n* Props come from the LLM (based on defaults and prompt)\n* You can transform or validate props before passing them\n\n### Category\n\nAn optional string that groups related components:\n\n```tsx\ncategory: 'checkout' // Groups with other checkout-related components\n```\n\nUseful for organization and helping the LLM understand component relationships.\n\n## Example: E-Commerce Components\n\nHere's a complete example from an e-commerce app:\n\n```tsx\ncomponents: {\r\n  CartSummary: {\r\n    prompt: 'Shows cart items with quantities and total; triggers checkout when requested.',\r\n    defaults: {\r\n      items: [\r\n        { id: '1', name: 'Beige Coat', price: 89.99, quantity: 2 },\r\n        { id: '2', name: 'Denim Jacket', price: 69.99, quantity: 1 },\r\n      ],\r\n    },\r\n    callComponent: (props) => <CartSummary {...props} />,\r\n    category: 'checkout',\r\n  },\r\n\r\n  ProductCard: {\r\n    prompt: 'Displays a single product with image, name, price, and add-to-cart button.',\r\n    defaults: {\r\n      id: '1',\r\n      name: 'Product Name',\r\n      price: 29.99,\r\n      image: 'https://example.com/product.jpg',\r\n      description: 'Product description',\r\n    },\r\n    callComponent: (props) => <ProductCard {...props} />,\r\n    category: 'products',\r\n  },\r\n\r\n  ProductGrid: {\r\n    prompt: 'Displays a grid of product cards. Use when showing multiple products.',\r\n    defaults: {\r\n      products: [\r\n        { id: '1', name: 'Product 1', price: 29.99 },\r\n        { id: '2', name: 'Product 2', price: 39.99 },\r\n      ],\r\n    },\r\n    callComponent: (props) => <ProductGrid {...props} />,\r\n    category: 'products',\r\n  },\r\n}\n```\n\n## Component Patterns\n\n### Display Components\n\nComponents that show data:\n\n```tsx\nUserProfile: {\r\n  prompt: 'Displays user profile information: name, avatar, email, and stats.',\r\n  defaults: {\r\n    name: 'John Doe',\r\n    email: 'john@example.com',\r\n    avatar: 'https://example.com/avatar.jpg',\r\n    stats: { posts: 42, followers: 123 },\r\n  },\r\n  callComponent: (props) => <UserProfile {...props} />,\r\n}\n```\n\n### Form Components\n\nComponents that collect input:\n\n```tsx\nTaskForm: {\r\n  prompt: 'Displays a form for creating or editing a task. Includes fields for title, description, status, priority, and due date.',\r\n  defaults: {\r\n    title: '',\r\n    description: '',\r\n    status: 'todo',\r\n    priority: 'medium',\r\n    dueDate: null,\r\n  },\r\n  callComponent: (props) => <TaskForm {...props} />,\r\n  category: 'forms',\r\n}\n```\n\n### Interactive Components\n\nComponents that trigger actions:\n\n```tsx\nActionButton: {\r\n  prompt: 'A button that triggers an action when clicked. Use for primary actions like \"Save\", \"Submit\", \"Delete\".',\r\n  defaults: {\r\n    label: 'Click me',\r\n    variant: 'primary',\r\n    onClick: () => {},\r\n  },\r\n  callComponent: (props) => <ActionButton {...props} />,\r\n  category: 'actions',\r\n}\n```\n\n### Layout Components\n\nComponents that organize other components:\n\n```tsx\nDashboard: {\r\n  prompt: 'A dashboard layout with sidebar, header, and main content area. Can contain widgets and charts.',\r\n  defaults: {\r\n    sidebarItems: [],\r\n    headerTitle: 'Dashboard',\r\n    widgets: [],\r\n  },\r\n  callComponent: (props) => <Dashboard {...props} />,\r\n  category: 'layout',\r\n}\n```\n\n## Props Handling\n\n### Validating Props\n\nValidate and transform props before passing them to your component:\n\n```tsx\ncallComponent: (props) => {\r\n  // Validate required props\r\n  if (!props.items || !Array.isArray(props.items)) {\r\n    return <div>Error: Invalid items prop</div>\r\n  }\r\n\r\n  // Transform props\r\n  const transformedProps = {\r\n    ...props,\r\n    items: props.items.map(item => ({\r\n      ...item,\r\n      total: item.price * item.quantity,\r\n    })),\r\n  }\r\n\r\n  return <CartSummary {...transformedProps} />\r\n}\n```\n\n### Default Props\n\nProvide fallback values:\n\n```tsx\ncallComponent: (props) => {\r\n  const safeProps = {\r\n    title: props.title || 'Untitled',\r\n    items: props.items || [],\r\n    onAction: props.onAction || (() => {}),\r\n  }\r\n  return <MyComponent {...safeProps} />\r\n}\n```\n\n## Component Categories\n\nUse categories to organize related components:\n\n```tsx\n// Navigation\r\ncomponents: {\r\n  NavBar: { category: 'navigation', /* ... */ },\r\n  Sidebar: { category: 'navigation', /* ... */ },\r\n}\r\n\r\n// Data Display\r\ncomponents: {\r\n  Table: { category: 'data', /* ... */ },\r\n  Chart: { category: 'data', /* ... */ },\r\n  List: { category: 'data', /* ... */ },\r\n}\r\n\r\n// Forms\r\ncomponents: {\r\n  TextInput: { category: 'forms', /* ... */ },\r\n  Select: { category: 'forms', /* ... */ },\r\n  Checkbox: { category: 'forms', /* ... */ },\r\n}\n```\n\n## Best Practices\n\n<Note title=\"Realistic Defaults\" type=\"warning\">\n  Provide realistic default props that match your actual data structure. This helps the LLM generate appropriate props.\n</Note>\n\n<Note title=\"Error Boundaries\" type=\"warning\">\n  Consider wrapping components in error boundaries to handle rendering errors gracefully:\n\n  ```tsx\n  callComponent: (props) => (\r\n    <ErrorBoundary>\r\n      <YourComponent {...props} />\r\n    </ErrorBoundary>\r\n  )\n  ```\n</Note>\n\n## Combining Components and Functions\n\nComponents can work together with functions:\n\n```tsx\n// Function to fetch data\r\nfunctions: {\r\n  getProducts: {\r\n    prompt: 'Fetch list of products.',\r\n    callFunc: () => products,\r\n    returns: 'Product[]',\r\n  },\r\n}\r\n\r\n// Component to display data\r\ncomponents: {\r\n  ProductGrid: {\r\n    prompt: 'Display a grid of products.',\r\n    defaults: {\r\n      products: [],\r\n    },\r\n    callComponent: (props) => <ProductGrid {...props} />,\r\n  },\r\n}\n```\n\nThe LLM can:\n\n1. Call `getProducts()` to fetch data\n2. Render `ProductGrid` with the fetched products\n3. Compose multiple components together\n\n## Limitations\n\n* Components are rendered in the chat context (inside ModalChat)\n* Complex layouts may be limited by chat UI constraints\n* Props are generated by the LLM, so validation is important\n* Performance: Many components may impact chat performance\n\n## Next Steps\n\n* Learn about functions: [Functions](/docs/functions)\n* Configure runtime: [Runtime & Debugging](/docs/runtime)\n* Customize styling: [ModalChat Styling](/docs/styling)\n",
    "_searchMeta": {
      "cleanContent": "the components registry allows you to register react components that the ai assistant can render dynamically this enables generative ui the assistant can compose new interfaces on the fly based on user requests how components work when you register a component the llm can: decide to render it based on user requests pass props based on the component s defaults and prompt compose multiple components together update component props through conversation component structure each component in your config has this structure: key concepts prompt the prompt field describes what the component does and when to render it: the llm uses this to decide: when to render the component what props to pass how to describe it to the user defaults the defaults object provides example default props that help the llm understand the component s structure: purpose: shows the llm what props the component expects provides example data structure helps the llm generate appropriate props callcomponent a function that returns your react component with the provided props: important: must return a valid react element props come from the llm based on defaults and prompt you can transform or validate props before passing them category an optional string that groups related components: useful for organization and helping the llm understand component relationships example: e-commerce components here s a complete example from an e-commerce app: component patterns display components components that show data: form components components that collect input: interactive components components that trigger actions: layout components components that organize other components: props handling validating props validate and transform props before passing them to your component: default props provide fallback values: component categories use categories to organize related components: best practices provide realistic default props that match your actual data structure this helps the llm generate appropriate props consider wrapping components in error boundaries to handle rendering errors gracefully: combining components and functions components can work together with functions: the llm can: call getproducts to fetch data render productgrid with the fetched products compose multiple components together limitations components are rendered in the chat context inside modalchat complex layouts may be limited by chat ui constraints props are generated by the llm so validation is important performance: many components may impact chat performance next steps learn about functions: functions configure runtime: runtime debugging customize styling: modalchat styling",
      "headings": [
        "How Components Work",
        "Component Structure",
        "Key Concepts",
        "Example: E-Commerce Components",
        "Component Patterns",
        "Props Handling",
        "Component Categories",
        "Best Practices",
        "Combining Components and Functions",
        "Limitations",
        "Next Steps"
      ],
      "keywords": [
        "components",
        "generative ui",
        "react components",
        "registry",
        "callComponent",
        "How Components Work",
        "Component Structure",
        "Key Concepts",
        "Example: E-Commerce Components",
        "Component Patterns",
        "Props Handling",
        "Component Categories",
        "Best Practices",
        "Combining Components and Functions",
        "Limitations",
        "Next Steps",
        "generative UI",
        "Purpose:",
        "Important:",
        "defaults",
        "prompt",
        "tsx\ncomponents: {\r\n  ComponentName: {\r\n    prompt: 'Description of what this component displays...',\r\n    defaults: {\r\n      propName: 'default value',\r\n    },\r\n    callComponent: (props) => <YourComponent {...props} />,\r\n    category: 'optional-category',\r\n  },\r\n}",
        "## Key Concepts\n\n### Prompt\n\nThe",
        "field describes what the component does and when to render it:",
        "tsx\nprompt: 'Shows cart items with quantities and total; triggers checkout when requested.'",
        "The LLM uses this to decide:\n\n* When to render the component\n* What props to pass\n* How to describe it to the user\n\n### Defaults\n\nThe",
        "object provides example/default props that help the LLM understand the component's structure:",
        "tsx\ndefaults: {\r\n  items: [\r\n    { id: '1', name: 'Beige Coat', price: 89.99, quantity: 2 },\r\n    { id: '2', name: 'Denim Jacket', price: 69.99, quantity: 1 },\r\n  ],\r\n}",
        "**Purpose:**\n\n* Shows the LLM what props the component expects\n* Provides example data structure\n* Helps the LLM generate appropriate props\n\n### callComponent\n\nA function that returns your React component with the provided props:",
        "tsx\ncallComponent: (props) => <CartSummary {...props} />",
        "**Important:**\n\n* Must return a valid React element\n* Props come from the LLM (based on defaults and prompt)\n* You can transform or validate props before passing them\n\n### Category\n\nAn optional string that groups related components:",
        "tsx\ncategory: 'checkout' // Groups with other checkout-related components",
        "Useful for organization and helping the LLM understand component relationships.\n\n## Example: E-Commerce Components\n\nHere's a complete example from an e-commerce app:",
        "tsx\ncomponents: {\r\n  CartSummary: {\r\n    prompt: 'Shows cart items with quantities and total; triggers checkout when requested.',\r\n    defaults: {\r\n      items: [\r\n        { id: '1', name: 'Beige Coat', price: 89.99, quantity: 2 },\r\n        { id: '2', name: 'Denim Jacket', price: 69.99, quantity: 1 },\r\n      ],\r\n    },\r\n    callComponent: (props) => <CartSummary {...props} />,\r\n    category: 'checkout',\r\n  },\r\n\r\n  ProductCard: {\r\n    prompt: 'Displays a single product with image, name, price, and add-to-cart button.',\r\n    defaults: {\r\n      id: '1',\r\n      name: 'Product Name',\r\n      price: 29.99,\r\n      image: 'https://example.com/product.jpg',\r\n      description: 'Product description',\r\n    },\r\n    callComponent: (props) => <ProductCard {...props} />,\r\n    category: 'products',\r\n  },\r\n\r\n  ProductGrid: {\r\n    prompt: 'Displays a grid of product cards. Use when showing multiple products.',\r\n    defaults: {\r\n      products: [\r\n        { id: '1', name: 'Product 1', price: 29.99 },\r\n        { id: '2', name: 'Product 2', price: 39.99 },\r\n      ],\r\n    },\r\n    callComponent: (props) => <ProductGrid {...props} />,\r\n    category: 'products',\r\n  },\r\n}",
        "## Component Patterns\n\n### Display Components\n\nComponents that show data:",
        "tsx\nUserProfile: {\r\n  prompt: 'Displays user profile information: name, avatar, email, and stats.',\r\n  defaults: {\r\n    name: 'John Doe',\r\n    email: 'john@example.com',\r\n    avatar: 'https://example.com/avatar.jpg',\r\n    stats: { posts: 42, followers: 123 },\r\n  },\r\n  callComponent: (props) => <UserProfile {...props} />,\r\n}",
        "### Form Components\n\nComponents that collect input:",
        "tsx\nTaskForm: {\r\n  prompt: 'Displays a form for creating or editing a task. Includes fields for title, description, status, priority, and due date.',\r\n  defaults: {\r\n    title: '',\r\n    description: '',\r\n    status: 'todo',\r\n    priority: 'medium',\r\n    dueDate: null,\r\n  },\r\n  callComponent: (props) => <TaskForm {...props} />,\r\n  category: 'forms',\r\n}",
        "### Interactive Components\n\nComponents that trigger actions:",
        "tsx\nActionButton: {\r\n  prompt: 'A button that triggers an action when clicked. Use for primary actions like \"Save\", \"Submit\", \"Delete\".',\r\n  defaults: {\r\n    label: 'Click me',\r\n    variant: 'primary',\r\n    onClick: () => {},\r\n  },\r\n  callComponent: (props) => <ActionButton {...props} />,\r\n  category: 'actions',\r\n}",
        "### Layout Components\n\nComponents that organize other components:",
        "tsx\nDashboard: {\r\n  prompt: 'A dashboard layout with sidebar, header, and main content area. Can contain widgets and charts.',\r\n  defaults: {\r\n    sidebarItems: [],\r\n    headerTitle: 'Dashboard',\r\n    widgets: [],\r\n  },\r\n  callComponent: (props) => <Dashboard {...props} />,\r\n  category: 'layout',\r\n}",
        "## Props Handling\n\n### Validating Props\n\nValidate and transform props before passing them to your component:",
        "tsx\ncallComponent: (props) => {\r\n  // Validate required props\r\n  if (!props.items || !Array.isArray(props.items)) {\r\n    return <div>Error: Invalid items prop</div>\r\n  }\r\n\r\n  // Transform props\r\n  const transformedProps = {\r\n    ...props,\r\n    items: props.items.map(item => ({\r\n      ...item,\r\n      total: item.price * item.quantity,\r\n    })),\r\n  }\r\n\r\n  return <CartSummary {...transformedProps} />\r\n}",
        "### Default Props\n\nProvide fallback values:",
        "tsx\ncallComponent: (props) => {\r\n  const safeProps = {\r\n    title: props.title || 'Untitled',\r\n    items: props.items || [],\r\n    onAction: props.onAction || (() => {}),\r\n  }\r\n  return <MyComponent {...safeProps} />\r\n}",
        "## Component Categories\n\nUse categories to organize related components:",
        "tsx\n// Navigation\r\ncomponents: {\r\n  NavBar: { category: 'navigation', /* ... */ },\r\n  Sidebar: { category: 'navigation', /* ... */ },\r\n}\r\n\r\n// Data Display\r\ncomponents: {\r\n  Table: { category: 'data', /* ... */ },\r\n  Chart: { category: 'data', /* ... */ },\r\n  List: { category: 'data', /* ... */ },\r\n}\r\n\r\n// Forms\r\ncomponents: {\r\n  TextInput: { category: 'forms', /* ... */ },\r\n  Select: { category: 'forms', /* ... */ },\r\n  Checkbox: { category: 'forms', /* ... */ },\r\n}",
        "## Best Practices\n\n<Note title=\"Realistic Defaults\" type=\"warning\">\n  Provide realistic default props that match your actual data structure. This helps the LLM generate appropriate props.\n</Note>\n\n<Note title=\"Error Boundaries\" type=\"warning\">\n  Consider wrapping components in error boundaries to handle rendering errors gracefully:",
        "tsx\n  callComponent: (props) => (\r\n    <ErrorBoundary>\r\n      <YourComponent {...props} />\r\n    </ErrorBoundary>\r\n  )",
        "</Note>\n\n## Combining Components and Functions\n\nComponents can work together with functions:",
        "tsx\n// Function to fetch data\r\nfunctions: {\r\n  getProducts: {\r\n    prompt: 'Fetch list of products.',\r\n    callFunc: () => products,\r\n    returns: 'Product[]',\r\n  },\r\n}\r\n\r\n// Component to display data\r\ncomponents: {\r\n  ProductGrid: {\r\n    prompt: 'Display a grid of products.',\r\n    defaults: {\r\n      products: [],\r\n    },\r\n    callComponent: (props) => <ProductGrid {...props} />,\r\n  },\r\n}",
        "The LLM can:\n\n1. Call",
        "to fetch data\n2. Render"
      ]
    }
  },
  {
    "slug": "/config",
    "title": "Config Explanation",
    "description": "Understand AutoUIConfig structure and how to configure AUTOUI for your app.",
    "content": "Your `AutoUIConfig` is the contract between your app and the AI assistant. It tells the AI what your app can do.\n\n## Basic Structure\n\n```tsx\nimport { AutoUIConfig } from \"@autoai-ui/autoui\"\n\nconst config: AutoUIConfig = {\n  appId: 'my-app',           // Required: Unique app ID\n  llm: { /* ... */ },        // Required: LLM configuration\n  runtime: { /* ... */ },    // Required: Runtime settings\n  functions: { /* ... */ },  // Optional: Functions AI can call\n  components: { /* ... */ }, // Optional: Components AI can render\n  metadata: { /* ... */ },   // Optional: App metadata\n}\n```\n\n## Required Fields\n\n### `appId`\n\nUnique identifier for your app:\n\n```tsx\nappId: 'my-app'\n```\n\n### `llm`\n\nLLM provider configuration:\n\n```tsx\nllm: {\n  proxyUrl: 'http://localhost:3001',  // Required: Your proxy URL\n  sharedSecret: 'your-secret',        // Optional: Proxy auth\n  appDescriptionPrompt: 'My app does...', // Optional: Describe your app\n}\n```\n\n### `runtime`\n\nRuntime execution settings:\n\n```tsx\nruntime: {\n  validateLLMOutput: true,           // Validate AI responses\n  storeChatToLocalStorage: true,      // Save chat history\n  localStorageKey: 'autoui_chat_history', // Storage key\n  enableDebugLogs: true,              // Enable debug logging\n  maxSteps: 20,                        // Max AI actions per turn\n  errorHandling: {\n    showToUser: true,                  // Show errors in chat\n    retryOnFail: false,                // Auto-retry on failure\n  },\n  runtimeSchemaPath: '.autoui-runtime-schema.json', // Optional: Custom schema path\n}\n```\n\n**Note:** The `runtimeSchemaPath` option allows you to specify a custom path to the runtime schema file generated by the Vite plugin. This schema file is automatically generated during development builds and should be committed to your repository.\n\n## Optional Fields\n\n### `metadata`\n\nApp information (helps AI understand your app):\n\n```tsx\nmetadata: {\n  appName: 'My App',\n  description: 'What my app does...',\n  tags: ['ecommerce', 'react'],\n}\n```\n\n### `functions`\n\nFunctions the AI can call:\n\n```tsx\nfunctions: {\n  searchProducts: {\n    prompt: 'Search for products',\n    callFunc: ({ query }) => searchProducts(query),\n    returns: 'Array of products',\n  },\n}\n```\n\n### `components`\n\nComponents the AI can render:\n\n```tsx\ncomponents: {\n  ProductCard: {\n    prompt: 'Display a product card',\n    callComponent: ProductCard,\n    props: {\n      name: 'string - Product name',\n      price: 'number - Product price',\n    },\n  },\n}\n```\n\n## React vs Next.js\n\n### React Config\n\n```tsx\n// lib/autoui-config.ts\nimport { AutoUIConfig } from \"@autoai-ui/autoui\"\n\nexport function createAutoUIConfig(): AutoUIConfig {\n  return {\n    appId: 'my-react-app',\n    llm: {\n      proxyUrl: process.env.REACT_APP_PROXY_URL!,\n      sharedSecret: process.env.REACT_APP_SHARED_SECRET,\n    },\n    runtime: {\n      validateLLMOutput: true,\n      storeChatToLocalStorage: true,\n    },\n  }\n}\n```\n\n### Next.js Config\n\n```tsx\n// lib/autoui-config.tsx\n\"use client\"\n\nimport { AutoUIConfig } from \"@autoai-ui/autoui\"\n\nexport function createAutoUIConfig(): AutoUIConfig {\n  return {\n    appId: 'my-nextjs-app',\n    llm: {\n      proxyUrl: process.env.NEXT_PUBLIC_PROXY_URL!,\n      sharedSecret: process.env.NEXT_PUBLIC_SHARED_SECRET,\n    },\n    runtime: {\n      validateLLMOutput: true,\n      storeChatToLocalStorage: true,\n    },\n  }\n}\n```\n\n## Common Patterns\n\n### With Navigation\n\n```tsx\nimport { useRouter } from 'next/navigation'\n\nexport function createAutoUIConfig(router) {\n  return {\n    // ... other config\n    functions: {\n      navigate: {\n        prompt: 'Navigate to a page',\n        callFunc: ({ path }) => {\n          router.push(path)\n          return { success: true }\n        },\n      },\n    },\n  }\n}\n```\n\n### With State\n\n```tsx\nimport { useState } from 'react'\n\nfunction App() {\n  const [cart, setCart] = useState([])\n  \n  const config = {\n    // ... other config\n    functions: {\n      addToCart: {\n        prompt: 'Add item to cart',\n        callFunc: ({ item }) => {\n          setCart([...cart, item])\n          return { success: true }\n        },\n      },\n    },\n  }\n  \n  return <ModalChat config={config} />\n}\n```\n\n## Best Practices\n\n1. **Use environment variables** for sensitive data\n2. **Keep functions simple** and focused\n3. **Document props clearly** for components\n4. **Set appropriate maxSteps** based on complexity\n5. **Enable validation** in production\n\n## Schema Generation\n\nIf you're using the Vite plugin, AutoUI automatically generates a runtime schema file (`.autoui-runtime-schema.json`) from your TypeScript types. This schema helps the LLM understand your app's structure. See the [Runtime Schema documentation](/docs/runtime#runtime-schema-file) for more details.\n\n## Learn More\n\n* [Complete Developer Guide](/docs/developer-guide) - Comprehensive setup and configuration guide\n* [Functions Guide](/docs/functions) - Register functions\n* [Components Guide](/docs/components) - Register components\n* [Runtime Schema](/docs/runtime#runtime-schema-file) - Schema generation and registration\n* [Full Reference](/docs/reference/autouiconfig) - Complete API reference\n",
    "_searchMeta": {
      "cleanContent": "your autouiconfig is the contract between your app and the ai assistant it tells the ai what your app can do basic structure required fields appid unique identifier for your app: llm llm provider configuration: runtime runtime execution settings: note: the runtimeschemapath option allows you to specify a custom path to the runtime schema file generated by the vite plugin this schema file is automatically generated during development builds and should be committed to your repository optional fields metadata app information helps ai understand your app : functions functions the ai can call: components components the ai can render: react vs next js react config next js config common patterns with navigation with state best practices use environment variables for sensitive data keep functions simple and focused document props clearly for components set appropriate maxsteps based on complexity enable validation in production schema generation if you re using the vite plugin autoui automatically generates a runtime schema file autoui-runtime-schema json from your typescript types this schema helps the llm understand your app s structure see the runtime schema documentation for more details learn more complete developer guide - comprehensive setup and configuration guide functions guide - register functions components guide - register components runtime schema - schema generation and registration full reference - complete api reference",
      "headings": [
        "Basic Structure",
        "Required Fields",
        "Optional Fields",
        "React vs Next.js",
        "Common Patterns",
        "Best Practices",
        "Schema Generation",
        "Learn More"
      ],
      "keywords": [
        "config",
        "configuration",
        "autouiconfig",
        "setup",
        "Basic Structure",
        "Required Fields",
        "Optional Fields",
        "React vs Next.js",
        "Common Patterns",
        "Best Practices",
        "Schema Generation",
        "Learn More",
        "Note:",
        "Use environment variables",
        "Keep functions simple",
        "Document props clearly",
        "Set appropriate maxSteps",
        "Enable validation",
        "AutoUIConfig",
        "tsx\nimport { AutoUIConfig } from \"@autoai-ui/autoui\"\n\nconst config: AutoUIConfig = {\n  appId: 'my-app',           // Required: Unique app ID\n  llm: { /* ... */ },        // Required: LLM configuration\n  runtime: { /* ... */ },    // Required: Runtime settings\n  functions: { /* ... */ },  // Optional: Functions AI can call\n  components: { /* ... */ }, // Optional: Components AI can render\n  metadata: { /* ... */ },   // Optional: App metadata\n}",
        "## Required Fields\n\n###",
        "Unique identifier for your app:",
        "tsx\nappId: 'my-app'",
        "###",
        "LLM provider configuration:",
        "tsx\nllm: {\n  proxyUrl: 'http://localhost:3001',  // Required: Your proxy URL\n  sharedSecret: 'your-secret',        // Optional: Proxy auth\n  appDescriptionPrompt: 'My app does...', // Optional: Describe your app\n}",
        "Runtime execution settings:",
        "tsx\nruntime: {\n  validateLLMOutput: true,           // Validate AI responses\n  storeChatToLocalStorage: true,      // Save chat history\n  localStorageKey: 'autoui_chat_history', // Storage key\n  enableDebugLogs: true,              // Enable debug logging\n  maxSteps: 20,                        // Max AI actions per turn\n  errorHandling: {\n    showToUser: true,                  // Show errors in chat\n    retryOnFail: false,                // Auto-retry on failure\n  },\n  runtimeSchemaPath: '.autoui-runtime-schema.json', // Optional: Custom schema path\n}",
        "**Note:** The",
        "option allows you to specify a custom path to the runtime schema file generated by the Vite plugin. This schema file is automatically generated during development builds and should be committed to your repository.\n\n## Optional Fields\n\n###",
        "App information (helps AI understand your app):",
        "tsx\nmetadata: {\n  appName: 'My App',\n  description: 'What my app does...',\n  tags: ['ecommerce', 'react'],\n}",
        "Functions the AI can call:",
        "tsx\nfunctions: {\n  searchProducts: {\n    prompt: 'Search for products',\n    callFunc: ({ query }) => searchProducts(query),\n    returns: 'Array of products',\n  },\n}",
        "Components the AI can render:",
        "tsx\ncomponents: {\n  ProductCard: {\n    prompt: 'Display a product card',\n    callComponent: ProductCard,\n    props: {\n      name: 'string - Product name',\n      price: 'number - Product price',\n    },\n  },\n}",
        "## React vs Next.js\n\n### React Config",
        "tsx\n// lib/autoui-config.ts\nimport { AutoUIConfig } from \"@autoai-ui/autoui\"\n\nexport function createAutoUIConfig(): AutoUIConfig {\n  return {\n    appId: 'my-react-app',\n    llm: {\n      proxyUrl: process.env.REACT_APP_PROXY_URL!,\n      sharedSecret: process.env.REACT_APP_SHARED_SECRET,\n    },\n    runtime: {\n      validateLLMOutput: true,\n      storeChatToLocalStorage: true,\n    },\n  }\n}",
        "### Next.js Config",
        "tsx\n// lib/autoui-config.tsx\n\"use client\"\n\nimport { AutoUIConfig } from \"@autoai-ui/autoui\"\n\nexport function createAutoUIConfig(): AutoUIConfig {\n  return {\n    appId: 'my-nextjs-app',\n    llm: {\n      proxyUrl: process.env.NEXT_PUBLIC_PROXY_URL!,\n      sharedSecret: process.env.NEXT_PUBLIC_SHARED_SECRET,\n    },\n    runtime: {\n      validateLLMOutput: true,\n      storeChatToLocalStorage: true,\n    },\n  }\n}",
        "## Common Patterns\n\n### With Navigation",
        "tsx\nimport { useRouter } from 'next/navigation'\n\nexport function createAutoUIConfig(router) {\n  return {\n    // ... other config\n    functions: {\n      navigate: {\n        prompt: 'Navigate to a page',\n        callFunc: ({ path }) => {\n          router.push(path)\n          return { success: true }\n        },\n      },\n    },\n  }\n}",
        "### With State",
        "tsx\nimport { useState } from 'react'\n\nfunction App() {\n  const [cart, setCart] = useState([])\n  \n  const config = {\n    // ... other config\n    functions: {\n      addToCart: {\n        prompt: 'Add item to cart',\n        callFunc: ({ item }) => {\n          setCart([...cart, item])\n          return { success: true }\n        },\n      },\n    },\n  }\n  \n  return <ModalChat config={config} />\n}",
        "## Best Practices\n\n1. **Use environment variables** for sensitive data\n2. **Keep functions simple** and focused\n3. **Document props clearly** for components\n4. **Set appropriate maxSteps** based on complexity\n5. **Enable validation** in production\n\n## Schema Generation\n\nIf you're using the Vite plugin, AutoUI automatically generates a runtime schema file ("
      ]
    }
  },
  {
    "slug": "/developer-guide",
    "title": "Complete Developer Guide",
    "description": "Comprehensive guide to AutoUI library - installation, configuration, schema generation, and advanced features.",
    "content": "# AutoUI Library - Complete Developer Guide\n\n## Overview\n\nAutoUI is a powerful React library that enables developers to build AI-powered chat interfaces that can dynamically interact with your application's components and functions. The library uses a Large Language Model (LLM) proxy to understand user intent and automatically render React components or call functions based on natural language conversations.\n\n## Core Concepts\n\nAutoUI works by:\n\n1. **Type Extraction**: Automatically extracting TypeScript type information from your components and functions during build time\n\n2. **Schema Generation**: Creating a runtime schema file (`.autoui-runtime-schema.json`) that describes your app's capabilities\n\n3. **LLM Integration**: Sending user messages to an LLM proxy that understands your app structure and generates appropriate actions\n\n4. **Dynamic Rendering**: Executing function calls and rendering React components based on LLM instructions\n\n***\n\n## Installation\n\nInstall AutoUI from npm:\n\n```bash\nnpm install @autoai-ui/autoui\n```\n\n**Peer Dependencies:**\n\n* React >= 19.0.0 \\< 20.0.0\n* React DOM >= 19.0.0 \\< 20.0.0\n\n***\n\n## Getting Started Workflow\n\n### Step 1: Create Your App Registration\n\nBefore integrating AutoUI into your application, you need to register your app with the AutoUI service. You have **two options**:\n\n**Option A: Use AutoUI's Deployed Service (Recommended)**\n\nVisit the [AutoUI Service Portal](https://autoui-chi.vercel.app/) to generate:\n\n* **`appId`**: A unique identifier for your application (e.g., `app_1768313360453_dbptv83`)\n* **`shared_secret`**: A secret key used for authenticating requests to the LLM proxy\n\nThis service handles the proxy for you—no backend installation or setup required. Simply use the generated credentials in your config.\n\n**Option B: Self-Hosted Backend**\n\nIf you prefer to run your own backend, see the [Backend Proxy Installation & Configuration](/docs/backend-proxy) guide. You'll need to clone the backend repository and set up your own proxy server.\n\nFor this guide, we'll assume you're using Option A (the deployed service).\n\n### Step 2: Configure Environment Variables\n\nAdd the `AUTOUI_APP_ID` to your project's environment file (`.env`, `.env.local`, or `.env.development`):\n\n```bash\nAUTOUI_APP_ID=app_1768313360453_dbptv83\n```\n\n**Optional Environment Variables:**\n\n* `AUTOUI_VERSION`: Version string for your app (defaults to `1.0.0`)\n* `VITE_BASE_URL`: Your LLM proxy URL (if using Vite). Use `https://autoui-chi.vercel.app` for the deployed service, or your own proxy URL\n* `VITE_AUTOUI_SHARED_SECRET`: Your shared secret for proxy authentication (from the service portal or your own backend)\n\nThe plugin automatically reads these environment variables during development builds.\n\n### Step 3: Install and Configure the Vite Plugin\n\nAdd the AutoUI type schema plugin to your `vite.config.ts`:\n\n```typescript\nimport { defineConfig } from 'vite';\r\nimport react from '@vitejs/plugin-react';\r\nimport { autouiTypeSchemaPlugin } from '@autoai-ui/autoui/plugin';\r\n\r\nexport default defineConfig({\r\n  plugins: [\r\n    react(),\r\n    autouiTypeSchemaPlugin({\r\n      // Optional: Override appId from env\r\n      // appId: 'your-app-id',\r\n      // Optional: Override version from env\r\n      // version: '1.0.0',\r\n      // Optional: Custom schema file path\r\n      // runtimeSchemaFile: '.autoui-runtime-schema.json',\r\n    }),\r\n  ],\r\n});\n```\n\n**Plugin Behavior:**\n\n* **Development Mode**: The plugin scans your TypeScript source files, extracts type information from registered components and functions, and generates the `.autoui-runtime-schema.json` file\n* **Production Mode**: The plugin skips schema generation and uses the existing schema file (which should be committed to your repository)\n\n### Step 4: Create Your AutoUI Configuration\n\nCreate a configuration file (e.g., `autoui.config.ts`) that defines your app's capabilities:\n\n```typescript\nimport type { AutoUIConfig } from '@autoai-ui/autoui';\r\nimport { ModalChat } from '@autoai-ui/autoui';\r\n\r\nconst proxyUrl = import.meta.env.VITE_BASE_URL;\r\nconst sharedSecret = import.meta.env.VITE_AUTOUI_SHARED_SECRET;\r\n\r\nexport const autouiConfig: AutoUIConfig = {\r\n  // Required: Your app ID (from registration)\r\n  appId: import.meta.env.AUTOUI_APP_ID || 'your-app-id',\r\n\r\n  // LLM Configuration\r\n  llm: {\r\n    proxyUrl: proxyUrl, // Your LLM proxy endpoint\r\n    sharedSecret: sharedSecret, // Optional: For proxy authentication\r\n    temperature: 0.7, // Optional: LLM temperature hint\r\n    maxTokens: 2048, // Optional: Max tokens hint\r\n    appDescriptionPrompt: 'A brief description of what your app does',\r\n    requestHeaders: { // Optional: Custom headers\r\n      'HTTP-Referer': 'https://yourdomain.com',\r\n      'X-Title': 'Your App Name',\r\n    },\r\n  },\r\n\r\n  // Runtime Configuration\r\n  runtime: {\r\n    validateLLMOutput: true, // Validate LLM responses against schema\r\n    storeChatToLocalStorage: true, // Persist chat history\r\n    localStorageKey: 'autoui_chat_history', // Storage key\r\n    enableDebugLogs: true, // Enable debug logging\r\n    maxSteps: 20, // Maximum instruction steps per conversation\r\n    errorHandling: {\r\n      showToUser: true, // Display errors to users\r\n      retryOnFail: true, // Retry failed operations\r\n    },\r\n    runtimeSchemaPath: '.autoui-runtime-schema.json', // Optional: Custom schema path\r\n  },\r\n\r\n  // Function Definitions\r\n  functions: {\r\n    fetchProducts: {\r\n      prompt: 'Fetch a list of products filtered by category or search query',\r\n      params: {\r\n        category: 'string (optional) — product category',\r\n        q: 'string (optional) — search query',\r\n      },\r\n      returns: 'Product[] — array of products',\r\n      callFunc: async ({ category, q }) => {\r\n        // Your implementation\r\n        return products;\r\n      },\r\n      tags: ['products', 'search'],\r\n    },\r\n    // ... more functions\r\n  },\r\n\r\n  // Component Definitions\r\n  components: {\r\n    ProductGallery: {\r\n      prompt: 'Display a gallery of products in a grid layout',\r\n      props: {\r\n        products: 'Product[] — array of products to display',\r\n      },\r\n      callComponent: ProductGallery, // Your React component\r\n      defaults: {\r\n        products: [],\r\n      },\r\n      category: 'display',\r\n      tags: ['products', 'gallery'],\r\n    },\r\n    // ... more components\r\n  },\r\n\r\n  // Optional Metadata\r\n  metadata: {\r\n    appName: 'Your App Name',\r\n    appVersion: '1.0.0',\r\n    description: 'Description of your application',\r\n    tags: ['ecommerce', 'react', 'autoui'],\r\n  },\r\n};\n```\n\n### Step 5: Integrate ChatModal Component\n\nImport and use the `ModalChat` component in your application:\n\n```typescript\nimport { ModalChat } from '@autoai-ui/autoui';\r\nimport { autouiConfig } from './autoui.config';\r\n\r\nfunction App() {\r\n  return (\r\n    <div>\r\n      <h1>My Application</h1>\r\n      {/* Your app content */}\r\n      \r\n      {/* AutoUI Chat Modal */}\r\n      <ModalChat config={autouiConfig} />\r\n    </div>\r\n  );\r\n}\n```\n\nThe `ModalChat` component provides:\n\n* A floating chat button that opens/closes the chat interface\n* A chat interface that communicates with your LLM proxy\n* Automatic rendering of components and execution of functions based on user conversations\n* Chat history persistence (if enabled)\n\n***\n\n## Configuration Reference\n\n### AutoUIConfig Interface\n\nThe main configuration object that defines your app's capabilities:\n\n```typescript\ninterface AutoUIConfig {\r\n  appId: string; // Required: Your app ID from registration\r\n  llm: LLMConfig; // Required: LLM proxy configuration\r\n  runtime: RuntimeConfig; // Required: Runtime behavior settings\r\n  functions: Record<string, AutoUIFunction>; // Required: Function definitions\r\n  components: Record<string, AutoUIComponent>; // Required: Component definitions\r\n  metadata?: AutoUIMetadata; // Optional: App metadata\r\n}\n```\n\n### LLMConfig\n\nConfiguration for the LLM proxy connection:\n\n```typescript\ninterface LLMConfig {\r\n  proxyUrl: string; // Required: Backend proxy URL\r\n  sharedSecret?: string; // Optional: Shared secret for proxy auth\r\n  temperature?: number; // Optional: Sampling temperature (hint only)\r\n  maxTokens?: number; // Optional: Max tokens (hint only)\r\n  appDescriptionPrompt?: string; // Optional: App description context\r\n  requestHeaders?: Record<string, string>; // Optional: Headers forwarded to proxy\r\n}\n```\n\n**Purpose**: Configures how AutoUI communicates with your LLM proxy service. The `proxyUrl` is the endpoint where user messages are sent, and the proxy returns instructions for rendering components or calling functions.\n\n### RuntimeConfig\n\nConfiguration for runtime behavior:\n\n```typescript\ninterface RuntimeConfig {\r\n  validateLLMOutput?: boolean; // Validate LLM JSON output against schema\r\n  storeChatToLocalStorage?: boolean; // Persist chat history\r\n  localStorageKey?: string; // Key for localStorage\r\n  enableDebugLogs?: boolean; // Enable internal debug logging\r\n  maxSteps?: number; // Maximum instruction steps allowed\r\n  errorHandling?: {\r\n    showToUser?: boolean; // Display errors to users\r\n    retryOnFail?: boolean; // Retry failed operations\r\n  };\r\n  runtimeSchemaPath?: string; // Path to runtime schema file (default: '.autoui-runtime-schema.json')\r\n}\n```\n\n**Purpose**: Controls how AutoUI behaves at runtime, including error handling, persistence, validation, and debugging options.\n\n### AutoUIFunction\n\nDefines a callable function that the LLM can invoke:\n\n```typescript\ninterface AutoUIFunction {\r\n  prompt: string; // Required: Description for LLM to decide when/how to call\r\n  params?: Record<string, string>; // Optional: Parameter descriptions\r\n  returns?: string; // Optional: Return type description\r\n  callFunc: Function; // Required: The actual function implementation\r\n  exampleUsage?: string; // Optional: Example usage for LLM context\r\n  tags?: string[]; // Optional: Tags for organization\r\n  canShareDataWithLLM?: boolean; // Optional: Whether function data can be shared with LLM\r\n}\n```\n\n**Purpose**: Registers functions that the LLM can call based on user requests. The `prompt` field is crucial—it tells the LLM when and how to use this function. The `callFunc` is the actual implementation that gets executed.\n\n**Example:**\n\n```typescript\nfunctions: {\r\n  getUserProfile: {\r\n    prompt: 'Get the current user profile information',\r\n    params: {\r\n      userId: 'string — user ID to fetch',\r\n    },\r\n    returns: 'UserProfile — user profile object',\r\n    callFunc: async ({ userId }) => {\r\n      const response = await fetch(`/api/users/${userId}`);\r\n      return response.json();\r\n    },\r\n  },\r\n}\n```\n\n### AutoUIComponent\n\nDefines a React component that the LLM can render:\n\n```typescript\ninterface AutoUIComponent {\r\n  prompt: string; // Required: Description for LLM to decide when/how to render\r\n  props?: Record<string, string>; // Optional: Prop descriptions\r\n  callComponent: ComponentType<any>; // Required: The React component\r\n  defaults?: Record<string, any>; // Optional: Default prop values\r\n  callbacks?: Record<string, AutoUICallback | Function>; // Optional: Callback handlers\r\n  exampleUsage?: string; // Optional: Example JSX usage\r\n  category?: string; // Optional: Component category\r\n  tags?: string[]; // Optional: Tags for organization\r\n}\n```\n\n**Purpose**: Registers React components that the LLM can render based on user requests. The `prompt` describes what the component does, and `props` describes the component's interface.\n\n**Example:**\n\n```typescript\ncomponents: {\r\n  ProductCard: {\r\n    prompt: 'Display a single product card with image, name, price, and add to cart button',\r\n    props: {\r\n      product: 'Product — product object with id, name, price, image',\r\n      onAddToCart: 'function(productId: string) — callback when add to cart is clicked',\r\n    },\r\n    callComponent: ProductCard,\r\n    defaults: {\r\n      product: { id: '', name: '', price: 0, image: '' },\r\n    },\r\n    category: 'display',\r\n  },\r\n}\n```\n\n### AutoUICallback\n\nDefines callbacks that components can use:\n\n```typescript\ninterface AutoUICallback {\r\n  description: string; // Required: What this callback does\r\n  whenToUse?: string; // Optional: When to use this callback\r\n  example?: string; // Optional: Example usage\r\n  callFunc: Function; // Required: The callback implementation\r\n}\n```\n\n**Purpose**: Defines callback functions that components can use for user interactions (e.g., button clicks, form submissions).\n\n### AutoUIMetadata\n\nOptional metadata about your application:\n\n```typescript\ninterface AutoUIMetadata {\r\n  appName: string; // Required: Application name\r\n  appVersion?: string; // Optional: Version string\r\n  author?: string; // Optional: Author name\r\n  createdAt?: string; // Optional: Creation date\r\n  description?: string; // Optional: App description\r\n  tags?: string[]; // Optional: Tags for categorization\r\n}\n```\n\n**Purpose**: Provides metadata about your application for documentation and organization purposes.\n\n***\n\n## The Runtime Schema File (.autoui-runtime-schema.json)\n\n### What is it?\n\nThe `.autoui-runtime-schema.json` file is automatically generated by the AutoUI Vite plugin during development builds. It contains a complete type-safe schema of your application's components and functions, extracted from your TypeScript source code.\n\n### Purpose\n\n1. **Type Safety**: Provides a complete type definition of all registered components and functions\n2. **LLM Context**: The schema is sent to the LLM proxy to help it understand your app's structure\n3. **Validation**: Used at runtime to validate LLM responses before executing functions or rendering components\n4. **Documentation**: Serves as a machine-readable documentation of your app's capabilities\n\n### Structure\n\nThe schema file has the following structure:\n\n```json\n{\r\n  \"appId\": \"app_1768313360453_dbptv83\",\r\n  \"version\": \"1.0.0\",\r\n  \"generatedAt\": \"2026-01-13T15:59:08.897Z\",\r\n  \"types\": {\r\n    \"Product\": {\r\n      \"type\": \"object\",\r\n      \"properties\": {\r\n        \"id\": { \"type\": \"string\", \"required\": true },\r\n        \"name\": { \"type\": \"string\", \"required\": true },\r\n        \"price\": { \"type\": \"number\", \"required\": true }\r\n      },\r\n      \"refs\": [\"string\", \"number\"]\r\n    },\r\n    \"Product[]\": {\r\n      \"type\": \"array\",\r\n      \"items\": { \"type\": \"Product\" },\r\n      \"refs\": [\"Product\"]\r\n    }\r\n  },\r\n  \"components\": [\r\n    {\r\n      \"name\": \"ProductGallery\",\r\n      \"props\": {\r\n        \"products\": {\r\n          \"type\": \"Product[]\",\r\n          \"required\": true\r\n        }\r\n      }\r\n    }\r\n  ],\r\n  \"functions\": [\r\n    {\r\n      \"name\": \"fetchProducts\",\r\n      \"params\": {\r\n        \"params\": {\r\n          \"type\": \"FetchProductsParams\",\r\n          \"required\": false\r\n        }\r\n      },\r\n      \"returns\": {\r\n        \"type\": \"Promise<Product[]>\"\r\n      }\r\n    }\r\n  ]\r\n}\n```\n\n### How it's Generated\n\n1. **Type Extraction**: The plugin uses `ts-morph` to parse your TypeScript project\n2. **Registration Discovery**: It finds components and functions registered using `autouiRegisterComponentPropsSchema` and `autouiRegisterFunctionParamsSchema`\n3. **Type Resolution**: It extracts and resolves all TypeScript types, including:\n   * Primitives (string, number, boolean)\n   * Objects and interfaces\n   * Arrays\n   * Unions and intersections\n   * Generic types\n4. **Schema Creation**: It generates a JSON schema with complete type information\n\n### When is it Generated?\n\n* **Development**: Generated automatically on each build start\n* **Production**: Not generated; uses the committed schema file\n\n### Best Practices\n\n1. **Commit the Schema**: Always commit `.autoui-runtime-schema.json` to your repository\n2. **Version Control**: The schema should match your code—if you change component props or function signatures, regenerate the schema\n3. **CI/CD**: In production builds, the plugin skips generation and uses the committed schema\n4. **Review Changes**: Review schema changes in pull requests to ensure they match your code changes\n\n***\n\n## Component Registration\n\nTo register components and functions for schema extraction, use the registration utilities:\n\n```typescript\nimport { autouiRegisterComponentPropsSchema, autouiRegisterFunctionParamsSchema } from '@autoai-ui/autoui';\r\n\r\n// Register a component's props type\r\nautouiRegisterComponentPropsSchema('ProductCard', ProductCardProps);\r\n\r\n// Register a function's parameter and return types\r\nautouiRegisterFunctionParamsSchema('fetchProducts', FetchProductsParams, Product[]);\n```\n\nThese registrations help the plugin extract accurate type information during build time.\n\n***\n\n## Usage Examples\n\n### Basic Chat Integration\n\n```typescript\nimport { ModalChat } from '@autoai-ui/autoui';\r\nimport { autouiConfig } from './autoui.config';\r\n\r\nfunction App() {\r\n  return (\r\n    <>\r\n      <YourAppContent />\r\n      <ModalChat config={autouiConfig} />\r\n    </>\r\n  );\r\n}\n```\n\n### Custom Portal Container\n\n```typescript\n<ModalChat \r\n  config={autouiConfig} \r\n  portalContainer={document.getElementById('chat-container')} \r\n/>\n```\n\n### Inline Chat (Non-Modal)\n\n```typescript\nimport { Chat } from '@autoai-ui/autoui';\r\n\r\nfunction App() {\r\n  return (\r\n    <div>\r\n      <Chat config={autouiConfig} title=\"AI Assistant\" />\r\n    </div>\r\n  );\r\n}\n```\n\n***\n\n## Advanced Features\n\n### Custom Error Handling\n\n```typescript\nruntime: {\r\n  errorHandling: {\r\n    showToUser: true,\r\n    retryOnFail: true,\r\n  },\r\n}\n```\n\n### Chat History Persistence\n\n```typescript\nruntime: {\r\n  storeChatToLocalStorage: true,\r\n  localStorageKey: 'my_app_chat_history',\r\n}\n```\n\n### Debug Logging\n\n```typescript\nruntime: {\r\n  enableDebugLogs: true, // Logs LLM requests/responses and execution steps\r\n}\n```\n\n### Custom Request Headers\n\n```typescript\nllm: {\r\n  requestHeaders: {\r\n    'X-Custom-Header': 'value',\r\n    'Authorization': 'Bearer token',\r\n  },\r\n}\n```\n\n***\n\n## Troubleshooting\n\n### Schema Not Generated\n\n* Ensure the plugin is added to `vite.config.ts`\n* Check that you have a `tsconfig.json` or `tsconfig.app.json` file\n* Verify components/functions are registered using the registration utilities\n* Check console for plugin error messages\n\n### LLM Not Understanding Your App\n\n* Improve `prompt` descriptions in your config\n* Add more detailed `params` and `props` descriptions\n* Ensure `appDescriptionPrompt` accurately describes your app\n* Review the generated schema file to ensure types are correct\n\n### Functions Not Being Called\n\n* Verify function `prompt` clearly describes when to use it\n* Check function registration in the schema file\n* Enable debug logs to see LLM decision-making\n* Ensure function signatures match the schema\n\n### Components Not Rendering\n\n* Verify component `prompt` clearly describes when to render it\n* Check component registration in the schema file\n* Ensure component props match the schema\n* Review LLM response in debug logs\n\n***\n\n## Type Safety\n\nAutoUI provides full TypeScript support:\n\n```typescript\nimport type { AutoUIConfig, AutoUIFunction, AutoUIComponent } from '@autoai-ui/autoui';\n```\n\nAll configuration interfaces are fully typed, providing autocomplete and type checking in your IDE.\n\n***\n\n## Summary\n\nAutoUI enables you to build AI-powered chat interfaces by:\n\n1. **Installing** the library from npm\n2. **Registering** your app to get `appId` and `shared_secret`\n3. **Configuring** environment variables (`AUTOUI_APP_ID`)\n4. **Adding** the Vite plugin to extract types and generate schema\n5. **Creating** a config that defines your functions and components\n6. **Integrating** the `ModalChat` component into your app\n\nThe plugin automatically generates `.autoui-runtime-schema.json` which describes your app's capabilities, enabling the LLM to understand and interact with your application intelligently.\n",
    "_searchMeta": {
      "cleanContent": "autoui library - complete developer guide overview autoui is a powerful react library that enables developers to build ai-powered chat interfaces that can dynamically interact with your application s components and functions the library uses a large language model llm proxy to understand user intent and automatically render react components or call functions based on natural language conversations core concepts autoui works by: type extraction: automatically extracting typescript type information from your components and functions during build time schema generation: creating a runtime schema file autoui-runtime-schema json that describes your app s capabilities llm integration: sending user messages to an llm proxy that understands your app structure and generates appropriate actions dynamic rendering: executing function calls and rendering react components based on llm instructions installation install autoui from npm: peer dependencies: react 19 0 0 20 0 0 react dom 19 0 0 20 0 0 getting started workflow step 1: create your app registration before integrating autoui into your application you need to register your app with the autoui service you have two options: option a: use autoui s deployed service recommended visit the autoui service portal to generate: appid: a unique identifier for your application e g app1768313360453dbptv83 shared_secret: a secret key used for authenticating requests to the llm proxy this service handles the proxy for you no backend installation or setup required simply use the generated credentials in your config option b: self-hosted backend if you prefer to run your own backend see the backend proxy installation configuration guide you ll need to clone the backend repository and set up your own proxy server for this guide we ll assume you re using option a the deployed service step 2: configure environment variables add the autouiappid to your project s environment file env env local or env development : optional environment variables: autoui_version: version string for your app defaults to 1 0 0 vitebaseurl: your llm proxy url if using vite use https: autoui-chi vercel app for the deployed service or your own proxy url viteautouishared_secret: your shared secret for proxy authentication from the service portal or your own backend the plugin automatically reads these environment variables during development builds step 3: install and configure the vite plugin add the autoui type schema plugin to your vite config ts: plugin behavior: development mode: the plugin scans your typescript source files extracts type information from registered components and functions and generates the autoui-runtime-schema json file production mode: the plugin skips schema generation and uses the existing schema file which should be committed to your repository step 4: create your autoui configuration create a configuration file e g autoui config ts that defines your app s capabilities: step 5: integrate chatmodal component import and use the modalchat component in your application: the modalchat component provides: a floating chat button that opens closes the chat interface a chat interface that communicates with your llm proxy automatic rendering of components and execution of functions based on user conversations chat history persistence if enabled configuration reference autouiconfig interface the main configuration object that defines your app s capabilities: llmconfig configuration for the llm proxy connection: purpose: configures how autoui communicates with your llm proxy service the proxyurl is the endpoint where user messages are sent and the proxy returns instructions for rendering components or calling functions runtimeconfig configuration for runtime behavior: purpose: controls how autoui behaves at runtime including error handling persistence validation and debugging options autouifunction defines a callable function that the llm can invoke: purpose: registers functions that the llm can call based on user requests the prompt field is crucial it tells the llm when and how to use this function the callfunc is the actual implementation that gets executed example: autouicomponent defines a react component that the llm can render: purpose: registers react components that the llm can render based on user requests the prompt describes what the component does and props describes the component s interface example: autouicallback defines callbacks that components can use: purpose: defines callback functions that components can use for user interactions e g button clicks form submissions autouimetadata optional metadata about your application: purpose: provides metadata about your application for documentation and organization purposes the runtime schema file autoui-runtime-schema json what is it the autoui-runtime-schema json file is automatically generated by the autoui vite plugin during development builds it contains a complete type-safe schema of your application s components and functions extracted from your typescript source code purpose type safety: provides a complete type definition of all registered components and functions llm context: the schema is sent to the llm proxy to help it understand your app s structure validation: used at runtime to validate llm responses before executing functions or rendering components documentation: serves as a machine-readable documentation of your app s capabilities structure the schema file has the following structure: how it s generated type extraction: the plugin uses ts-morph to parse your typescript project registration discovery: it finds components and functions registered using autouiregistercomponentpropsschema and autouiregisterfunctionparamsschema type resolution: it extracts and resolves all typescript types including: primitives string number boolean objects and interfaces arrays unions and intersections generic types schema creation: it generates a json schema with complete type information when is it generated development: generated automatically on each build start production: not generated uses the committed schema file best practices commit the schema: always commit autoui-runtime-schema json to your repository version control: the schema should match your code if you change component props or function signatures regenerate the schema ci cd: in production builds the plugin skips generation and uses the committed schema review changes: review schema changes in pull requests to ensure they match your code changes component registration to register components and functions for schema extraction use the registration utilities: these registrations help the plugin extract accurate type information during build time usage examples basic chat integration custom portal container inline chat non-modal advanced features custom error handling chat history persistence debug logging custom request headers troubleshooting schema not generated ensure the plugin is added to vite config ts check that you have a tsconfig json or tsconfig app json file verify components functions are registered using the registration utilities check console for plugin error messages llm not understanding your app improve prompt descriptions in your config add more detailed params and props descriptions ensure appdescriptionprompt accurately describes your app review the generated schema file to ensure types are correct functions not being called verify function prompt clearly describes when to use it check function registration in the schema file enable debug logs to see llm decision-making ensure function signatures match the schema components not rendering verify component prompt clearly describes when to render it check component registration in the schema file ensure component props match the schema review llm response in debug logs type safety autoui provides full typescript support: all configuration interfaces are fully typed providing autocomplete and type checking in your ide summary autoui enables you to build ai-powered chat interfaces by: installing the library from npm registering your app to get appid and shared_secret configuring environment variables autouiappid adding the vite plugin to extract types and generate schema creating a config that defines your functions and components integrating the modalchat component into your app the plugin automatically generates autoui-runtime-schema json which describes your app s capabilities enabling the llm to understand and interact with your application intelligently",
      "headings": [
        "Overview",
        "Core Concepts",
        "Installation",
        "Getting Started Workflow",
        "Configuration Reference",
        "The Runtime Schema File (.autoui-runtime-schema.json)",
        "Component Registration",
        "Usage Examples",
        "Advanced Features",
        "Troubleshooting",
        "Type Safety",
        "Summary"
      ],
      "keywords": [
        "developer guide",
        "complete guide",
        "autoui",
        "installation",
        "configuration",
        "vite plugin",
        "schema",
        "Overview",
        "Core Concepts",
        "Installation",
        "Getting Started Workflow",
        "Configuration Reference",
        "The Runtime Schema File (.autoui-runtime-schema.json)",
        "Component Registration",
        "Usage Examples",
        "Advanced Features",
        "Troubleshooting",
        "Type Safety",
        "Summary",
        "Type Extraction",
        "Schema Generation",
        "LLM Integration",
        "Dynamic Rendering",
        "## Installation\n\nInstall AutoUI from npm:\n\n```bash\nnpm install @autoai-ui/autoui\n```",
        "## Getting Started Workflow\n\n### Step 1: Create Your App Registration\n\nBefore integrating AutoUI into your application, you need to register your app with the AutoUI service. You have",
        ":",
        "`appId`",
        "`shared_secret`",
        "Option B: Self-Hosted Backend",
        "Optional Environment Variables:",
        "Plugin Behavior:",
        "Development Mode",
        "Production Mode",
        "## Configuration Reference\n\n### AutoUIConfig Interface\n\nThe main configuration object that defines your app's capabilities:\n\n```typescript\ninterface AutoUIConfig {\r\n  appId: string; // Required: Your app ID from registration\r\n  llm: LLMConfig; // Required: LLM proxy configuration\r\n  runtime: RuntimeConfig; // Required: Runtime behavior settings\r\n  functions: Record<string, AutoUIFunction>; // Required: Function definitions\r\n  components: Record<string, AutoUIComponent>; // Required: Component definitions\r\n  metadata?: AutoUIMetadata; // Optional: App metadata\r\n}\n```\n\n### LLMConfig\n\nConfiguration for the LLM proxy connection:\n\n```typescript\ninterface LLMConfig {\r\n  proxyUrl: string; // Required: Backend proxy URL\r\n  sharedSecret?: string; // Optional: Shared secret for proxy auth\r\n  temperature?: number; // Optional: Sampling temperature (hint only)\r\n  maxTokens?: number; // Optional: Max tokens (hint only)\r\n  appDescriptionPrompt?: string; // Optional: App description context\r\n  requestHeaders?: Record<string, string>; // Optional: Headers forwarded to proxy\r\n}\n```",
        ": Configures how AutoUI communicates with your LLM proxy service. The `proxyUrl` is the endpoint where user messages are sent, and the proxy returns instructions for rendering components or calling functions.\n\n### RuntimeConfig\n\nConfiguration for runtime behavior:\n\n```typescript\ninterface RuntimeConfig {\r\n  validateLLMOutput?: boolean; // Validate LLM JSON output against schema\r\n  storeChatToLocalStorage?: boolean; // Persist chat history\r\n  localStorageKey?: string; // Key for localStorage\r\n  enableDebugLogs?: boolean; // Enable internal debug logging\r\n  maxSteps?: number; // Maximum instruction steps allowed\r\n  errorHandling?: {\r\n    showToUser?: boolean; // Display errors to users\r\n    retryOnFail?: boolean; // Retry failed operations\r\n  };\r\n  runtimeSchemaPath?: string; // Path to runtime schema file (default: '.autoui-runtime-schema.json')\r\n}\n```",
        ": Controls how AutoUI behaves at runtime, including error handling, persistence, validation, and debugging options.\n\n### AutoUIFunction\n\nDefines a callable function that the LLM can invoke:\n\n```typescript\ninterface AutoUIFunction {\r\n  prompt: string; // Required: Description for LLM to decide when/how to call\r\n  params?: Record<string, string>; // Optional: Parameter descriptions\r\n  returns?: string; // Optional: Return type description\r\n  callFunc: Function; // Required: The actual function implementation\r\n  exampleUsage?: string; // Optional: Example usage for LLM context\r\n  tags?: string[]; // Optional: Tags for organization\r\n  canShareDataWithLLM?: boolean; // Optional: Whether function data can be shared with LLM\r\n}\n```",
        ": Registers functions that the LLM can call based on user requests. The `prompt` field is crucial—it tells the LLM when and how to use this function. The `callFunc` is the actual implementation that gets executed.",
        "```typescript\nfunctions: {\r\n  getUserProfile: {\r\n    prompt: 'Get the current user profile information',\r\n    params: {\r\n      userId: 'string — user ID to fetch',\r\n    },\r\n    returns: 'UserProfile — user profile object',\r\n    callFunc: async ({ userId }) => {\r\n      const response = await fetch(`/api/users/${userId}`);\r\n      return response.json();\r\n    },\r\n  },\r\n}\n```\n\n### AutoUIComponent\n\nDefines a React component that the LLM can render:\n\n```typescript\ninterface AutoUIComponent {\r\n  prompt: string; // Required: Description for LLM to decide when/how to render\r\n  props?: Record<string, string>; // Optional: Prop descriptions\r\n  callComponent: ComponentType<any>; // Required: The React component\r\n  defaults?: Record<string, any>; // Optional: Default prop values\r\n  callbacks?: Record<string, AutoUICallback | Function>; // Optional: Callback handlers\r\n  exampleUsage?: string; // Optional: Example JSX usage\r\n  category?: string; // Optional: Component category\r\n  tags?: string[]; // Optional: Tags for organization\r\n}\n```",
        ": Registers React components that the LLM can render based on user requests. The `prompt` describes what the component does, and `props` describes the component's interface.",
        "```typescript\ncomponents: {\r\n  ProductCard: {\r\n    prompt: 'Display a single product card with image, name, price, and add to cart button',\r\n    props: {\r\n      product: 'Product — product object with id, name, price, image',\r\n      onAddToCart: 'function(productId: string) — callback when add to cart is clicked',\r\n    },\r\n    callComponent: ProductCard,\r\n    defaults: {\r\n      product: { id: '', name: '', price: 0, image: '' },\r\n    },\r\n    category: 'display',\r\n  },\r\n}\n```\n\n### AutoUICallback\n\nDefines callbacks that components can use:\n\n```typescript\ninterface AutoUICallback {\r\n  description: string; // Required: What this callback does\r\n  whenToUse?: string; // Optional: When to use this callback\r\n  example?: string; // Optional: Example usage\r\n  callFunc: Function; // Required: The callback implementation\r\n}\n```",
        ": Defines callback functions that components can use for user interactions (e.g., button clicks, form submissions).\n\n### AutoUIMetadata\n\nOptional metadata about your application:\n\n```typescript\ninterface AutoUIMetadata {\r\n  appName: string; // Required: Application name\r\n  appVersion?: string; // Optional: Version string\r\n  author?: string; // Optional: Author name\r\n  createdAt?: string; // Optional: Creation date\r\n  description?: string; // Optional: App description\r\n  tags?: string[]; // Optional: Tags for categorization\r\n}\n```",
        ": Provides metadata about your application for documentation and organization purposes.",
        "LLM Context",
        "Validation",
        "Documentation",
        "Registration Discovery",
        "Type Resolution",
        "Schema Creation",
        "Development",
        "Production",
        "Commit the Schema",
        "Version Control",
        "CI/CD",
        "Review Changes",
        "## Component Registration\n\nTo register components and functions for schema extraction, use the registration utilities:\n\n```typescript\nimport { autouiRegisterComponentPropsSchema, autouiRegisterFunctionParamsSchema } from '@autoai-ui/autoui';\r\n\r\n// Register a component's props type\r\nautouiRegisterComponentPropsSchema('ProductCard', ProductCardProps);\r\n\r\n// Register a function's parameter and return types\r\nautouiRegisterFunctionParamsSchema('fetchProducts', FetchProductsParams, Product[]);\n```\n\nThese registrations help the plugin extract accurate type information during build time.",
        "## Advanced Features\n\n### Custom Error Handling\n\n```typescript\nruntime: {\r\n  errorHandling: {\r\n    showToUser: true,\r\n    retryOnFail: true,\r\n  },\r\n}\n```\n\n### Chat History Persistence\n\n```typescript\nruntime: {\r\n  storeChatToLocalStorage: true,\r\n  localStorageKey: 'my_app_chat_history',\r\n}\n```\n\n### Debug Logging\n\n```typescript\nruntime: {\r\n  enableDebugLogs: true, // Logs LLM requests/responses and execution steps\r\n}\n```\n\n### Custom Request Headers\n\n```typescript\nllm: {\r\n  requestHeaders: {\r\n    'X-Custom-Header': 'value',\r\n    'Authorization': 'Bearer token',\r\n  },\r\n}\n```",
        "## Type Safety\n\nAutoUI provides full TypeScript support:\n\n```typescript\nimport type { AutoUIConfig, AutoUIFunction, AutoUIComponent } from '@autoai-ui/autoui';\n```\n\nAll configuration interfaces are fully typed, providing autocomplete and type checking in your IDE.",
        "Installing",
        "Registering",
        "Configuring",
        "Adding",
        "Creating",
        "Integrating",
        ".autoui-runtime-schema.json",
        "bash\nnpm install @autoai-ui/autoui",
        "**Peer Dependencies:**\n\n* React >= 19.0.0 \\< 20.0.0\n* React DOM >= 19.0.0 \\< 20.0.0\n\n***\n\n## Getting Started Workflow\n\n### Step 1: Create Your App Registration\n\nBefore integrating AutoUI into your application, you need to register your app with the AutoUI service. You have **two options**:\n\n**Option A: Use AutoUI's Deployed Service (Recommended)**\n\nVisit the [AutoUI Service Portal](https://autoui-chi.vercel.app/) to generate:\n\n* **",
        "**: A unique identifier for your application (e.g.,",
        ")\n* **",
        "**: A secret key used for authenticating requests to the LLM proxy\n\nThis service handles the proxy for you—no backend installation or setup required. Simply use the generated credentials in your config.\n\n**Option B: Self-Hosted Backend**\n\nIf you prefer to run your own backend, see the [Backend Proxy Installation & Configuration](/docs/backend-proxy) guide. You'll need to clone the backend repository and set up your own proxy server.\n\nFor this guide, we'll assume you're using Option A (the deployed service).\n\n### Step 2: Configure Environment Variables\n\nAdd the",
        "to your project's environment file (",
        ",",
        ", or",
        "):",
        "bash\nAUTOUI_APP_ID=app_1768313360453_dbptv83",
        "**Optional Environment Variables:**\n\n*",
        ": Version string for your app (defaults to",
        ")\n*",
        ": Your LLM proxy URL (if using Vite). Use",
        "for the deployed service, or your own proxy URL\n*",
        ": Your shared secret for proxy authentication (from the service portal or your own backend)\n\nThe plugin automatically reads these environment variables during development builds.\n\n### Step 3: Install and Configure the Vite Plugin\n\nAdd the AutoUI type schema plugin to your",
        "typescript\nimport { defineConfig } from 'vite';\r\nimport react from '@vitejs/plugin-react';\r\nimport { autouiTypeSchemaPlugin } from '@autoai-ui/autoui/plugin';\r\n\r\nexport default defineConfig({\r\n  plugins: [\r\n    react(),\r\n    autouiTypeSchemaPlugin({\r\n      // Optional: Override appId from env\r\n      // appId: 'your-app-id',\r\n      // Optional: Override version from env\r\n      // version: '1.0.0',\r\n      // Optional: Custom schema file path\r\n      // runtimeSchemaFile: '.autoui-runtime-schema.json',\r\n    }),\r\n  ],\r\n});",
        "**Plugin Behavior:**\n\n* **Development Mode**: The plugin scans your TypeScript source files, extracts type information from registered components and functions, and generates the",
        "file\n* **Production Mode**: The plugin skips schema generation and uses the existing schema file (which should be committed to your repository)\n\n### Step 4: Create Your AutoUI Configuration\n\nCreate a configuration file (e.g.,",
        ") that defines your app's capabilities:",
        "typescript\nimport type { AutoUIConfig } from '@autoai-ui/autoui';\r\nimport { ModalChat } from '@autoai-ui/autoui';\r\n\r\nconst proxyUrl = import.meta.env.VITE_BASE_URL;\r\nconst sharedSecret = import.meta.env.VITE_AUTOUI_SHARED_SECRET;\r\n\r\nexport const autouiConfig: AutoUIConfig = {\r\n  // Required: Your app ID (from registration)\r\n  appId: import.meta.env.AUTOUI_APP_ID || 'your-app-id',\r\n\r\n  // LLM Configuration\r\n  llm: {\r\n    proxyUrl: proxyUrl, // Your LLM proxy endpoint\r\n    sharedSecret: sharedSecret, // Optional: For proxy authentication\r\n    temperature: 0.7, // Optional: LLM temperature hint\r\n    maxTokens: 2048, // Optional: Max tokens hint\r\n    appDescriptionPrompt: 'A brief description of what your app does',\r\n    requestHeaders: { // Optional: Custom headers\r\n      'HTTP-Referer': 'https://yourdomain.com',\r\n      'X-Title': 'Your App Name',\r\n    },\r\n  },\r\n\r\n  // Runtime Configuration\r\n  runtime: {\r\n    validateLLMOutput: true, // Validate LLM responses against schema\r\n    storeChatToLocalStorage: true, // Persist chat history\r\n    localStorageKey: 'autoui_chat_history', // Storage key\r\n    enableDebugLogs: true, // Enable debug logging\r\n    maxSteps: 20, // Maximum instruction steps per conversation\r\n    errorHandling: {\r\n      showToUser: true, // Display errors to users\r\n      retryOnFail: true, // Retry failed operations\r\n    },\r\n    runtimeSchemaPath: '.autoui-runtime-schema.json', // Optional: Custom schema path\r\n  },\r\n\r\n  // Function Definitions\r\n  functions: {\r\n    fetchProducts: {\r\n      prompt: 'Fetch a list of products filtered by category or search query',\r\n      params: {\r\n        category: 'string (optional) — product category',\r\n        q: 'string (optional) — search query',\r\n      },\r\n      returns: 'Product[] — array of products',\r\n      callFunc: async ({ category, q }) => {\r\n        // Your implementation\r\n        return products;\r\n      },\r\n      tags: ['products', 'search'],\r\n    },\r\n    // ... more functions\r\n  },\r\n\r\n  // Component Definitions\r\n  components: {\r\n    ProductGallery: {\r\n      prompt: 'Display a gallery of products in a grid layout',\r\n      props: {\r\n        products: 'Product[] — array of products to display',\r\n      },\r\n      callComponent: ProductGallery, // Your React component\r\n      defaults: {\r\n        products: [],\r\n      },\r\n      category: 'display',\r\n      tags: ['products', 'gallery'],\r\n    },\r\n    // ... more components\r\n  },\r\n\r\n  // Optional Metadata\r\n  metadata: {\r\n    appName: 'Your App Name',\r\n    appVersion: '1.0.0',\r\n    description: 'Description of your application',\r\n    tags: ['ecommerce', 'react', 'autoui'],\r\n  },\r\n};",
        "### Step 5: Integrate ChatModal Component\n\nImport and use the",
        "component in your application:",
        "typescript\nimport { ModalChat } from '@autoai-ui/autoui';\r\nimport { autouiConfig } from './autoui.config';\r\n\r\nfunction App() {\r\n  return (\r\n    <div>\r\n      <h1>My Application</h1>\r\n      {/* Your app content */}\r\n      \r\n      {/* AutoUI Chat Modal */}\r\n      <ModalChat config={autouiConfig} />\r\n    </div>\r\n  );\r\n}",
        "The",
        "component provides:\n\n* A floating chat button that opens/closes the chat interface\n* A chat interface that communicates with your LLM proxy\n* Automatic rendering of components and execution of functions based on user conversations\n* Chat history persistence (if enabled)\n\n***\n\n## Configuration Reference\n\n### AutoUIConfig Interface\n\nThe main configuration object that defines your app's capabilities:",
        "typescript\ninterface AutoUIConfig {\r\n  appId: string; // Required: Your app ID from registration\r\n  llm: LLMConfig; // Required: LLM proxy configuration\r\n  runtime: RuntimeConfig; // Required: Runtime behavior settings\r\n  functions: Record<string, AutoUIFunction>; // Required: Function definitions\r\n  components: Record<string, AutoUIComponent>; // Required: Component definitions\r\n  metadata?: AutoUIMetadata; // Optional: App metadata\r\n}",
        "### LLMConfig\n\nConfiguration for the LLM proxy connection:",
        "typescript\ninterface LLMConfig {\r\n  proxyUrl: string; // Required: Backend proxy URL\r\n  sharedSecret?: string; // Optional: Shared secret for proxy auth\r\n  temperature?: number; // Optional: Sampling temperature (hint only)\r\n  maxTokens?: number; // Optional: Max tokens (hint only)\r\n  appDescriptionPrompt?: string; // Optional: App description context\r\n  requestHeaders?: Record<string, string>; // Optional: Headers forwarded to proxy\r\n}",
        "**Purpose**: Configures how AutoUI communicates with your LLM proxy service. The",
        "is the endpoint where user messages are sent, and the proxy returns instructions for rendering components or calling functions.\n\n### RuntimeConfig\n\nConfiguration for runtime behavior:",
        "typescript\ninterface RuntimeConfig {\r\n  validateLLMOutput?: boolean; // Validate LLM JSON output against schema\r\n  storeChatToLocalStorage?: boolean; // Persist chat history\r\n  localStorageKey?: string; // Key for localStorage\r\n  enableDebugLogs?: boolean; // Enable internal debug logging\r\n  maxSteps?: number; // Maximum instruction steps allowed\r\n  errorHandling?: {\r\n    showToUser?: boolean; // Display errors to users\r\n    retryOnFail?: boolean; // Retry failed operations\r\n  };\r\n  runtimeSchemaPath?: string; // Path to runtime schema file (default: '.autoui-runtime-schema.json')\r\n}",
        "**Purpose**: Controls how AutoUI behaves at runtime, including error handling, persistence, validation, and debugging options.\n\n### AutoUIFunction\n\nDefines a callable function that the LLM can invoke:",
        "typescript\ninterface AutoUIFunction {\r\n  prompt: string; // Required: Description for LLM to decide when/how to call\r\n  params?: Record<string, string>; // Optional: Parameter descriptions\r\n  returns?: string; // Optional: Return type description\r\n  callFunc: Function; // Required: The actual function implementation\r\n  exampleUsage?: string; // Optional: Example usage for LLM context\r\n  tags?: string[]; // Optional: Tags for organization\r\n  canShareDataWithLLM?: boolean; // Optional: Whether function data can be shared with LLM\r\n}",
        "**Purpose**: Registers functions that the LLM can call based on user requests. The",
        "field is crucial—it tells the LLM when and how to use this function. The",
        "is the actual implementation that gets executed.\n\n**Example:**",
        "typescript\nfunctions: {\r\n  getUserProfile: {\r\n    prompt: 'Get the current user profile information',\r\n    params: {\r\n      userId: 'string — user ID to fetch',\r\n    },\r\n    returns: 'UserProfile — user profile object',\r\n    callFunc: async ({ userId }) => {\r\n      const response = await fetch(",
        ");\r\n      return response.json();\r\n    },\r\n  },\r\n}",
        "### AutoUIComponent\n\nDefines a React component that the LLM can render:",
        "typescript\ninterface AutoUIComponent {\r\n  prompt: string; // Required: Description for LLM to decide when/how to render\r\n  props?: Record<string, string>; // Optional: Prop descriptions\r\n  callComponent: ComponentType<any>; // Required: The React component\r\n  defaults?: Record<string, any>; // Optional: Default prop values\r\n  callbacks?: Record<string, AutoUICallback | Function>; // Optional: Callback handlers\r\n  exampleUsage?: string; // Optional: Example JSX usage\r\n  category?: string; // Optional: Component category\r\n  tags?: string[]; // Optional: Tags for organization\r\n}",
        "**Purpose**: Registers React components that the LLM can render based on user requests. The",
        "describes what the component does, and",
        "describes the component's interface.\n\n**Example:**",
        "typescript\ncomponents: {\r\n  ProductCard: {\r\n    prompt: 'Display a single product card with image, name, price, and add to cart button',\r\n    props: {\r\n      product: 'Product — product object with id, name, price, image',\r\n      onAddToCart: 'function(productId: string) — callback when add to cart is clicked',\r\n    },\r\n    callComponent: ProductCard,\r\n    defaults: {\r\n      product: { id: '', name: '', price: 0, image: '' },\r\n    },\r\n    category: 'display',\r\n  },\r\n}",
        "### AutoUICallback\n\nDefines callbacks that components can use:",
        "typescript\ninterface AutoUICallback {\r\n  description: string; // Required: What this callback does\r\n  whenToUse?: string; // Optional: When to use this callback\r\n  example?: string; // Optional: Example usage\r\n  callFunc: Function; // Required: The callback implementation\r\n}",
        "**Purpose**: Defines callback functions that components can use for user interactions (e.g., button clicks, form submissions).\n\n### AutoUIMetadata\n\nOptional metadata about your application:",
        "typescript\ninterface AutoUIMetadata {\r\n  appName: string; // Required: Application name\r\n  appVersion?: string; // Optional: Version string\r\n  author?: string; // Optional: Author name\r\n  createdAt?: string; // Optional: Creation date\r\n  description?: string; // Optional: App description\r\n  tags?: string[]; // Optional: Tags for categorization\r\n}",
        "**Purpose**: Provides metadata about your application for documentation and organization purposes.\n\n***\n\n## The Runtime Schema File (.autoui-runtime-schema.json)\n\n### What is it?\n\nThe",
        "file is automatically generated by the AutoUI Vite plugin during development builds. It contains a complete type-safe schema of your application's components and functions, extracted from your TypeScript source code.\n\n### Purpose\n\n1. **Type Safety**: Provides a complete type definition of all registered components and functions\n2. **LLM Context**: The schema is sent to the LLM proxy to help it understand your app's structure\n3. **Validation**: Used at runtime to validate LLM responses before executing functions or rendering components\n4. **Documentation**: Serves as a machine-readable documentation of your app's capabilities\n\n### Structure\n\nThe schema file has the following structure:",
        "json\n{\r\n  \"appId\": \"app_1768313360453_dbptv83\",\r\n  \"version\": \"1.0.0\",\r\n  \"generatedAt\": \"2026-01-13T15:59:08.897Z\",\r\n  \"types\": {\r\n    \"Product\": {\r\n      \"type\": \"object\",\r\n      \"properties\": {\r\n        \"id\": { \"type\": \"string\", \"required\": true },\r\n        \"name\": { \"type\": \"string\", \"required\": true },\r\n        \"price\": { \"type\": \"number\", \"required\": true }\r\n      },\r\n      \"refs\": [\"string\", \"number\"]\r\n    },\r\n    \"Product[]\": {\r\n      \"type\": \"array\",\r\n      \"items\": { \"type\": \"Product\" },\r\n      \"refs\": [\"Product\"]\r\n    }\r\n  },\r\n  \"components\": [\r\n    {\r\n      \"name\": \"ProductGallery\",\r\n      \"props\": {\r\n        \"products\": {\r\n          \"type\": \"Product[]\",\r\n          \"required\": true\r\n        }\r\n      }\r\n    }\r\n  ],\r\n  \"functions\": [\r\n    {\r\n      \"name\": \"fetchProducts\",\r\n      \"params\": {\r\n        \"params\": {\r\n          \"type\": \"FetchProductsParams\",\r\n          \"required\": false\r\n        }\r\n      },\r\n      \"returns\": {\r\n        \"type\": \"Promise<Product[]>\"\r\n      }\r\n    }\r\n  ]\r\n}",
        "### How it's Generated\n\n1. **Type Extraction**: The plugin uses",
        "to parse your TypeScript project\n2. **Registration Discovery**: It finds components and functions registered using",
        "and",
        "3. **Type Resolution**: It extracts and resolves all TypeScript types, including:\n   * Primitives (string, number, boolean)\n   * Objects and interfaces\n   * Arrays\n   * Unions and intersections\n   * Generic types\n4. **Schema Creation**: It generates a JSON schema with complete type information\n\n### When is it Generated?\n\n* **Development**: Generated automatically on each build start\n* **Production**: Not generated; uses the committed schema file\n\n### Best Practices\n\n1. **Commit the Schema**: Always commit",
        "to your repository\n2. **Version Control**: The schema should match your code—if you change component props or function signatures, regenerate the schema\n3. **CI/CD**: In production builds, the plugin skips generation and uses the committed schema\n4. **Review Changes**: Review schema changes in pull requests to ensure they match your code changes\n\n***\n\n## Component Registration\n\nTo register components and functions for schema extraction, use the registration utilities:",
        "typescript\nimport { autouiRegisterComponentPropsSchema, autouiRegisterFunctionParamsSchema } from '@autoai-ui/autoui';\r\n\r\n// Register a component's props type\r\nautouiRegisterComponentPropsSchema('ProductCard', ProductCardProps);\r\n\r\n// Register a function's parameter and return types\r\nautouiRegisterFunctionParamsSchema('fetchProducts', FetchProductsParams, Product[]);",
        "These registrations help the plugin extract accurate type information during build time.\n\n***\n\n## Usage Examples\n\n### Basic Chat Integration",
        "typescript\nimport { ModalChat } from '@autoai-ui/autoui';\r\nimport { autouiConfig } from './autoui.config';\r\n\r\nfunction App() {\r\n  return (\r\n    <>\r\n      <YourAppContent />\r\n      <ModalChat config={autouiConfig} />\r\n    </>\r\n  );\r\n}",
        "### Custom Portal Container",
        "typescript\n<ModalChat \r\n  config={autouiConfig} \r\n  portalContainer={document.getElementById('chat-container')} \r\n/>",
        "### Inline Chat (Non-Modal)",
        "typescript\nimport { Chat } from '@autoai-ui/autoui';\r\n\r\nfunction App() {\r\n  return (\r\n    <div>\r\n      <Chat config={autouiConfig} title=\"AI Assistant\" />\r\n    </div>\r\n  );\r\n}",
        "***\n\n## Advanced Features\n\n### Custom Error Handling",
        "typescript\nruntime: {\r\n  errorHandling: {\r\n    showToUser: true,\r\n    retryOnFail: true,\r\n  },\r\n}",
        "### Chat History Persistence",
        "typescript\nruntime: {\r\n  storeChatToLocalStorage: true,\r\n  localStorageKey: 'my_app_chat_history',\r\n}",
        "### Debug Logging",
        "typescript\nruntime: {\r\n  enableDebugLogs: true, // Logs LLM requests/responses and execution steps\r\n}",
        "### Custom Request Headers",
        "typescript\nllm: {\r\n  requestHeaders: {\r\n    'X-Custom-Header': 'value',\r\n    'Authorization': 'Bearer token',\r\n  },\r\n}",
        "***\n\n## Troubleshooting\n\n### Schema Not Generated\n\n* Ensure the plugin is added to",
        "* Check that you have a",
        "or",
        "file\n* Verify components/functions are registered using the registration utilities\n* Check console for plugin error messages\n\n### LLM Not Understanding Your App\n\n* Improve",
        "descriptions in your config\n* Add more detailed",
        "descriptions\n* Ensure",
        "accurately describes your app\n* Review the generated schema file to ensure types are correct\n\n### Functions Not Being Called\n\n* Verify function",
        "clearly describes when to use it\n* Check function registration in the schema file\n* Enable debug logs to see LLM decision-making\n* Ensure function signatures match the schema\n\n### Components Not Rendering\n\n* Verify component",
        "clearly describes when to render it\n* Check component registration in the schema file\n* Ensure component props match the schema\n* Review LLM response in debug logs\n\n***\n\n## Type Safety\n\nAutoUI provides full TypeScript support:",
        "typescript\nimport type { AutoUIConfig, AutoUIFunction, AutoUIComponent } from '@autoai-ui/autoui';",
        "All configuration interfaces are fully typed, providing autocomplete and type checking in your IDE.\n\n***\n\n## Summary\n\nAutoUI enables you to build AI-powered chat interfaces by:\n\n1. **Installing** the library from npm\n2. **Registering** your app to get",
        "3. **Configuring** environment variables (",
        ")\n4. **Adding** the Vite plugin to extract types and generate schema\n5. **Creating** a config that defines your functions and components\n6. **Integrating** the",
        "component into your app\n\nThe plugin automatically generates"
      ]
    }
  },
  {
    "slug": "/functions",
    "title": "Functions",
    "description": "Learn how to register JavaScript functions that the AI assistant can call to interact with your application.",
    "content": "Functions are JavaScript functions you register in your `AutoUIConfig` that the AI assistant can call to interact with your application. They enable the assistant to read state, modify data, trigger side effects, and return information.\n\n## Function Structure\n\nEach function in your config has this structure:\n\n```tsx\nfunctions: {\r\n  functionName: {\r\n    prompt: 'Description of what this function does...',\r\n    params: {\r\n      paramName: 'Type description — what this parameter is',\r\n    },\r\n    callFunc: ({ paramName }) => {\r\n      // Your function implementation\r\n      return result\r\n    },\r\n    returns: 'ReturnType — description of what is returned',\r\n  },\r\n}\n```\n\n## Key Concepts\n\n### Prompt\n\nThe `prompt` field is a **natural language description** that tells the LLM:\n\n* What the function does\n* When to call it\n* What it's used for\n\nThe LLM uses this description to decide whether to call the function and with what parameters.\n\n### Params\n\nThe `params` object describes function parameters in a format the LLM can understand:\n\n```tsx\nparams: {\r\n  draft: 'TaskDraft — { title, description?, status, priority, due_date? }',\r\n  taskId: 'string — unique identifier for the task',\r\n  status: 'string — new status value: \"todo\" | \"in-progress\" | \"done\"',\r\n}\n```\n\n**Format:** `parameterName: 'Type — description'`\n\n* Use TypeScript-like type notation\n* Mark optional parameters with `?`\n* Include examples or constraints when helpful\n\n### callFunc\n\nThe actual JavaScript function that gets executed. It receives an object with the parameters:\n\n```tsx\ncallFunc: ({ draft, taskId, status }) => {\r\n  // Implementation\r\n  return result\r\n}\n```\n\n**Important:**\n\n* Parameters are passed as an object (destructured)\n* The function can be async\n* Return values become context for the LLM\n* Side effects (API calls, state updates) are allowed\n\n### Returns\n\nA description of what the function returns, in the same format as params:\n\n```tsx\nreturns: 'Task — full task object with id, title, status, priority, created_at'\n```\n\n## Example: Task Management Functions\n\nHere's a complete example from a task management app:\n\n```tsx\nfunctions: {\r\n  createTask: {\r\n    prompt: 'Create a new Task object from a TaskDraft by adding id and created_at timestamp.',\r\n    params: {\r\n      draft: 'TaskDraft — { title, description?, status, priority, due_date? }',\r\n    },\r\n    callFunc: ({ draft }: { draft: TaskDraft }) => {\r\n      const task = {\r\n        ...draft,\r\n        id: generateId(),\r\n        created_at: new Date().toISOString(),\r\n      }\r\n      tasks.push(task)\r\n      return task\r\n    },\r\n    returns: 'Task — full task with generated id and created_at fields.',\r\n  },\r\n\r\n  updateTask: {\r\n    prompt: 'Update an existing Task using a TaskDraft patch, preserving id and created_at.',\r\n    params: {\r\n      task: 'Task — existing task object',\r\n      patch: 'TaskDraft — fields to update',\r\n    },\r\n    callFunc: ({ task, patch }: { task: Task; patch: TaskDraft }) => {\r\n      const updated = {\r\n        ...task,\r\n        ...patch,\r\n        id: task.id, // Preserve id\r\n        created_at: task.created_at, // Preserve created_at\r\n      }\r\n      const index = tasks.findIndex(t => t.id === task.id)\r\n      if (index !== -1) {\r\n        tasks[index] = updated\r\n      }\r\n      return updated\r\n    },\r\n    returns: 'Task — updated task object.',\r\n  },\r\n\r\n  summarizeTasks: {\r\n    prompt: 'Compute task statistics: total count and counts by status and priority.',\r\n    params: {\r\n      tasks: 'Task[] — current list of tasks',\r\n    },\r\n    callFunc: ({ tasks }: { tasks: Task[] }) => {\r\n      const total = tasks.length\r\n      const byStatus: Record<string, number> = {}\r\n      const byPriority: Record<string, number> = {}\r\n\r\n      for (const t of tasks) {\r\n        byStatus[t.status] = (byStatus[t.status] ?? 0) + 1\r\n        byPriority[t.priority] = (byPriority[t.priority] ?? 0) + 1\r\n      }\r\n\r\n      return { total, byStatus, byPriority }\r\n    },\r\n    returns: '{ total: number, byStatus: Record<string, number>, byPriority: Record<string, number> }',\r\n  },\r\n\r\n  openTaskForm: {\r\n    prompt: 'Open the task creation form in the main app UI. After opening, tell the user they can close the chat and continue in the form.',\r\n    callFunc: () => {\r\n      setShowForm(true)\r\n    },\r\n  },\r\n\r\n  fetchCurrentTasksState: {\r\n    prompt: 'Return the current list of tasks from application state.',\r\n    callFunc: () => tasks,\r\n    returns: 'Task[] — array of all tasks',\r\n  },\r\n\r\n  showHowManyTasks: {\r\n    prompt: 'Return the number of tasks in the current task list.',\r\n    callFunc: () => tasks.length,\r\n    returns: 'number — count of tasks',\r\n  },\r\n}\n```\n\n## Function Types\n\n### Read-Only Functions\n\nFunctions that only read state and return data:\n\n```tsx\ngetUserProfile: {\r\n  prompt: 'Get the current user profile information.',\r\n  callFunc: () => currentUser,\r\n  returns: 'User — user object with name, email, avatar',\r\n}\n```\n\n### State Modification Functions\n\nFunctions that modify application state:\n\n```tsx\nupdateUserSettings: {\r\n  prompt: 'Update user settings with new values.',\r\n  params: {\r\n    settings: 'UserSettings — { theme, notifications, language }',\r\n  },\r\n  callFunc: ({ settings }) => {\r\n    userSettings = { ...userSettings, ...settings }\r\n    saveToLocalStorage(userSettings)\r\n    return userSettings\r\n  },\r\n  returns: 'UserSettings — updated settings object',\r\n}\n```\n\n### Side Effect Functions\n\nFunctions that trigger side effects (API calls, navigation, etc.):\n\n```tsx\nnavigateToPage: {\r\n  prompt: 'Navigate to a specific page in the application.',\r\n  params: {\r\n    path: 'string — route path (e.g., \"/dashboard\", \"/settings\")',\r\n  },\r\n  callFunc: ({ path }) => {\r\n    router.push(path)\r\n  },\r\n},\r\n\r\nsendEmail: {\r\n  prompt: 'Send an email notification.',\r\n  params: {\r\n    to: 'string — recipient email address',\r\n    subject: 'string — email subject',\r\n    body: 'string — email body text',\r\n  },\r\n  callFunc: async ({ to, subject, body }) => {\r\n    await emailService.send({ to, subject, body })\r\n    return { success: true, messageId: '...' }\r\n  },\r\n  returns: '{ success: boolean, messageId?: string }',\r\n}\n```\n\n### Async Functions\n\nFunctions can be async and return promises:\n\n```tsx\nfetchData: {\r\n  prompt: 'Fetch data from an API endpoint.',\r\n  params: {\r\n    endpoint: 'string — API endpoint URL',\r\n  },\r\n  callFunc: async ({ endpoint }) => {\r\n    const response = await fetch(endpoint)\r\n    return await response.json()\r\n  },\r\n  returns: 'any — JSON response from API',\r\n}\n```\n\n## Data Sharing Rules\n\nFunctions share the same JavaScript scope as your React component. This means:\n\n* **State access**: Functions can read and modify React state\n* **Closures**: Functions have access to variables in their closure\n* **Side effects**: Functions can trigger any side effects (API calls, navigation, etc.)\n\n**Example:**\n\n```tsx\nfunction MyApp() {\r\n  const [tasks, setTasks] = useState([])\r\n  const [showForm, setShowForm] = useState(false)\r\n\r\n  const config: AutoUIConfig = {\r\n    // ...\r\n    functions: {\r\n      // Can access tasks and setTasks\r\n      createTask: {\r\n        prompt: 'Create a new task.',\r\n        params: {\r\n          title: 'string — task title',\r\n        },\r\n        callFunc: ({ title }) => {\r\n          const newTask = { id: generateId(), title, status: 'todo' }\r\n          setTasks([...tasks, newTask]) // Modify React state\r\n          return newTask\r\n        },\r\n        returns: 'Task — newly created task',\r\n      },\r\n\r\n      // Can access showForm and setShowForm\r\n      openTaskForm: {\r\n        prompt: 'Open the task creation form.',\r\n        callFunc: () => {\r\n          setShowForm(true) // Trigger UI change\r\n        },\r\n      },\r\n    },\r\n  }\r\n\r\n  return <ModalChat config={config} />\r\n}\n```\n\n## Best Practices\n\n<Note title=\"Type Safety\" type=\"warning\">\n  While params are described as strings, consider adding TypeScript types for your own code:\n\n  ```tsx\n  interface TaskDraft {\r\n    title: string\r\n    description?: string\r\n    status: 'todo' | 'in-progress' | 'done'\r\n    priority: 'low' | 'medium' | 'high'\r\n    due_date?: string\r\n  }\r\n\r\n  callFunc: ({ draft }: { draft: TaskDraft }) => {\r\n    // TypeScript will catch errors\r\n  }\n  ```\n</Note>\n\n<Note title=\"Idempotency\" type=\"success\">\n  When possible, make functions idempotent (safe to call multiple times):\n\n  ```tsx\n  // Good: Idempotent\r\n  markAsComplete: {\r\n    callFunc: ({ taskId }) => {\r\n      const task = tasks.find(t => t.id === taskId)\r\n      if (task) {\r\n        task.status = 'done' // Safe to call multiple times\r\n      }\r\n      return task\r\n    },\r\n  }\n  ```\n</Note>\n\n## Common Patterns\n\n### CRUD Operations\n\n```tsx\n// Create\r\ncreateItem: { /* ... */ }\r\n\r\n// Read\r\ngetItem: { /* ... */ }\r\nlistItems: { /* ... */ }\r\n\r\n// Update\r\nupdateItem: { /* ... */ }\r\n\r\n// Delete\r\ndeleteItem: { /* ... */ }\n```\n\n### Filtering and Search\n\n```tsx\nsearchItems: {\r\n  prompt: 'Search items by query string.',\r\n  params: {\r\n    query: 'string — search query',\r\n    filters: 'object (optional) — { category?, status?, dateRange? }',\r\n  },\r\n  callFunc: ({ query, filters }) => {\r\n    return items.filter(item => {\r\n      // Filter logic\r\n    })\r\n  },\r\n}\n```\n\n### Statistics and Aggregations\n\n```tsx\ngetStats: {\r\n  prompt: 'Get aggregated statistics.',\r\n  callFunc: () => {\r\n    return {\r\n      total: items.length,\r\n      byCategory: groupBy(items, 'category'),\r\n      average: calculateAverage(items),\r\n    }\r\n  },\r\n}\n```\n\n## Next Steps\n\n* Register components: [Components Registry](/docs/components)\n* Configure runtime: [Runtime & Debugging](/docs/runtime)\n* Troubleshoot issues: [Troubleshooting](/docs/troubleshooting)\n",
    "_searchMeta": {
      "cleanContent": "functions are javascript functions you register in your autouiconfig that the ai assistant can call to interact with your application they enable the assistant to read state modify data trigger side effects and return information function structure each function in your config has this structure: key concepts prompt the prompt field is a natural language description that tells the llm: what the function does when to call it what it s used for the llm uses this description to decide whether to call the function and with what parameters params the params object describes function parameters in a format the llm can understand: format: parametername: type description use typescript-like type notation mark optional parameters with include examples or constraints when helpful callfunc the actual javascript function that gets executed it receives an object with the parameters: important: parameters are passed as an object destructured the function can be async return values become context for the llm side effects api calls state updates are allowed returns a description of what the function returns in the same format as params: example: task management functions here s a complete example from a task management app: function types read-only functions functions that only read state and return data: state modification functions functions that modify application state: side effect functions functions that trigger side effects api calls navigation etc : async functions functions can be async and return promises: data sharing rules functions share the same javascript scope as your react component this means: state access: functions can read and modify react state closures: functions have access to variables in their closure side effects: functions can trigger any side effects api calls navigation etc example: best practices while params are described as strings consider adding typescript types for your own code: when possible make functions idempotent safe to call multiple times : common patterns crud operations filtering and search statistics and aggregations next steps register components: components registry configure runtime: runtime debugging troubleshoot issues: troubleshooting",
      "headings": [
        "Function Structure",
        "Key Concepts",
        "Example: Task Management Functions",
        "Function Types",
        "Data Sharing Rules",
        "Best Practices",
        "Common Patterns",
        "Next Steps"
      ],
      "keywords": [
        "functions",
        "callFunc",
        "params",
        "returns",
        "side effects",
        "Function Structure",
        "Key Concepts",
        "Example: Task Management Functions",
        "Function Types",
        "Data Sharing Rules",
        "Best Practices",
        "Common Patterns",
        "Next Steps",
        "natural language description",
        "Format:",
        "Important:",
        "State access",
        "Closures",
        "Side effects",
        "Example:",
        "AutoUIConfig",
        "tsx\nfunctions: {\r\n  functionName: {\r\n    prompt: 'Description of what this function does...',\r\n    params: {\r\n      paramName: 'Type description — what this parameter is',\r\n    },\r\n    callFunc: ({ paramName }) => {\r\n      // Your function implementation\r\n      return result\r\n    },\r\n    returns: 'ReturnType — description of what is returned',\r\n  },\r\n}",
        "## Key Concepts\n\n### Prompt\n\nThe",
        "field is a **natural language description** that tells the LLM:\n\n* What the function does\n* When to call it\n* What it's used for\n\nThe LLM uses this description to decide whether to call the function and with what parameters.\n\n### Params\n\nThe",
        "object describes function parameters in a format the LLM can understand:",
        "tsx\nparams: {\r\n  draft: 'TaskDraft — { title, description?, status, priority, due_date? }',\r\n  taskId: 'string — unique identifier for the task',\r\n  status: 'string — new status value: \"todo\" | \"in-progress\" | \"done\"',\r\n}",
        "**Format:**",
        "* Use TypeScript-like type notation\n* Mark optional parameters with",
        "* Include examples or constraints when helpful\n\n### callFunc\n\nThe actual JavaScript function that gets executed. It receives an object with the parameters:",
        "tsx\ncallFunc: ({ draft, taskId, status }) => {\r\n  // Implementation\r\n  return result\r\n}",
        "**Important:**\n\n* Parameters are passed as an object (destructured)\n* The function can be async\n* Return values become context for the LLM\n* Side effects (API calls, state updates) are allowed\n\n### Returns\n\nA description of what the function returns, in the same format as params:",
        "tsx\nreturns: 'Task — full task object with id, title, status, priority, created_at'",
        "## Example: Task Management Functions\n\nHere's a complete example from a task management app:",
        "tsx\nfunctions: {\r\n  createTask: {\r\n    prompt: 'Create a new Task object from a TaskDraft by adding id and created_at timestamp.',\r\n    params: {\r\n      draft: 'TaskDraft — { title, description?, status, priority, due_date? }',\r\n    },\r\n    callFunc: ({ draft }: { draft: TaskDraft }) => {\r\n      const task = {\r\n        ...draft,\r\n        id: generateId(),\r\n        created_at: new Date().toISOString(),\r\n      }\r\n      tasks.push(task)\r\n      return task\r\n    },\r\n    returns: 'Task — full task with generated id and created_at fields.',\r\n  },\r\n\r\n  updateTask: {\r\n    prompt: 'Update an existing Task using a TaskDraft patch, preserving id and created_at.',\r\n    params: {\r\n      task: 'Task — existing task object',\r\n      patch: 'TaskDraft — fields to update',\r\n    },\r\n    callFunc: ({ task, patch }: { task: Task; patch: TaskDraft }) => {\r\n      const updated = {\r\n        ...task,\r\n        ...patch,\r\n        id: task.id, // Preserve id\r\n        created_at: task.created_at, // Preserve created_at\r\n      }\r\n      const index = tasks.findIndex(t => t.id === task.id)\r\n      if (index !== -1) {\r\n        tasks[index] = updated\r\n      }\r\n      return updated\r\n    },\r\n    returns: 'Task — updated task object.',\r\n  },\r\n\r\n  summarizeTasks: {\r\n    prompt: 'Compute task statistics: total count and counts by status and priority.',\r\n    params: {\r\n      tasks: 'Task[] — current list of tasks',\r\n    },\r\n    callFunc: ({ tasks }: { tasks: Task[] }) => {\r\n      const total = tasks.length\r\n      const byStatus: Record<string, number> = {}\r\n      const byPriority: Record<string, number> = {}\r\n\r\n      for (const t of tasks) {\r\n        byStatus[t.status] = (byStatus[t.status] ?? 0) + 1\r\n        byPriority[t.priority] = (byPriority[t.priority] ?? 0) + 1\r\n      }\r\n\r\n      return { total, byStatus, byPriority }\r\n    },\r\n    returns: '{ total: number, byStatus: Record<string, number>, byPriority: Record<string, number> }',\r\n  },\r\n\r\n  openTaskForm: {\r\n    prompt: 'Open the task creation form in the main app UI. After opening, tell the user they can close the chat and continue in the form.',\r\n    callFunc: () => {\r\n      setShowForm(true)\r\n    },\r\n  },\r\n\r\n  fetchCurrentTasksState: {\r\n    prompt: 'Return the current list of tasks from application state.',\r\n    callFunc: () => tasks,\r\n    returns: 'Task[] — array of all tasks',\r\n  },\r\n\r\n  showHowManyTasks: {\r\n    prompt: 'Return the number of tasks in the current task list.',\r\n    callFunc: () => tasks.length,\r\n    returns: 'number — count of tasks',\r\n  },\r\n}",
        "## Function Types\n\n### Read-Only Functions\n\nFunctions that only read state and return data:",
        "tsx\ngetUserProfile: {\r\n  prompt: 'Get the current user profile information.',\r\n  callFunc: () => currentUser,\r\n  returns: 'User — user object with name, email, avatar',\r\n}",
        "### State Modification Functions\n\nFunctions that modify application state:",
        "tsx\nupdateUserSettings: {\r\n  prompt: 'Update user settings with new values.',\r\n  params: {\r\n    settings: 'UserSettings — { theme, notifications, language }',\r\n  },\r\n  callFunc: ({ settings }) => {\r\n    userSettings = { ...userSettings, ...settings }\r\n    saveToLocalStorage(userSettings)\r\n    return userSettings\r\n  },\r\n  returns: 'UserSettings — updated settings object',\r\n}",
        "### Side Effect Functions\n\nFunctions that trigger side effects (API calls, navigation, etc.):",
        "tsx\nnavigateToPage: {\r\n  prompt: 'Navigate to a specific page in the application.',\r\n  params: {\r\n    path: 'string — route path (e.g., \"/dashboard\", \"/settings\")',\r\n  },\r\n  callFunc: ({ path }) => {\r\n    router.push(path)\r\n  },\r\n},\r\n\r\nsendEmail: {\r\n  prompt: 'Send an email notification.',\r\n  params: {\r\n    to: 'string — recipient email address',\r\n    subject: 'string — email subject',\r\n    body: 'string — email body text',\r\n  },\r\n  callFunc: async ({ to, subject, body }) => {\r\n    await emailService.send({ to, subject, body })\r\n    return { success: true, messageId: '...' }\r\n  },\r\n  returns: '{ success: boolean, messageId?: string }',\r\n}",
        "### Async Functions\n\nFunctions can be async and return promises:",
        "tsx\nfetchData: {\r\n  prompt: 'Fetch data from an API endpoint.',\r\n  params: {\r\n    endpoint: 'string — API endpoint URL',\r\n  },\r\n  callFunc: async ({ endpoint }) => {\r\n    const response = await fetch(endpoint)\r\n    return await response.json()\r\n  },\r\n  returns: 'any — JSON response from API',\r\n}",
        "## Data Sharing Rules\n\nFunctions share the same JavaScript scope as your React component. This means:\n\n* **State access**: Functions can read and modify React state\n* **Closures**: Functions have access to variables in their closure\n* **Side effects**: Functions can trigger any side effects (API calls, navigation, etc.)\n\n**Example:**",
        "tsx\nfunction MyApp() {\r\n  const [tasks, setTasks] = useState([])\r\n  const [showForm, setShowForm] = useState(false)\r\n\r\n  const config: AutoUIConfig = {\r\n    // ...\r\n    functions: {\r\n      // Can access tasks and setTasks\r\n      createTask: {\r\n        prompt: 'Create a new task.',\r\n        params: {\r\n          title: 'string — task title',\r\n        },\r\n        callFunc: ({ title }) => {\r\n          const newTask = { id: generateId(), title, status: 'todo' }\r\n          setTasks([...tasks, newTask]) // Modify React state\r\n          return newTask\r\n        },\r\n        returns: 'Task — newly created task',\r\n      },\r\n\r\n      // Can access showForm and setShowForm\r\n      openTaskForm: {\r\n        prompt: 'Open the task creation form.',\r\n        callFunc: () => {\r\n          setShowForm(true) // Trigger UI change\r\n        },\r\n      },\r\n    },\r\n  }\r\n\r\n  return <ModalChat config={config} />\r\n}",
        "## Best Practices\n\n<Note title=\"Type Safety\" type=\"warning\">\n  While params are described as strings, consider adding TypeScript types for your own code:",
        "tsx\n  interface TaskDraft {\r\n    title: string\r\n    description?: string\r\n    status: 'todo' | 'in-progress' | 'done'\r\n    priority: 'low' | 'medium' | 'high'\r\n    due_date?: string\r\n  }\r\n\r\n  callFunc: ({ draft }: { draft: TaskDraft }) => {\r\n    // TypeScript will catch errors\r\n  }",
        "</Note>\n\n<Note title=\"Idempotency\" type=\"success\">\n  When possible, make functions idempotent (safe to call multiple times):",
        "tsx\n  // Good: Idempotent\r\n  markAsComplete: {\r\n    callFunc: ({ taskId }) => {\r\n      const task = tasks.find(t => t.id === taskId)\r\n      if (task) {\r\n        task.status = 'done' // Safe to call multiple times\r\n      }\r\n      return task\r\n    },\r\n  }",
        "</Note>\n\n## Common Patterns\n\n### CRUD Operations",
        "tsx\n// Create\r\ncreateItem: { /* ... */ }\r\n\r\n// Read\r\ngetItem: { /* ... */ }\r\nlistItems: { /* ... */ }\r\n\r\n// Update\r\nupdateItem: { /* ... */ }\r\n\r\n// Delete\r\ndeleteItem: { /* ... */ }",
        "### Filtering and Search",
        "tsx\nsearchItems: {\r\n  prompt: 'Search items by query string.',\r\n  params: {\r\n    query: 'string — search query',\r\n    filters: 'object (optional) — { category?, status?, dateRange? }',\r\n  },\r\n  callFunc: ({ query, filters }) => {\r\n    return items.filter(item => {\r\n      // Filter logic\r\n    })\r\n  },\r\n}",
        "### Statistics and Aggregations",
        "tsx\ngetStats: {\r\n  prompt: 'Get aggregated statistics.',\r\n  callFunc: () => {\r\n    return {\r\n      total: items.length,\r\n      byCategory: groupBy(items, 'category'),\r\n      average: calculateAverage(items),\r\n    }\r\n  },\r\n}"
      ]
    }
  },
  {
    "slug": "/installation",
    "title": "Quick Installation & Configuration",
    "description": "Install AUTOUI and get it running in your app quickly.",
    "content": "This guide provides a quick overview of installing and configuring AUTOUI. For a comprehensive setup guide with detailed explanations, see the [Complete Developer Guide](/docs/developer-guide).\n\n## Step 1: Install\n\n```bash\nnpm install @autoai-ui/autoui\n```\n\n**Peer Dependencies:**\n\n* React >= 19.0.0 \\< 20.0.0\n* React DOM >= 19.0.0 \\< 20.0.0\n\n## Step 2: Create Your App Registration\n\nYou have two options for the backend proxy:\n\n### Option A: Use AutoUI's Deployed Service (Recommended)\n\nVisit the [AutoUI Service Portal](https://autoui-chi.vercel.app/) to generate:\n\n* **`appId`**: A unique identifier for your application\n* **`shared_secret`**: A secret key for authenticating requests to the LLM proxy\n\nThis service handles the proxy for you—no backend installation or setup required. Simply use the generated credentials in your config.\n\n### Option B: Self-Hosted Backend\n\nIf you prefer to run your own backend, see the [Backend Proxy Installation & Configuration](/docs/backend-proxy) guide. You'll need to:\n\n1. Clone and set up the AutoUI backend repository\n2. Configure your own proxy server\n3. Use your proxy server URL in the config\n\nFor this guide, we'll assume you're using Option A (the deployed service).\n\n## Step 3: Configure Environment Variables\n\nAdd the following to your `.env`, `.env.local`, or `.env.development` file:\n\n**If using AutoUI's deployed service:**\n\n* Get your `appId` and `shared_secret` from [autoui-chi.vercel.app](https://autoui-chi.vercel.app/)\n* Use the service URL as your `proxyUrl`\n\n**For Vite/React projects:**\n\n```bash\nAUTOUI_APP_ID=app_1768313360453_dbptv83\nVITE_BASE_URL=https://autoui-chi.vercel.app\nVITE_AUTOUI_SHARED_SECRET=your-shared-secret-from-service\n```\n\n**For Next.js:**\n\n```bash\nAUTOUI_APP_ID=app_1768313360453_dbptv83\nNEXT_PUBLIC_PROXY_URL=https://autoui-chi.vercel.app\nNEXT_PUBLIC_SHARED_SECRET=your-shared-secret-from-service\n```\n\n**For Create React App:**\n\n```bash\nAUTOUI_APP_ID=app_1768313360453_dbptv83\nREACT_APP_PROXY_URL=https://autoui-chi.vercel.app\nREACT_APP_SHARED_SECRET=your-shared-secret-from-service\n```\n\n## Step 4: Install and Configure the Vite Plugin (Vite projects only)\n\nIf you're using Vite, add the AutoUI type schema plugin to your `vite.config.ts`:\n\n```typescript\nimport { defineConfig } from 'vite';\nimport react from '@vitejs/plugin-react';\nimport { autouiTypeSchemaPlugin } from '@autoai-ui/autoui/plugin';\n\nexport default defineConfig({\n  plugins: [\n    react(),\n    autouiTypeSchemaPlugin({\n      // Optional: Override appId from env\n      // appId: 'your-app-id',\n      // Optional: Override version from env\n      // version: '1.0.0',\n    }),\n  ],\n});\n```\n\n**Note:** The Vite plugin generates a `.autoui-runtime-schema.json` file during development builds. This file should be committed to your repository.\n\n## Step 5: Create Your AutoUI Configuration\n\nCreate a configuration file (e.g., `lib/autoui-config.ts` or `lib/autoui-config.tsx`):\n\n**React/Vite:**\n\n```tsx\n// lib/autoui-config.ts\nimport type { AutoUIConfig } from '@autoai-ui/autoui';\n\nexport const autouiConfig: AutoUIConfig = {\n  appId: import.meta.env.AUTOUI_APP_ID || 'your-app-id',\n  llm: {\n    proxyUrl: import.meta.env.VITE_BASE_URL || 'http://localhost:3001',\n    sharedSecret: import.meta.env.VITE_AUTOUI_SHARED_SECRET,\n    appDescriptionPrompt: 'A brief description of what your app does',\n  },\n  runtime: {\n    validateLLMOutput: true,\n    storeChatToLocalStorage: true,\n    enableDebugLogs: true,\n    maxSteps: 20,\n  },\n  functions: {\n    // Your functions here\n  },\n  components: {\n    // Your components here\n  },\n};\n```\n\n**Next.js:**\n\n```tsx\n// lib/autoui-config.tsx\n\"use client\"\n\nimport type { AutoUIConfig } from '@autoai-ui/autoui';\n\nexport const autouiConfig: AutoUIConfig = {\n  appId: process.env.AUTOUI_APP_ID || 'your-app-id',\n  llm: {\n    proxyUrl: process.env.NEXT_PUBLIC_PROXY_URL || 'http://localhost:3001',\n    sharedSecret: process.env.NEXT_PUBLIC_SHARED_SECRET,\n    appDescriptionPrompt: 'A brief description of what your app does',\n  },\n  runtime: {\n    validateLLMOutput: true,\n    storeChatToLocalStorage: true,\n    enableDebugLogs: true,\n    maxSteps: 20,\n  },\n  functions: {\n    // Your functions here\n  },\n  components: {\n    // Your components here\n  },\n};\n```\n\n## Step 6: Integrate ModalChat Component\n\n**React:**\n\n```tsx\nimport { ModalChat } from '@autoai-ui/autoui';\nimport { autouiConfig } from './lib/autoui-config';\n\nfunction App() {\n  return (\n    <div>\n      <h1>My Application</h1>\n      <ModalChat config={autouiConfig} />\n    </div>\n  );\n}\n```\n\n**Next.js:**\n\n```tsx\n\"use client\"\n\nimport dynamic from \"next/dynamic\"\nimport { autouiConfig } from \"@/lib/autoui-config\"\n\nconst ModalChat = dynamic(\n  () => import(\"@autoai-ui/autoui\").then(m => m.ModalChat),\n  { ssr: false }\n)\n\nexport default function App() {\n  return <ModalChat config={autouiConfig} />\n}\n```\n\n## What's Next?\n\n* Read the [Complete Developer Guide](/docs/developer-guide) for detailed explanations\n* Set up your [Backend Proxy](/docs/backend-proxy)\n* Understand [Config Structure](/docs/config)\n* Learn about the [Runtime Schema File](/docs/runtime#runtime-schema-file)\n* See [Quick Start Guides](/docs/quickstart) for framework-specific setup\n",
    "_searchMeta": {
      "cleanContent": "this guide provides a quick overview of installing and configuring autoui for a comprehensive setup guide with detailed explanations see the complete developer guide step 1: install peer dependencies: react 19 0 0 20 0 0 react dom 19 0 0 20 0 0 step 2: create your app registration you have two options for the backend proxy: option a: use autoui s deployed service recommended visit the autoui service portal to generate: appid: a unique identifier for your application shared_secret: a secret key for authenticating requests to the llm proxy this service handles the proxy for you no backend installation or setup required simply use the generated credentials in your config option b: self-hosted backend if you prefer to run your own backend see the backend proxy installation configuration guide you ll need to: clone and set up the autoui backend repository configure your own proxy server use your proxy server url in the config for this guide we ll assume you re using option a the deployed service step 3: configure environment variables add the following to your env env local or env development file: if using autoui s deployed service: get your appid and shared_secret from autoui-chi vercel app use the service url as your proxyurl for vite react projects: for next js: for create react app: step 4: install and configure the vite plugin vite projects only if you re using vite add the autoui type schema plugin to your vite config ts: note: the vite plugin generates a autoui-runtime-schema json file during development builds this file should be committed to your repository step 5: create your autoui configuration create a configuration file e g lib autoui-config ts or lib autoui-config tsx : react vite: next js: step 6: integrate modalchat component react: next js: what s next read the complete developer guide for detailed explanations set up your backend proxy understand config structure learn about the runtime schema file see quick start guides for framework-specific setup",
      "headings": [
        "Step 1: Install",
        "Step 2: Create Your App Registration",
        "Step 3: Configure Environment Variables",
        "Step 4: Install and Configure the Vite Plugin (Vite projects only)",
        "Step 5: Create Your AutoUI Configuration",
        "Step 6: Integrate ModalChat Component",
        "What's Next?"
      ],
      "keywords": [
        "installation",
        "setup",
        "quick",
        "vite plugin",
        "schema",
        "Step 1: Install",
        "Step 2: Create Your App Registration",
        "Step 3: Configure Environment Variables",
        "Step 4: Install and Configure the Vite Plugin (Vite projects only)",
        "Step 5: Create Your AutoUI Configuration",
        "Step 6: Integrate ModalChat Component",
        "What's Next?",
        "Peer Dependencies:",
        "`appId`",
        "`shared_secret`",
        "If using AutoUI's deployed service:",
        "For Vite/React projects:",
        "For Next.js:",
        "For Create React App:",
        "Note:",
        "React/Vite:",
        "Next.js:",
        "React:",
        "bash\nnpm install @autoai-ui/autoui",
        "**Peer Dependencies:**\n\n* React >= 19.0.0 \\< 20.0.0\n* React DOM >= 19.0.0 \\< 20.0.0\n\n## Step 2: Create Your App Registration\n\nYou have two options for the backend proxy:\n\n### Option A: Use AutoUI's Deployed Service (Recommended)\n\nVisit the [AutoUI Service Portal](https://autoui-chi.vercel.app/) to generate:\n\n* **",
        "**: A unique identifier for your application\n* **",
        "**: A secret key for authenticating requests to the LLM proxy\n\nThis service handles the proxy for you—no backend installation or setup required. Simply use the generated credentials in your config.\n\n### Option B: Self-Hosted Backend\n\nIf you prefer to run your own backend, see the [Backend Proxy Installation & Configuration](/docs/backend-proxy) guide. You'll need to:\n\n1. Clone and set up the AutoUI backend repository\n2. Configure your own proxy server\n3. Use your proxy server URL in the config\n\nFor this guide, we'll assume you're using Option A (the deployed service).\n\n## Step 3: Configure Environment Variables\n\nAdd the following to your",
        ",",
        ", or",
        "file:\n\n**If using AutoUI's deployed service:**\n\n* Get your",
        "and",
        "from [autoui-chi.vercel.app](https://autoui-chi.vercel.app/)\n* Use the service URL as your",
        "**For Vite/React projects:**",
        "bash\nAUTOUI_APP_ID=app_1768313360453_dbptv83\nVITE_BASE_URL=https://autoui-chi.vercel.app\nVITE_AUTOUI_SHARED_SECRET=your-shared-secret-from-service",
        "**For Next.js:**",
        "bash\nAUTOUI_APP_ID=app_1768313360453_dbptv83\nNEXT_PUBLIC_PROXY_URL=https://autoui-chi.vercel.app\nNEXT_PUBLIC_SHARED_SECRET=your-shared-secret-from-service",
        "**For Create React App:**",
        "bash\nAUTOUI_APP_ID=app_1768313360453_dbptv83\nREACT_APP_PROXY_URL=https://autoui-chi.vercel.app\nREACT_APP_SHARED_SECRET=your-shared-secret-from-service",
        "## Step 4: Install and Configure the Vite Plugin (Vite projects only)\n\nIf you're using Vite, add the AutoUI type schema plugin to your",
        ":",
        "typescript\nimport { defineConfig } from 'vite';\nimport react from '@vitejs/plugin-react';\nimport { autouiTypeSchemaPlugin } from '@autoai-ui/autoui/plugin';\n\nexport default defineConfig({\n  plugins: [\n    react(),\n    autouiTypeSchemaPlugin({\n      // Optional: Override appId from env\n      // appId: 'your-app-id',\n      // Optional: Override version from env\n      // version: '1.0.0',\n    }),\n  ],\n});",
        "**Note:** The Vite plugin generates a",
        "file during development builds. This file should be committed to your repository.\n\n## Step 5: Create Your AutoUI Configuration\n\nCreate a configuration file (e.g.,",
        "or",
        "):\n\n**React/Vite:**",
        "tsx\n// lib/autoui-config.ts\nimport type { AutoUIConfig } from '@autoai-ui/autoui';\n\nexport const autouiConfig: AutoUIConfig = {\n  appId: import.meta.env.AUTOUI_APP_ID || 'your-app-id',\n  llm: {\n    proxyUrl: import.meta.env.VITE_BASE_URL || 'http://localhost:3001',\n    sharedSecret: import.meta.env.VITE_AUTOUI_SHARED_SECRET,\n    appDescriptionPrompt: 'A brief description of what your app does',\n  },\n  runtime: {\n    validateLLMOutput: true,\n    storeChatToLocalStorage: true,\n    enableDebugLogs: true,\n    maxSteps: 20,\n  },\n  functions: {\n    // Your functions here\n  },\n  components: {\n    // Your components here\n  },\n};",
        "**Next.js:**",
        "tsx\n// lib/autoui-config.tsx\n\"use client\"\n\nimport type { AutoUIConfig } from '@autoai-ui/autoui';\n\nexport const autouiConfig: AutoUIConfig = {\n  appId: process.env.AUTOUI_APP_ID || 'your-app-id',\n  llm: {\n    proxyUrl: process.env.NEXT_PUBLIC_PROXY_URL || 'http://localhost:3001',\n    sharedSecret: process.env.NEXT_PUBLIC_SHARED_SECRET,\n    appDescriptionPrompt: 'A brief description of what your app does',\n  },\n  runtime: {\n    validateLLMOutput: true,\n    storeChatToLocalStorage: true,\n    enableDebugLogs: true,\n    maxSteps: 20,\n  },\n  functions: {\n    // Your functions here\n  },\n  components: {\n    // Your components here\n  },\n};",
        "## Step 6: Integrate ModalChat Component\n\n**React:**",
        "tsx\nimport { ModalChat } from '@autoai-ui/autoui';\nimport { autouiConfig } from './lib/autoui-config';\n\nfunction App() {\n  return (\n    <div>\n      <h1>My Application</h1>\n      <ModalChat config={autouiConfig} />\n    </div>\n  );\n}",
        "tsx\n\"use client\"\n\nimport dynamic from \"next/dynamic\"\nimport { autouiConfig } from \"@/lib/autoui-config\"\n\nconst ModalChat = dynamic(\n  () => import(\"@autoai-ui/autoui\").then(m => m.ModalChat),\n  { ssr: false }\n)\n\nexport default function App() {\n  return <ModalChat config={autouiConfig} />\n}"
      ]
    }
  },
  {
    "slug": "/introduction",
    "title": "What is AUTOUI?",
    "description": "Learn about AUTOUI, a config-driven React library that integrates AI-powered chat assistants into your applications.",
    "content": "AutoUI is a powerful React library that enables developers to build AI-powered chat interfaces that can dynamically interact with your application's components and functions. The library uses a Large Language Model (LLM) proxy to understand user intent and automatically render React components or call functions based on natural language conversations.\n\n## How AUTOUI Works\n\nAutoUI works by:\n\n1. **Type Extraction**: Automatically extracting TypeScript type information from your components and functions during build time\n2. **Schema Generation**: Creating a runtime schema file (`.autoui-runtime-schema.json`) that describes your app's capabilities\n3. **LLM Integration**: Sending user messages to an LLM proxy that understands your app structure and generates appropriate actions\n4. **Dynamic Rendering**: Executing function calls and rendering React components based on LLM instructions\n\nAUTOUI follows a **config-driven architecture** where your application's capabilities are defined declaratively. Here's the high-level flow:\n\n```\nUser → ModalChat → Proxy Server → OpenRouter/LLM → Plan JSON → Frontend Runtime → Functions/Components\n```\n\n## Key Concepts\n\n### ModalChat\n\nThe main React component you import and render. It displays a chat interface (typically as a floating button that opens a modal) and manages the conversation flow.\n\n```tsx\nimport { ModalChat } from \"@autoai-ui/autoui\"\n\n<ModalChat config={myConfig} />\n```\n\n### Config-Driven UI\n\nYour `AutoUIConfig` object is the **contract** between your app and the AI assistant. It tells the LLM:\n\n* What your app does (via `metadata.description` and `llm.appDescriptionPrompt`)\n* What functions are available (via `functions`)\n* What UI components can be rendered (via `components`)\n* How to behave (via `runtime` settings)\n\n### Plan & Steps\n\nThe LLM returns a **plan**—a structured JSON object that describes a sequence of actions. The runtime executes these steps in order, calling functions and rendering components as needed.\n\n### Runtime\n\nThe AUTOUI runtime orchestrates plan execution. It:\n\n* Validates LLM output (if `validateLLMOutput` is enabled)\n* Executes function calls with proper error handling\n* Renders components with provided props\n* Manages conversation state and localStorage persistence\n* Enforces `maxSteps` limits to prevent infinite loops\n\n### Functions\n\nFunctions are JavaScript functions you register in your config. They can:\n\n* Read application state\n* Modify data\n* Trigger side effects (API calls, navigation, etc.)\n* Return data that becomes context for the LLM\n  So it is you who decides what functions modalChat can acess\n\n### Components Registry\n\nYou can register React components that the LLM can render dynamically. This enables **generative UI**—the assistant can compose new interfaces on the fly based on user requests.\n\n### Proxy-First LLM Access\n\nAUTOUI uses a **proxy server** pattern for security:\n\n* Your OpenRouter API key stays on the server\n* The frontend only sends a client key (shared secret)\n* The proxy handles authentication and rate limiting\n* CORS and security policies are centralized\n\nYou have **two options** for the backend proxy:\n\n1. **Use AutoUI's Deployed Service** (Recommended for quick start): Visit [autoui-chi.vercel.app](https://autoui-chi.vercel.app/) to generate an `appId` and `shared_secret`. This service handles the proxy for you—no backend installation required.\n\n2. **Self-Hosted Backend**: Copy the AutoUI backend repository and run your own proxy server. Connect to it via the `proxyUrl` in your config. See [Backend Proxy Installation](/docs/backend-proxy) for setup instructions.\n\n## When to Use AUTOUI\n\n## When Not to Use AUTOUI\n\n## Architecture Diagram\n\n```\n┌─────────────┐\n│   User      │\n│  (Browser)  │\n└──────┬──────┘\n       │\n       │ Opens ModalChat\n       ▼\n┌─────────────────┐\n│   ModalChat     │ ◄─── AutoUIConfig\n│  (React Comp)   │      (functions, components, metadata)\n└──────┬──────────┘\n       │\n       │ Sends config + user message\n       ▼\n┌─────────────────┐\n│  Proxy Server   │\n│  (Your Backend) │ ◄─── OPENROUTER_API_KEY (server-side)\n└──────┬──────────┘\n       │\n       │ Forwards to LLM\n       ▼\n┌─────────────────┐\n│  OpenRouter     │\n│  / LLM Provider │\n└──────┬──────────┘\n       │\n       │ Returns Plan JSON\n       ▼\n┌─────────────────┐\n│  Frontend       │\n│  Runtime        │\n└──────┬──────────┘\n       │\n       │ Executes plan:\n       │ - callFunc(...)\n       │ - renderComponent(...)\n       ▼\n┌─────────────────┐\n│  Your App       │\n│  (State/UI)     │\n└─────────────────┘\n```\n\n## Next Steps\n\nReady to get started? Head to the [Complete Developer Guide](/docs/developer-guide) for comprehensive setup instructions, or check the [Quick Installation & Configuration](/docs/installation) guide for a quick start.\n",
    "_searchMeta": {
      "cleanContent": "autoui is a powerful react library that enables developers to build ai-powered chat interfaces that can dynamically interact with your application s components and functions the library uses a large language model llm proxy to understand user intent and automatically render react components or call functions based on natural language conversations how autoui works autoui works by: type extraction: automatically extracting typescript type information from your components and functions during build time schema generation: creating a runtime schema file autoui-runtime-schema json that describes your app s capabilities llm integration: sending user messages to an llm proxy that understands your app structure and generates appropriate actions dynamic rendering: executing function calls and rendering react components based on llm instructions autoui follows a config-driven architecture where your application s capabilities are defined declaratively here s the high-level flow: key concepts modalchat the main react component you import and render it displays a chat interface typically as a floating button that opens a modal and manages the conversation flow config-driven ui your autouiconfig object is the contract between your app and the ai assistant it tells the llm: what your app does via metadata description and llm appdescriptionprompt what functions are available via functions what ui components can be rendered via components how to behave via runtime settings plan steps the llm returns a plan a structured json object that describes a sequence of actions the runtime executes these steps in order calling functions and rendering components as needed runtime the autoui runtime orchestrates plan execution it: validates llm output if validatellmoutput is enabled executes function calls with proper error handling renders components with provided props manages conversation state and localstorage persistence enforces maxsteps limits to prevent infinite loops functions functions are javascript functions you register in your config they can: read application state modify data trigger side effects api calls navigation etc return data that becomes context for the llm so it is you who decides what functions modalchat can acess components registry you can register react components that the llm can render dynamically this enables generative ui the assistant can compose new interfaces on the fly based on user requests proxy-first llm access autoui uses a proxy server pattern for security: your openrouter api key stays on the server the frontend only sends a client key shared secret the proxy handles authentication and rate limiting cors and security policies are centralized you have two options for the backend proxy: use autoui s deployed service recommended for quick start : visit autoui-chi vercel app to generate an appid and shared_secret this service handles the proxy for you no backend installation required self-hosted backend: copy the autoui backend repository and run your own proxy server connect to it via the proxyurl in your config see backend proxy installation for setup instructions when to use autoui when not to use autoui architecture diagram next steps ready to get started head to the complete developer guide for comprehensive setup instructions or check the quick installation configuration guide for a quick start",
      "headings": [
        "How AUTOUI Works",
        "Key Concepts",
        "When to Use AUTOUI",
        "When Not to Use AUTOUI",
        "Architecture Diagram",
        "Next Steps"
      ],
      "keywords": [
        "autoui",
        "introduction",
        "modalchat",
        "ai",
        "llm",
        "react",
        "How AUTOUI Works",
        "Key Concepts",
        "When to Use AUTOUI",
        "When Not to Use AUTOUI",
        "Architecture Diagram",
        "Next Steps",
        "Type Extraction",
        "Schema Generation",
        "LLM Integration",
        "Dynamic Rendering",
        "config-driven architecture",
        "contract",
        "plan",
        "generative UI",
        "proxy server",
        "two options",
        "Use AutoUI's Deployed Service",
        "Self-Hosted Backend",
        ".autoui-runtime-schema.json",
        "User → ModalChat → Proxy Server → OpenRouter/LLM → Plan JSON → Frontend Runtime → Functions/Components",
        "## Key Concepts\n\n### ModalChat\n\nThe main React component you import and render. It displays a chat interface (typically as a floating button that opens a modal) and manages the conversation flow.",
        "tsx\nimport { ModalChat } from \"@autoai-ui/autoui\"\n\n<ModalChat config={myConfig} />",
        "### Config-Driven UI\n\nYour",
        "object is the **contract** between your app and the AI assistant. It tells the LLM:\n\n* What your app does (via",
        "and",
        ")\n* What functions are available (via",
        ")\n* What UI components can be rendered (via",
        ")\n* How to behave (via",
        "settings)\n\n### Plan & Steps\n\nThe LLM returns a **plan**—a structured JSON object that describes a sequence of actions. The runtime executes these steps in order, calling functions and rendering components as needed.\n\n### Runtime\n\nThe AUTOUI runtime orchestrates plan execution. It:\n\n* Validates LLM output (if",
        "is enabled)\n* Executes function calls with proper error handling\n* Renders components with provided props\n* Manages conversation state and localStorage persistence\n* Enforces",
        "limits to prevent infinite loops\n\n### Functions\n\nFunctions are JavaScript functions you register in your config. They can:\n\n* Read application state\n* Modify data\n* Trigger side effects (API calls, navigation, etc.)\n* Return data that becomes context for the LLM\n  So it is you who decides what functions modalChat can acess\n\n### Components Registry\n\nYou can register React components that the LLM can render dynamically. This enables **generative UI**—the assistant can compose new interfaces on the fly based on user requests.\n\n### Proxy-First LLM Access\n\nAUTOUI uses a **proxy server** pattern for security:\n\n* Your OpenRouter API key stays on the server\n* The frontend only sends a client key (shared secret)\n* The proxy handles authentication and rate limiting\n* CORS and security policies are centralized\n\nYou have **two options** for the backend proxy:\n\n1. **Use AutoUI's Deployed Service** (Recommended for quick start): Visit [autoui-chi.vercel.app](https://autoui-chi.vercel.app/) to generate an",
        ". This service handles the proxy for you—no backend installation required.\n\n2. **Self-Hosted Backend**: Copy the AutoUI backend repository and run your own proxy server. Connect to it via the",
        "in your config. See [Backend Proxy Installation](/docs/backend-proxy) for setup instructions.\n\n## When to Use AUTOUI\n\n## When Not to Use AUTOUI\n\n## Architecture Diagram",
        "┌─────────────┐\n│   User      │\n│  (Browser)  │\n└──────┬──────┘\n       │\n       │ Opens ModalChat\n       ▼\n┌─────────────────┐\n│   ModalChat     │ ◄─── AutoUIConfig\n│  (React Comp)   │      (functions, components, metadata)\n└──────┬──────────┘\n       │\n       │ Sends config + user message\n       ▼\n┌─────────────────┐\n│  Proxy Server   │\n│  (Your Backend) │ ◄─── OPENROUTER_API_KEY (server-side)\n└──────┬──────────┘\n       │\n       │ Forwards to LLM\n       ▼\n┌─────────────────┐\n│  OpenRouter     │\n│  / LLM Provider │\n└──────┬──────────┘\n       │\n       │ Returns Plan JSON\n       ▼\n┌─────────────────┐\n│  Frontend       │\n│  Runtime        │\n└──────┬──────────┘\n       │\n       │ Executes plan:\n       │ - callFunc(...)\n       │ - renderComponent(...)\n       ▼\n┌─────────────────┐\n│  Your App       │\n│  (State/UI)     │\n└─────────────────┘"
      ]
    }
  },
  {
    "slug": "/markdown/cards",
    "title": "Cards",
    "description": "Explore and implement various card styles, including small, large and image cards.",
    "content": "This section introduces the different card styles available in the system, from compact small cards to visually rich image cards. Each example is paired with JSX code snippets, providing you with a practical guide to incorporate these components seamlessly into your project.\n\n## Small Card\n\n```jsx\n<CardGrid>\n  <Card\n    title=\"Instructions\"\n    href=\"/docs/basic-setup/installation\"\n    icon=\"alignJustify\"\n    variant=\"small\"\n    description=\"test description\"\n  />\n  <Card\n    title=\"Setup\"\n    href=\"/docs/basic-setup/setup\"\n    icon=\"alignJustify\"\n    variant=\"small\"\n  />\n  <Card\n    title=\"@autoai-ui/autoui\"\n    href=\"https://www.npmjs.com/package/@autoai-ui/autoui\"\n    icon=\"alignJustify\"\n    external={true}\n    variant=\"small\"\n  />\n</CardGrid>\n```\n\n## Large Card\n\n```jsx\n<CardGrid>\n  <Card\n    subtitle=\"Instructions\"\n    title=\"Installation\"\n    description=\"Get started with Documents using our quick start installation guide to get your project started.\"\n    href=\"/docs/basic-setup/installation\"\n  />\n  <Card\n    subtitle=\"Setup\"\n    title=\"Site Settings\"\n    description=\"Setting up your Documents projects layout, links and search engine optimisation.\"\n    href=\"/docs/basic-setup/setup\"\n  />\n  <Card\n    subtitle=\"Support\"\n    title=\"Rubix Studios\"\n    description=\"Australia's leading branding, marketing and web development company.\"\n    href=\"https://rubixstudios.com.au\"\n    external={true}\n  />\n</CardGrid>\n```\n\n## Image Card\n\n```jsx\n<CardGrid>\n  <Card\n    title=\"Instructions\"\n    href=\"/docs/introduction/installation\"\n    image=\"/images/og-image.png\"\n    variant=\"image\"\n  />\n  <Card\n    title=\"Setup\"\n    href=\"/docs/introduction/setup\"\n    image=\"/images/og-image.png\"\n    variant=\"image\"\n  />\n  <Card\n    title=\"@autoai-ui/autoui\"\n    href=\"https://www.npmjs.com/package/@autoai-ui/autoui\"\n    image=\"/images/og-image.png\"\n    external={true}\n    variant=\"image\"\n  />\n</CardGrid>\n```\n",
    "_searchMeta": {
      "cleanContent": "this section introduces the different card styles available in the system from compact small cards to visually rich image cards each example is paired with jsx code snippets providing you with a practical guide to incorporate these components seamlessly into your project small card large card image card",
      "headings": [
        "Small Card",
        "Large Card",
        "Image Card"
      ],
      "keywords": [
        "Small Card",
        "Large Card",
        "Image Card",
        "jsx\n<CardGrid>\n  <Card\n    title=\"Instructions\"\n    href=\"/docs/basic-setup/installation\"\n    icon=\"alignJustify\"\n    variant=\"small\"\n    description=\"test description\"\n  />\n  <Card\n    title=\"Setup\"\n    href=\"/docs/basic-setup/setup\"\n    icon=\"alignJustify\"\n    variant=\"small\"\n  />\n  <Card\n    title=\"@autoai-ui/autoui\"\n    href=\"https://www.npmjs.com/package/@autoai-ui/autoui\"\n    icon=\"alignJustify\"\n    external={true}\n    variant=\"small\"\n  />\n</CardGrid>",
        "## Large Card",
        "jsx\n<CardGrid>\n  <Card\n    subtitle=\"Instructions\"\n    title=\"Installation\"\n    description=\"Get started with Documents using our quick start installation guide to get your project started.\"\n    href=\"/docs/basic-setup/installation\"\n  />\n  <Card\n    subtitle=\"Setup\"\n    title=\"Site Settings\"\n    description=\"Setting up your Documents projects layout, links and search engine optimisation.\"\n    href=\"/docs/basic-setup/setup\"\n  />\n  <Card\n    subtitle=\"Support\"\n    title=\"Rubix Studios\"\n    description=\"Australia's leading branding, marketing and web development company.\"\n    href=\"https://rubixstudios.com.au\"\n    external={true}\n  />\n</CardGrid>",
        "## Image Card",
        "jsx\n<CardGrid>\n  <Card\n    title=\"Instructions\"\n    href=\"/docs/introduction/installation\"\n    image=\"/images/og-image.png\"\n    variant=\"image\"\n  />\n  <Card\n    title=\"Setup\"\n    href=\"/docs/introduction/setup\"\n    image=\"/images/og-image.png\"\n    variant=\"image\"\n  />\n  <Card\n    title=\"@autoai-ui/autoui\"\n    href=\"https://www.npmjs.com/package/@autoai-ui/autoui\"\n    image=\"/images/og-image.png\"\n    external={true}\n    variant=\"image\"\n  />\n</CardGrid>"
      ]
    }
  },
  {
    "slug": "/markdown/diagrams",
    "title": "Diagrams",
    "description": "Add various diagram types, including flowcharts, decision trees and entity-relationship diagrams.",
    "content": "Diagrams are powerful tools for visualizing processes, relationships, and decisions. This section showcases different types of diagrams created using **Mermaid**, complete with examples and reusable code snippets to integrate into your projects.\n\n## Flowchart\n\nA flowchart represents a sequence of steps or processes in a visual format. Use this diagram to map workflows, decision-making processes, or operational flows.\n\n```jsx\n<Mermaid\r\n  chart={\\`\r\n    graph TD;\r\n    Start --> Task1;\r\n    Task1 --> Task2;\r\n    Task2 --> End;\r\n  \\`}\r\n/>\n```\n\n## Decision Tree\n\nDecision trees illustrate choices and possible outcomes, making them ideal for decision-making workflows or processes involving multiple paths.\n\n```jsx\n<Mermaid\r\n  chart={\\`\r\n    graph TD;\r\n    A[Start] --> B{Is it raining?};\r\n    B -->|Yes| C[Take an umbrella];\r\n    B -->|No| D[Enjoy the weather];\r\n    C --> E[Go outside];\r\n    D --> E;\r\n  \\`}\r\n/>\n```\n\n## Entity-Relationship Diagram\n\nEntity-relationship diagrams (ERDs) are used to model relationships between entities in a system. They are widely used in database design and system architecture planning.\n\n```jsx\n<Mermaid\r\n  chart={\\`\r\n    erDiagram\r\n    CUSTOMER ||--o{ ORDER : places\r\n    ORDER ||--|{ LINE-ITEM : contains\r\n    PRODUCT ||--o{ LINE-ITEM : \"included in\"\r\n    CUSTOMER {\r\n        string name\r\n        string email\r\n    }\r\n    ORDER {\r\n        int orderNumber\r\n        date orderDate\r\n    }\r\n    LINE-ITEM {\r\n        int quantity\r\n        float price\r\n    }\r\n    PRODUCT {\r\n        int productId\r\n        string name\r\n        float price\r\n    }\r\n  \\`}\r\n/>\n```\n\nEach of these diagrams serves a specific purpose and Mermaid makes it easy to generate them dynamically. Feel free to experiment with the provided code snippets and adapt them to your needs.\n",
    "_searchMeta": {
      "cleanContent": "diagrams are powerful tools for visualizing processes relationships and decisions this section showcases different types of diagrams created using mermaid complete with examples and reusable code snippets to integrate into your projects flowchart a flowchart represents a sequence of steps or processes in a visual format use this diagram to map workflows decision-making processes or operational flows decision tree decision trees illustrate choices and possible outcomes making them ideal for decision-making workflows or processes involving multiple paths entity-relationship diagram entity-relationship diagrams erds are used to model relationships between entities in a system they are widely used in database design and system architecture planning each of these diagrams serves a specific purpose and mermaid makes it easy to generate them dynamically feel free to experiment with the provided code snippets and adapt them to your needs",
      "headings": [
        "Flowchart",
        "Decision Tree",
        "Entity-Relationship Diagram"
      ],
      "keywords": [
        "Flowchart",
        "Decision Tree",
        "Entity-Relationship Diagram",
        "Mermaid",
        "jsx\n<Mermaid\r\n  chart={\\",
        "}\r\n/>",
        "## Decision Tree\n\nDecision trees illustrate choices and possible outcomes, making them ideal for decision-making workflows or processes involving multiple paths.",
        "## Entity-Relationship Diagram\n\nEntity-relationship diagrams (ERDs) are used to model relationships between entities in a system. They are widely used in database design and system architecture planning."
      ]
    }
  },
  {
    "slug": "/markdown/filetree",
    "title": "Filetree",
    "description": "This section provides an overview of file structures and their implementation using the FileTree component.",
    "content": "This section demonstrates the structure of a file tree using the `FileTree` component. Below is an example showcasing folders and files organized hierarchically for a project setup.\n\n## How to Use\n\nIntegrate the `FileTree` component into your project to visually represent file and folder structures. This is particularly useful for documentation, tutorials, or providing users with an overview of your project's architecture.\n\n### JSX Code Example\n\nHere is how you can define the file tree structure in for use in your project:\n\n```jsx\n<FileTree>\r\n  <Folder name=\"src\" label=\"Source Code\">\r\n    <File name=\"index.tsx\" label=\"Index File\" />\r\n    <Folder name=\"components\" label=\"Components\">\r\n      <File name=\"button.tsx\" label=\"Button Component\" />\r\n      <File name=\"input.tsx\" label=\"Input Component\" />\r\n    </Folder>\r\n    <Folder name=\"pages\" label=\"Pages\">\r\n      <File name=\"home.tsx\" label=\"Home Page\" />\r\n      <File name=\"about.tsx\" label=\"About Page\" />\r\n    </Folder>\r\n  </Folder>\r\n</FileTree>\n```\n\nUse this code as a template to set up your own file tree structure and customize it as needed.\n",
    "_searchMeta": {
      "cleanContent": "this section demonstrates the structure of a file tree using the filetree component below is an example showcasing folders and files organized hierarchically for a project setup how to use integrate the filetree component into your project to visually represent file and folder structures this is particularly useful for documentation tutorials or providing users with an overview of your project s architecture jsx code example here is how you can define the file tree structure in for use in your project: use this code as a template to set up your own file tree structure and customize it as needed",
      "headings": [
        "How to Use"
      ],
      "keywords": [
        "How to Use",
        "FileTree",
        "jsx\n<FileTree>\r\n  <Folder name=\"src\" label=\"Source Code\">\r\n    <File name=\"index.tsx\" label=\"Index File\" />\r\n    <Folder name=\"components\" label=\"Components\">\r\n      <File name=\"button.tsx\" label=\"Button Component\" />\r\n      <File name=\"input.tsx\" label=\"Input Component\" />\r\n    </Folder>\r\n    <Folder name=\"pages\" label=\"Pages\">\r\n      <File name=\"home.tsx\" label=\"Home Page\" />\r\n      <File name=\"about.tsx\" label=\"About Page\" />\r\n    </Folder>\r\n  </Folder>\r\n</FileTree>"
      ]
    }
  },
  {
    "slug": "/markdown",
    "title": "Introduction",
    "description": "This section provides an overview of Introduction.",
    "content": "Lorem ipsum dolor sit amet consectetur adipisicing elit. Numquam iste dolorum tempore consectetur explicabo tempora provident quia maxime, molestiae, facilis aperiam et, error illum vel ullam? Quis architecto dolore ullam\n\n* \\[x] Write the press release\n* \\[ ] Update the website\n* \\[ ] Contact the media\n\n| Syntax        | Description |   Test Text |\r\n| :------------ | :---------: | ----------: |\r\n| Header        |    Title    | Here's this |\r\n| Paragraph     |    Text     |    And more |\r\n| Strikethrough |             |    ~~Text~~ |\n\n## Sample Document with Mermaid\n\nHere is a Mermaid diagram:\n\nThis diagram should render automatically without any extra imports.\n\n## Getting Started\n\nTo begin using the Documentation Template, follow these simple steps:\n\n* Start by cloning the repository to your local machine.\n\nLorem ipsum dolor sit amet consectetur adipisicing elit. Reprehenderit quae iure nulla deserunt dolore quam pariatur minus sapiente accusantium. Optio, necessitatibus sequi. Veritatis, aspernatur? Possimus quis repellat eum vitae eveniet.\n\n## Blockquotes\n\nBlockquotes are useful for emphasizing key points or quoting external sources:\n\n> \"Documentation is a love letter that you write to your future self.\" - Damian Conway\n\nFeel free to use blockquotes to highlight important information or quotes relevant to your documentation.\n\n## Code Examples with switch\n\nHere a custom tab component from shadcn ui is used.\n\n## Conclusion\n\nThank you for choosing the Documentation Template for your project. Whether you're documenting software, APIs, or processes, we're here to support you in creating clear and effective documentation. Happy documenting!\n",
    "_searchMeta": {
      "cleanContent": "lorem ipsum dolor sit amet consectetur adipisicing elit numquam iste dolorum tempore consectetur explicabo tempora provident quia maxime molestiae facilis aperiam et error illum vel ullam quis architecto dolore ullam x write the press release update the website contact the media syntax description test text :------------ :---------: ----------: header title here s this paragraph text and more strikethrough text sample document with mermaid here is a mermaid diagram: this diagram should render automatically without any extra imports getting started to begin using the documentation template follow these simple steps: start by cloning the repository to your local machine lorem ipsum dolor sit amet consectetur adipisicing elit reprehenderit quae iure nulla deserunt dolore quam pariatur minus sapiente accusantium optio necessitatibus sequi veritatis aspernatur possimus quis repellat eum vitae eveniet blockquotes blockquotes are useful for emphasizing key points or quoting external sources: documentation is a love letter that you write to your future self - damian conway feel free to use blockquotes to highlight important information or quotes relevant to your documentation code examples with switch here a custom tab component from shadcn ui is used conclusion thank you for choosing the documentation template for your project whether you re documenting software apis or processes we re here to support you in creating clear and effective documentation happy documenting",
      "headings": [
        "Sample Document with Mermaid",
        "Getting Started",
        "Blockquotes",
        "Code Examples with switch",
        "Conclusion"
      ],
      "keywords": [
        "Sample Document with Mermaid",
        "Getting Started",
        "Blockquotes",
        "Code Examples with switch",
        "Conclusion"
      ]
    }
  },
  {
    "slug": "/markdown/lists",
    "title": "Lists",
    "description": "This section provides an overview of creating and using lists in the Documents boilerplate.",
    "content": "Learn how to create and render different types of lists in the Documents boilerplate. Examples include checklists, ordered lists, unordered lists and nested lists.\n\n## Checklist\n\n* \\[x] Write the press release\n* \\[ ] Update the website\n* \\[ ] Contact the media\n\n```jsx\n- [x] Write the press release\r\n- [ ] Update the website\r\n- [ ] Contact the media\n```\n\n## Simple List\n\n* Item 1\n* Item 2\n* Item 3\n\n```jsx\n- Item 1\r\n- Item 2\r\n- Item 3\n```\n\n## Number List\n\n1. Research\n2. Draft the content\n3. Review and edit\n4. Publish\n\n```jsx\n1. Research\r\n2. Draft the content\r\n3. Review and edit\r\n4. Publish\n```\n\n## Nested List\n\n* Main Category 1\n  * Sub Item 1.1\n  * Sub Item 1.2\n* Main Category 2\n  * Sub Item 2.1\n  * Sub Item 2.2\n\n```jsx\n- Main Category 1\r\n  - Sub Item 1.1\r\n  - Sub Item 1.2\r\n- Main Category 2\r\n  - Sub Item 2.1\r\n  - Sub Item 2.2\n```\n\nUse these examples as a foundation to create and customize lists that fit your project's needs.\n",
    "_searchMeta": {
      "cleanContent": "learn how to create and render different types of lists in the documents boilerplate examples include checklists ordered lists unordered lists and nested lists checklist x write the press release update the website contact the media simple list item 1 item 2 item 3 number list research draft the content review and edit publish nested list main category 1 sub item 1 1 sub item 1 2 main category 2 sub item 2 1 sub item 2 2 use these examples as a foundation to create and customize lists that fit your project s needs",
      "headings": [
        "Checklist",
        "Simple List",
        "Number List",
        "Nested List"
      ],
      "keywords": [
        "Checklist",
        "Simple List",
        "Number List",
        "Nested List",
        "jsx\n- [x] Write the press release\r\n- [ ] Update the website\r\n- [ ] Contact the media",
        "## Simple List\n\n* Item 1\n* Item 2\n* Item 3",
        "jsx\n- Item 1\r\n- Item 2\r\n- Item 3",
        "## Number List\n\n1. Research\n2. Draft the content\n3. Review and edit\n4. Publish",
        "jsx\n1. Research\r\n2. Draft the content\r\n3. Review and edit\r\n4. Publish",
        "## Nested List\n\n* Main Category 1\n  * Sub Item 1.1\n  * Sub Item 1.2\n* Main Category 2\n  * Sub Item 2.1\n  * Sub Item 2.2",
        "jsx\n- Main Category 1\r\n  - Sub Item 1.1\r\n  - Sub Item 1.2\r\n- Main Category 2\r\n  - Sub Item 2.1\r\n  - Sub Item 2.2"
      ]
    }
  },
  {
    "slug": "/markdown/maths",
    "title": "Maths",
    "description": "This section provides an overview of Introduction.",
    "content": "Lorem ipsum dolor sit amet consectetur adipisicing elit. Numquam iste dolorum tempore consectetur explicabo tempora provident quia maxime, molestiae, facilis aperiam et, error illum vel ullam? Quis architecto dolore ullam\n\n## Basic Algebra\n\nThe area of a circle ($$A$$) can be calculated using the radius ($$r$$) as follows:\n\n```math\nA = \\pi r^2\n```\n\n## Quadratic Formula\n\nThe quadratic formula for solving an equation of the form $$ax^2 + bx + c = 0$$ is:\n\n```math\nx = \\frac{-b \\pm \\sqrt{b^2 - 4ac}}{2a}\n```\n\n## Newton's Second Law of Motion\n\nNewton's second law of motion states that force ($$F$$) is the product of mass ($$m$$) and acceleration ($$a$$):\n\n```math\nF = ma\n```\n\n## Pythagorean Theorem\n\nThe Pythagorean theorem relates the lengths of the sides of a right triangle:\n\n```math\na^2 + b^2 = c^2\n```\n\n## Einstein's Mass-Energy Equivalence\n\nEinstein's famous equation relates energy ($$E$$), mass ($$m$$), and the speed of light ($$c$$):\n\n```math\nE = mc^2\n```\n",
    "_searchMeta": {
      "cleanContent": "lorem ipsum dolor sit amet consectetur adipisicing elit numquam iste dolorum tempore consectetur explicabo tempora provident quia maxime molestiae facilis aperiam et error illum vel ullam quis architecto dolore ullam basic algebra the area of a circle a can be calculated using the radius r as follows: quadratic formula the quadratic formula for solving an equation of the form ax 2 bx c 0 is: newton s second law of motion newton s second law of motion states that force f is the product of mass m and acceleration a : pythagorean theorem the pythagorean theorem relates the lengths of the sides of a right triangle: einstein s mass-energy equivalence einstein s famous equation relates energy e mass m and the speed of light c :",
      "headings": [
        "Basic Algebra",
        "Quadratic Formula",
        "Newton's Second Law of Motion",
        "Pythagorean Theorem",
        "Einstein's Mass-Energy Equivalence"
      ],
      "keywords": [
        "Basic Algebra",
        "Quadratic Formula",
        "Newton's Second Law of Motion",
        "Pythagorean Theorem",
        "Einstein's Mass-Energy Equivalence",
        "math\nA = \\pi r^2",
        "## Quadratic Formula\n\nThe quadratic formula for solving an equation of the form $$ax^2 + bx + c = 0$$ is:",
        "math\nx = \\frac{-b \\pm \\sqrt{b^2 - 4ac}}{2a}",
        "## Newton's Second Law of Motion\n\nNewton's second law of motion states that force ($$F$$) is the product of mass ($$m$$) and acceleration ($$a$$):",
        "math\nF = ma",
        "## Pythagorean Theorem\n\nThe Pythagorean theorem relates the lengths of the sides of a right triangle:",
        "math\na^2 + b^2 = c^2",
        "## Einstein's Mass-Energy Equivalence\n\nEinstein's famous equation relates energy ($$E$$), mass ($$m$$), and the speed of light ($$c$$):",
        "math\nE = mc^2"
      ]
    }
  },
  {
    "slug": "/markdown/notes",
    "title": "Notes",
    "description": "This section provides an overview of Introduction.",
    "content": "Lorem ipsum dolor sit amet consectetur adipisicing elit. Numquam iste dolorum tempore consectetur explicabo tempora provident quia maxime, molestiae, facilis aperiam et, error illum vel ullam? Quis architecto dolore ullam\n\n## Standard Note\n\n## Success Note\n\n## Warning Note\n\n## Danger Note\n",
    "_searchMeta": {
      "cleanContent": "lorem ipsum dolor sit amet consectetur adipisicing elit numquam iste dolorum tempore consectetur explicabo tempora provident quia maxime molestiae facilis aperiam et error illum vel ullam quis architecto dolore ullam standard note success note warning note danger note",
      "headings": [
        "Standard Note",
        "Success Note",
        "Warning Note",
        "Danger Note"
      ],
      "keywords": [
        "Standard Note",
        "Success Note",
        "Warning Note",
        "Danger Note"
      ]
    }
  },
  {
    "slug": "/markdown/steps",
    "title": "Steps",
    "description": "This section provides an overview of Introduction.",
    "content": "The `<Step>` and `<StepItem>` components allow you to create structured step-by-step guides in your documentation. These components are particularly useful when you want to break down a process or tutorial into easy-to-follow stages.\n\n## Steps\n\nTo create a step-by-step guide in your MDX, you can use the following structure:\n",
    "_searchMeta": {
      "cleanContent": "the step and stepitem components allow you to create structured step-by-step guides in your documentation these components are particularly useful when you want to break down a process or tutorial into easy-to-follow stages steps to create a step-by-step guide in your mdx you can use the following structure:",
      "headings": [
        "Steps"
      ],
      "keywords": [
        "Steps",
        "<Step>",
        "<StepItem>"
      ]
    }
  },
  {
    "slug": "/markdown/table",
    "title": "Table",
    "description": "This section provides an overview of Introduction.",
    "content": "Lorem ipsum dolor sit amet consectetur adipisicing elit. Numquam iste dolorum tempore consectetur explicabo tempora provident quia maxime, molestiae, facilis aperiam et, error illum vel ullam? Quis architecto dolore ullam\n\n| Syntax        | Description |   Test Text |\r\n| :------------ | :---------: | ----------: |\r\n| Header        |    Title    | Here's this |\r\n| Paragraph     |    Text     |    And more |\r\n| Strikethrough |             |    ~~Text~~ |\n\n| Feature       | Documentation Link |                    Notes |\r\n| :------------ | :----------------: | -----------------------: |\r\n| **Feature A** |     [Docs](#)      | For more info click here |\r\n| **Feature B** |     [Guide](#)     |  See the full guide here |\r\n| **Feature C** |     [Setup](#)     |       Setup instructions |\n",
    "_searchMeta": {
      "cleanContent": "lorem ipsum dolor sit amet consectetur adipisicing elit numquam iste dolorum tempore consectetur explicabo tempora provident quia maxime molestiae facilis aperiam et error illum vel ullam quis architecto dolore ullam syntax description test text :------------ :---------: ----------: header title here s this paragraph text and more strikethrough text feature documentation link notes :------------ :----------------: -----------------------: feature a docs for more info click here feature b guide see the full guide here feature c setup setup instructions",
      "headings": [],
      "keywords": [
        "Feature A",
        "Feature B",
        "Feature C"
      ]
    }
  },
  {
    "slug": "/markdown/tabs",
    "title": "Tabs",
    "description": "This section provides an overview of Introduction.",
    "content": "Lorem ipsum dolor sit amet consectetur adipisicing elit. Numquam iste dolorum tempore consectetur explicabo tempora provident quia maxime, molestiae, facilis aperiam et, error illum vel ullam? Quis architecto dolore ullam\n\n## Code Examples with switch\n\nHere a custom tab component from shadcn ui is used.\n",
    "_searchMeta": {
      "cleanContent": "lorem ipsum dolor sit amet consectetur adipisicing elit numquam iste dolorum tempore consectetur explicabo tempora provident quia maxime molestiae facilis aperiam et error illum vel ullam quis architecto dolore ullam code examples with switch here a custom tab component from shadcn ui is used",
      "headings": [
        "Code Examples with switch"
      ],
      "keywords": [
        "Code Examples with switch"
      ]
    }
  },
  {
    "slug": "/navigation",
    "title": "Navigation",
    "description": "How to build our your documents menu and navigations.",
    "content": "",
    "_searchMeta": {
      "cleanContent": "",
      "headings": [],
      "keywords": [
        "navigation",
        "sidebar",
        "menus",
        "mdx",
        "nextjs",
        "documents"
      ]
    }
  },
  {
    "slug": "/quickstart/chat-integration",
    "title": "Integrate AUTOUI Chat into Your App",
    "description": "End-to-end guide for adding the ModalChat assistant to your React or Next.js application.",
    "content": "This guide walks you through **everything you need** to integrate the AUTOUI chat (`ModalChat`) into your app.\n\nIt covers:\n\n* React apps (Create React App, Vite, etc.)\n* Next.js (App Router and Pages Router)\n* Required config, environment variables, and best practices\n\n> This documentation site **does not mount** the chat globally anymore.\\\n> Use the examples below to wire it into **your own app**.\n\n## 1. Install the library\n\n```bash\nnpm install @autoai-ui/autoui\n```\n\nYou can also use `pnpm` or `yarn` if that’s what your project uses.\n\n## 2. Create your `AutoUIConfig`\n\nAt the core of AUTOUI is the `AutoUIConfig` object.\\\nIt tells the assistant how to talk to your backend, which functions it can call, and which components it can render.\n\nCreate a config file in your project:\n\n```tsx\n// lib/autoui-config.ts (React) or lib/autoui-config.tsx (Next.js)\nimport type { AutoUIConfig } from \"@autoai-ui/autoui\"\n\nexport function createAutoUIConfig(): AutoUIConfig {\n  return {\n    appId: \"my-app\",\n    llm: {\n      // Proxy that talks to your LLM provider\n      proxyUrl: process.env.NEXT_PUBLIC_PROXY_URL || \"http://localhost:3001\",\n      sharedSecret: process.env.NEXT_PUBLIC_AUTOUI_SHARED_SECRET,\n      temperature: 0.3,\n    },\n    runtime: {\n      validateLLMOutput: true,\n      storeChatToLocalStorage: true,\n      localStorageKey: \"autoui_chat\",\n      maxSteps: 20,\n    },\n    // Optional: register functions and components here\n    // functions: { ... }\n    // components: { ... }\n  }\n}\n```\n\nFor a deeper breakdown of every field, see the [AutoUIConfig reference](/docs/reference/autouiconfig).\n\n## 3. Environment variables\n\nYou need at least:\n\n* A proxy URL that forwards requests to your LLM provider\n* A shared secret used to authenticate from the browser to your proxy\n\n### React (.env)\n\n```bash\nREACT_APP_PROXY_URL=http://localhost:3001\nREACT_APP_AUTOUI_SHARED_SECRET=your-secret\n```\n\nUpdate your config to read from `REACT_APP_*` for CRA or `VITE_*` for Vite (see the [React quick start](/docs/quickstart/react) for exact examples).\n\n### Next.js (.env.local)\n\n```bash\nNEXT_PUBLIC_PROXY_URL=http://localhost:3001\nNEXT_PUBLIC_AUTOUI_SHARED_SECRET=your-secret\n```\n\nThese `NEXT_PUBLIC_*` variables are available in the browser, which is required for the chat to talk to your proxy.\n\nFor how to run the proxy itself, see [Backend Proxy Installation & Configuration](/docs/backend-proxy).\n\n## 4. Integrate in a React app\n\nThis is the simplest integration.\n\n```tsx\n// src/App.tsx (or your main component)\nimport { ModalChat } from \"@autoai-ui/autoui\"\nimport { createAutoUIConfig } from \"./lib/autoui-config\"\n\nexport default function App() {\n  const config = createAutoUIConfig()\n\n  return (\n    <div className=\"App\">\n      {/* Your existing app UI */}\n      <h1>My React App</h1>\n\n      {/* AUTOUI chat assistant */}\n      <ModalChat config={config} />\n    </div>\n  )\n}\n```\n\nWhen the app loads, you’ll see a floating chat button in the bottom-right corner.\\\nClick it to open the chat and start talking to your assistant.\n\nFor a step-by-step React-only flow, see the [React Quick Start](/docs/quickstart/react).\n\n## 5. Integrate in a Next.js app\n\nNext.js has **SSR** (server‑side rendering), so `ModalChat` **must** be dynamically imported with `ssr: false`.\n\n### 5.1 Create a reusable `AutoUIChat` wrapper (recommended)\n\n```tsx\n// app/components/autoui-chat.tsx or components/autoui-chat.tsx\n\"use client\"\n\nimport { ModalChat } from \"@autoai-ui/autoui\"\nimport dynamic from \"next/dynamic\"\nimport { useRouter } from \"next/navigation\"\nimport { useMemo } from \"react\"\nimport { createAutoUIConfig } from \"@/lib/autoui-config\"\n\n// Disable SSR for ModalChat\nconst DynamicModalChat = dynamic(\n  () => Promise.resolve(ModalChat),\n  { ssr: false }\n)\n\nexport function AutoUIChat() {\n  const router = useRouter()\n\n  const config = useMemo(\n    () => createAutoUIConfig(router),\n    [router]\n  )\n\n  return <DynamicModalChat config={config} />\n}\n```\n\nThis wrapper:\n\n* Marks the component as a **client** component\n* Uses `dynamic(..., { ssr: false })` to avoid SSR issues\n* Injects the Next.js `router` into your config so functions like `navigateToPage` can call `router.push(...)`\n\n### 5.2 App Router – mount globally in `app/layout.tsx`\n\n```tsx\n// app/layout.tsx\nimport type { Metadata } from \"next\"\nimport { AutoUIChat } from \"@/components/autoui-chat\"\n\nexport const metadata: Metadata = {\n  title: \"My App\",\n}\n\nexport default function RootLayout({\n  children,\n}: {\n  children: React.ReactNode\n}) {\n  return (\n    <html lang=\"en\">\n      <body>\n        {children}\n        {/* Global AUTOUI chat assistant */}\n        <AutoUIChat />\n      </body>\n    </html>\n  )\n}\n```\n\nNow the chat is available on every page of your Next.js app.\n\n### 5.3 Pages Router – mount in `_app.tsx`\n\n```tsx\n// pages/_app.tsx\nimport type { AppProps } from \"next/app\"\nimport { AutoUIChat } from \"@/components/autoui-chat\"\n\nexport default function App({ Component, pageProps }: AppProps) {\n  return (\n    <>\n      <Component {...pageProps} />\n      <AutoUIChat />\n    </>\n  )\n}\n```\n\nFor more detailed Next.js patterns (server actions, middleware, etc.), see [Next.js Best Practices](/docs/best-practices/nextjs).\n\n## 6. Common gotchas\n\n* **Hydration errors in Next.js**\\\n  Make sure `ModalChat` is **only** used inside a client component and imported via `dynamic(..., { ssr: false })`.\n\n* **No responses / network errors**\\\n  Check that your **proxy URL** is correct and the server is running, and that the shared secret matches on both client and server.\n\n* **Config not updating**\\\n  If your config depends on props/state, wrap it in `useMemo` so it doesn’t recreate on every render.\n\n```tsx\nconst config = useMemo(\n  () => createAutoUIConfig(router),\n  [router]\n)\n```\n\n## 7. Where to go next\n\n* Full **Next.js quick start**: [Next.js Quick Start](/docs/quickstart/nextjs)\n* Full **React quick start**: [React Quick Start](/docs/quickstart/react)\n* Deep dive into **AutoUIConfig**: [AutoUIConfig Reference](/docs/reference/autouiconfig)\n* Learn more about **ModalChat** itself: [ModalChat Props Reference](/docs/reference/modalchat)\n",
    "_searchMeta": {
      "cleanContent": "this guide walks you through everything you need to integrate the autoui chat modalchat into your app it covers: react apps create react app vite etc next js app router and pages router required config environment variables and best practices this documentation site does not mount the chat globally anymore use the examples below to wire it into your own app install the library you can also use pnpm or yarn if that s what your project uses create your autouiconfig at the core of autoui is the autouiconfig object it tells the assistant how to talk to your backend which functions it can call and which components it can render create a config file in your project: for a deeper breakdown of every field see the autouiconfig reference environment variables you need at least: a proxy url that forwards requests to your llm provider a shared secret used to authenticate from the browser to your proxy react env update your config to read from reactapp for cra or vite_ for vite see the react quick start for exact examples next js env local these nextpublic variables are available in the browser which is required for the chat to talk to your proxy for how to run the proxy itself see backend proxy installation configuration integrate in a react app this is the simplest integration when the app loads you ll see a floating chat button in the bottom-right corner click it to open the chat and start talking to your assistant for a step-by-step react-only flow see the react quick start integrate in a next js app next js has ssr server side rendering so modalchat must be dynamically imported with ssr: false 5 1 create a reusable autouichat wrapper recommended this wrapper: marks the component as a client component uses dynamic ssr: false to avoid ssr issues injects the next js router into your config so functions like navigatetopage can call router push 5 2 app router mount globally in app layout tsx now the chat is available on every page of your next js app 5 3 pages router mount in _app tsx for more detailed next js patterns server actions middleware etc see next js best practices common gotchas hydration errors in next js make sure modalchat is only used inside a client component and imported via dynamic ssr: false no responses network errors check that your proxy url is correct and the server is running and that the shared secret matches on both client and server config not updating if your config depends on props state wrap it in usememo so it doesn t recreate on every render where to go next full next js quick start: next js quick start full react quick start: react quick start deep dive into autouiconfig: autouiconfig reference learn more about modalchat itself: modalchat props reference",
      "headings": [
        "1. Install the library",
        "2. Create your `AutoUIConfig`",
        "3. Environment variables",
        "4. Integrate in a React app",
        "5. Integrate in a Next.js app",
        "6. Common gotchas",
        "7. Where to go next"
      ],
      "keywords": [
        "autoui",
        "chat",
        "integration",
        "modalchat",
        "react",
        "nextjs",
        "quickstart",
        "1. Install the library",
        "2. Create your `AutoUIConfig`",
        "3. Environment variables",
        "4. Integrate in a React app",
        "5. Integrate in a Next.js app",
        "6. Common gotchas",
        "7. Where to go next",
        "everything you need",
        "does not mount",
        "your own app",
        "SSR",
        "must",
        "client",
        "Hydration errors in Next.js",
        "only",
        "No responses / network errors",
        "proxy URL",
        "Config not updating",
        "Next.js quick start",
        "React quick start",
        "AutoUIConfig",
        "ModalChat",
        "bash\nnpm install @autoai-ui/autoui",
        "You can also use",
        "or",
        "if that’s what your project uses.\n\n## 2. Create your",
        "At the core of AUTOUI is the",
        "object.\\\nIt tells the assistant how to talk to your backend, which functions it can call, and which components it can render.\n\nCreate a config file in your project:",
        "tsx\n// lib/autoui-config.ts (React) or lib/autoui-config.tsx (Next.js)\nimport type { AutoUIConfig } from \"@autoai-ui/autoui\"\n\nexport function createAutoUIConfig(): AutoUIConfig {\n  return {\n    appId: \"my-app\",\n    llm: {\n      // Proxy that talks to your LLM provider\n      proxyUrl: process.env.NEXT_PUBLIC_PROXY_URL || \"http://localhost:3001\",\n      sharedSecret: process.env.NEXT_PUBLIC_AUTOUI_SHARED_SECRET,\n      temperature: 0.3,\n    },\n    runtime: {\n      validateLLMOutput: true,\n      storeChatToLocalStorage: true,\n      localStorageKey: \"autoui_chat\",\n      maxSteps: 20,\n    },\n    // Optional: register functions and components here\n    // functions: { ... }\n    // components: { ... }\n  }\n}",
        "For a deeper breakdown of every field, see the [AutoUIConfig reference](/docs/reference/autouiconfig).\n\n## 3. Environment variables\n\nYou need at least:\n\n* A proxy URL that forwards requests to your LLM provider\n* A shared secret used to authenticate from the browser to your proxy\n\n### React (.env)",
        "bash\nREACT_APP_PROXY_URL=http://localhost:3001\nREACT_APP_AUTOUI_SHARED_SECRET=your-secret",
        "Update your config to read from",
        "for CRA or",
        "for Vite (see the [React quick start](/docs/quickstart/react) for exact examples).\n\n### Next.js (.env.local)",
        "bash\nNEXT_PUBLIC_PROXY_URL=http://localhost:3001\nNEXT_PUBLIC_AUTOUI_SHARED_SECRET=your-secret",
        "These",
        "variables are available in the browser, which is required for the chat to talk to your proxy.\n\nFor how to run the proxy itself, see [Backend Proxy Installation & Configuration](/docs/backend-proxy).\n\n## 4. Integrate in a React app\n\nThis is the simplest integration.",
        "tsx\n// src/App.tsx (or your main component)\nimport { ModalChat } from \"@autoai-ui/autoui\"\nimport { createAutoUIConfig } from \"./lib/autoui-config\"\n\nexport default function App() {\n  const config = createAutoUIConfig()\n\n  return (\n    <div className=\"App\">\n      {/* Your existing app UI */}\n      <h1>My React App</h1>\n\n      {/* AUTOUI chat assistant */}\n      <ModalChat config={config} />\n    </div>\n  )\n}",
        "When the app loads, you’ll see a floating chat button in the bottom-right corner.\\\nClick it to open the chat and start talking to your assistant.\n\nFor a step-by-step React-only flow, see the [React Quick Start](/docs/quickstart/react).\n\n## 5. Integrate in a Next.js app\n\nNext.js has **SSR** (server‑side rendering), so",
        "**must** be dynamically imported with",
        ".\n\n### 5.1 Create a reusable",
        "wrapper (recommended)",
        "tsx\n// app/components/autoui-chat.tsx or components/autoui-chat.tsx\n\"use client\"\n\nimport { ModalChat } from \"@autoai-ui/autoui\"\nimport dynamic from \"next/dynamic\"\nimport { useRouter } from \"next/navigation\"\nimport { useMemo } from \"react\"\nimport { createAutoUIConfig } from \"@/lib/autoui-config\"\n\n// Disable SSR for ModalChat\nconst DynamicModalChat = dynamic(\n  () => Promise.resolve(ModalChat),\n  { ssr: false }\n)\n\nexport function AutoUIChat() {\n  const router = useRouter()\n\n  const config = useMemo(\n    () => createAutoUIConfig(router),\n    [router]\n  )\n\n  return <DynamicModalChat config={config} />\n}",
        "This wrapper:\n\n* Marks the component as a **client** component\n* Uses",
        "to avoid SSR issues\n* Injects the Next.js",
        "into your config so functions like",
        "can call",
        "### 5.2 App Router – mount globally in",
        "",
        "tsx\n// app/layout.tsx\nimport type { Metadata } from \"next\"\nimport { AutoUIChat } from \"@/components/autoui-chat\"\n\nexport const metadata: Metadata = {\n  title: \"My App\",\n}\n\nexport default function RootLayout({\n  children,\n}: {\n  children: React.ReactNode\n}) {\n  return (\n    <html lang=\"en\">\n      <body>\n        {children}\n        {/* Global AUTOUI chat assistant */}\n        <AutoUIChat />\n      </body>\n    </html>\n  )\n}",
        "Now the chat is available on every page of your Next.js app.\n\n### 5.3 Pages Router – mount in",
        "tsx\n// pages/_app.tsx\nimport type { AppProps } from \"next/app\"\nimport { AutoUIChat } from \"@/components/autoui-chat\"\n\nexport default function App({ Component, pageProps }: AppProps) {\n  return (\n    <>\n      <Component {...pageProps} />\n      <AutoUIChat />\n    </>\n  )\n}",
        "For more detailed Next.js patterns (server actions, middleware, etc.), see [Next.js Best Practices](/docs/best-practices/nextjs).\n\n## 6. Common gotchas\n\n* **Hydration errors in Next.js**\\\n  Make sure",
        "is **only** used inside a client component and imported via",
        ".\n\n* **No responses / network errors**\\\n  Check that your **proxy URL** is correct and the server is running, and that the shared secret matches on both client and server.\n\n* **Config not updating**\\\n  If your config depends on props/state, wrap it in",
        "so it doesn’t recreate on every render.",
        "tsx\nconst config = useMemo(\n  () => createAutoUIConfig(router),\n  [router]\n)"
      ]
    }
  },
  {
    "slug": "/quickstart",
    "title": "Quick Start",
    "description": "Get started with AUTOUI in minutes. Choose your framework and follow the quick setup guide.",
    "content": "Welcome to AUTOUI! This guide will help you get up and running quickly.\n\n## Choose Your Framework\n\nAUTOUI works with any React-based framework. Select your framework to see the specific setup instructions:\n\n* **[React Quick Start](/docs/quickstart/react)** - For Create React App, Vite, or any React application\n* **[Next.js Quick Start](/docs/quickstart/nextjs)** - For Next.js applications (App Router or Pages Router)\n\n## What You'll Need\n\nBefore you begin, make sure you have:\n\n* Node.js 16+ installed\n* A React application (or create one)\n* A backend proxy server (see [Backend Proxy Installation](/docs/backend-proxy) for setup)\n\n## Quick Overview\n\nAUTOUI integration involves three main steps:\n\n1. **Install the package** - Add `@autoai-ui/autoui` to your project\n2. **Create a config** - Define your app's capabilities in an `AutoUIConfig` object\n3. **Add ModalChat** - Import and render the `<ModalChat>` component\n\nReady to get started? Choose your framework above!\n",
    "_searchMeta": {
      "cleanContent": "welcome to autoui this guide will help you get up and running quickly choose your framework autoui works with any react-based framework select your framework to see the specific setup instructions: react quick start - for create react app vite or any react application next js quick start - for next js applications app router or pages router what you ll need before you begin make sure you have: node js 16 installed a react application or create one a backend proxy server see backend proxy installation for setup quick overview autoui integration involves three main steps: install the package - add autoai-ui autoui to your project create a config - define your app s capabilities in an autouiconfig object add modalchat - import and render the modalchat component ready to get started choose your framework above",
      "headings": [
        "Choose Your Framework",
        "What You'll Need",
        "Quick Overview"
      ],
      "keywords": [
        "quickstart",
        "getting started",
        "setup",
        "react",
        "nextjs",
        "Choose Your Framework",
        "What You'll Need",
        "Quick Overview",
        "[React Quick Start](/docs/quickstart/react)",
        "[Next.js Quick Start](/docs/quickstart/nextjs)",
        "Install the package",
        "Create a config",
        "Add ModalChat",
        "@autoai-ui/autoui",
        "AutoUIConfig",
        "<ModalChat>"
      ]
    }
  },
  {
    "slug": "/quickstart/nextjs",
    "title": "Next.js Quick Start",
    "description": "Get AUTOUI running in your Next.js app in under 5 minutes. Step-by-step guide for Next.js applications.",
    "content": "This guide will help you integrate AUTOUI into your Next.js application quickly.\n\n## Prerequisites\n\n* A Next.js application (App Router or Pages Router)\n* Node.js 16 or higher\n* A backend proxy server (see [Backend Proxy Setup](/docs/backend-proxy))\n\n## Step 1: Install AUTOUI\n\n```bash\nnpm install @autoai-ui/autoui\n```\n\n## Step 2: Create Your Config\n\nCreate a new file `lib/autoui-config.tsx` (note the `.tsx` extension):\n\n```tsx\n\"use client\"\n\nimport { AutoUIConfig } from \"@autoai-ui/autoui\"\n\nexport function createAutoUIConfig(): AutoUIConfig {\n  return {\n    appId: 'my-nextjs-app',\n    llm: {\n      proxyUrl: process.env.NEXT_PUBLIC_PROXY_URL || 'http://localhost:3001',\n      sharedSecret: process.env.NEXT_PUBLIC_SHARED_SECRET,\n    },\n    runtime: {\n      validateLLMOutput: true,\n      storeChatToLocalStorage: true,\n      maxSteps: 10,\n    },\n  }\n}\n```\n\n## Step 3: Add Environment Variables\n\nCreate or update your `.env.local` file:\n\n```bash\nNEXT_PUBLIC_PROXY_URL=http://localhost:3001\nNEXT_PUBLIC_SHARED_SECRET=your-secret-key-here\n```\n\n## Step 4: Add ModalChat to Your Layout\n\n### For App Router (app directory)\n\nCreate or update `app/layout.tsx`:\n\n```tsx\nimport dynamic from \"next/dynamic\"\nimport { createAutoUIConfig } from \"@/lib/autoui-config\"\n\n// Dynamic import with SSR disabled (required!)\nconst ModalChat = dynamic(\n  () => import(\"@autoai-ui/autoui\").then((mod) => mod.ModalChat),\n  { ssr: false }\n)\n\nexport default function RootLayout({\n  children,\n}: {\n  children: React.ReactNode\n}) {\n  const config = createAutoUIConfig()\n\n  return (\n    <html lang=\"en\">\n      <body>\n        {children}\n        <ModalChat config={config} />\n      </body>\n    </html>\n  )\n}\n```\n\n### For Pages Router (pages directory)\n\nCreate or update `pages/_app.tsx`:\n\n```tsx\nimport dynamic from \"next/dynamic\"\nimport { createAutoUIConfig } from \"@/lib/autoui-config\"\nimport type { AppProps } from \"next/app\"\n\n// Dynamic import with SSR disabled (required!)\nconst ModalChat = dynamic(\n  () => import(\"@autoai-ui/autoui\").then((mod) => mod.ModalChat),\n  { ssr: false }\n)\n\nexport default function App({ Component, pageProps }: AppProps) {\n  const config = createAutoUIConfig()\n\n  return (\n    <>\n      <Component {...pageProps} />\n      <ModalChat config={config} />\n    </>\n  )\n}\n```\n\n## Step 5: Start Your App\n\n```bash\nnpm run dev\n```\n\nYou should now see a floating chat button in the bottom-right corner of your app!\n\n## Next Steps\n\n* Learn about [configuration options](/docs/config)\n* Add [functions and components](/docs/functions) to extend capabilities\n* Check out [Next.js best practices](/docs/best-practices/nextjs)\n\n## Troubleshooting\n\nIf you encounter issues:\n\n* Make sure your backend proxy server is running\n* Verify your environment variables are set correctly (must use `NEXT_PUBLIC_` prefix)\n* Ensure ModalChat is dynamically imported with `ssr: false`\n* Check the browser console for error messages\n* See the [Troubleshooting guide](/docs/troubleshooting)\n",
    "_searchMeta": {
      "cleanContent": "this guide will help you integrate autoui into your next js application quickly prerequisites a next js application app router or pages router node js 16 or higher a backend proxy server see backend proxy setup step 1: install autoui step 2: create your config create a new file lib autoui-config tsx note the tsx extension : step 3: add environment variables create or update your env local file: step 4: add modalchat to your layout for app router app directory create or update app layout tsx: for pages router pages directory create or update pages _app tsx: step 5: start your app you should now see a floating chat button in the bottom-right corner of your app next steps learn about configuration options add functions and components to extend capabilities check out next js best practices troubleshooting if you encounter issues: make sure your backend proxy server is running verify your environment variables are set correctly must use nextpublic prefix ensure modalchat is dynamically imported with ssr: false check the browser console for error messages see the troubleshooting guide",
      "headings": [
        "Prerequisites",
        "Step 1: Install AUTOUI",
        "Step 2: Create Your Config",
        "Step 3: Add Environment Variables",
        "Step 4: Add ModalChat to Your Layout",
        "Step 5: Start Your App",
        "Next Steps",
        "Troubleshooting"
      ],
      "keywords": [
        "nextjs",
        "next.js",
        "quickstart",
        "getting started",
        "app router",
        "pages router",
        "Prerequisites",
        "Step 1: Install AUTOUI",
        "Step 2: Create Your Config",
        "Step 3: Add Environment Variables",
        "Step 4: Add ModalChat to Your Layout",
        "Step 5: Start Your App",
        "Next Steps",
        "Troubleshooting",
        "bash\nnpm install @autoai-ui/autoui",
        "## Step 2: Create Your Config\n\nCreate a new file",
        "(note the",
        "extension):",
        "tsx\n\"use client\"\n\nimport { AutoUIConfig } from \"@autoai-ui/autoui\"\n\nexport function createAutoUIConfig(): AutoUIConfig {\n  return {\n    appId: 'my-nextjs-app',\n    llm: {\n      proxyUrl: process.env.NEXT_PUBLIC_PROXY_URL || 'http://localhost:3001',\n      sharedSecret: process.env.NEXT_PUBLIC_SHARED_SECRET,\n    },\n    runtime: {\n      validateLLMOutput: true,\n      storeChatToLocalStorage: true,\n      maxSteps: 10,\n    },\n  }\n}",
        "## Step 3: Add Environment Variables\n\nCreate or update your",
        "file:",
        "bash\nNEXT_PUBLIC_PROXY_URL=http://localhost:3001\nNEXT_PUBLIC_SHARED_SECRET=your-secret-key-here",
        "## Step 4: Add ModalChat to Your Layout\n\n### For App Router (app directory)\n\nCreate or update",
        ":",
        "tsx\nimport dynamic from \"next/dynamic\"\nimport { createAutoUIConfig } from \"@/lib/autoui-config\"\n\n// Dynamic import with SSR disabled (required!)\nconst ModalChat = dynamic(\n  () => import(\"@autoai-ui/autoui\").then((mod) => mod.ModalChat),\n  { ssr: false }\n)\n\nexport default function RootLayout({\n  children,\n}: {\n  children: React.ReactNode\n}) {\n  const config = createAutoUIConfig()\n\n  return (\n    <html lang=\"en\">\n      <body>\n        {children}\n        <ModalChat config={config} />\n      </body>\n    </html>\n  )\n}",
        "### For Pages Router (pages directory)\n\nCreate or update",
        "tsx\nimport dynamic from \"next/dynamic\"\nimport { createAutoUIConfig } from \"@/lib/autoui-config\"\nimport type { AppProps } from \"next/app\"\n\n// Dynamic import with SSR disabled (required!)\nconst ModalChat = dynamic(\n  () => import(\"@autoai-ui/autoui\").then((mod) => mod.ModalChat),\n  { ssr: false }\n)\n\nexport default function App({ Component, pageProps }: AppProps) {\n  const config = createAutoUIConfig()\n\n  return (\n    <>\n      <Component {...pageProps} />\n      <ModalChat config={config} />\n    </>\n  )\n}",
        "## Step 5: Start Your App",
        "bash\nnpm run dev",
        "You should now see a floating chat button in the bottom-right corner of your app!\n\n## Next Steps\n\n* Learn about [configuration options](/docs/config)\n* Add [functions and components](/docs/functions) to extend capabilities\n* Check out [Next.js best practices](/docs/best-practices/nextjs)\n\n## Troubleshooting\n\nIf you encounter issues:\n\n* Make sure your backend proxy server is running\n* Verify your environment variables are set correctly (must use",
        "prefix)\n* Ensure ModalChat is dynamically imported with"
      ]
    }
  },
  {
    "slug": "/quickstart/react",
    "title": "React Quick Start",
    "description": "Get AUTOUI running in your React app in under 5 minutes. Step-by-step guide for React applications.",
    "content": "This guide will help you integrate AUTOUI into your React application quickly.\n\n## Prerequisites\n\n* A React application (Create React App, Vite, or any React setup)\n* Node.js 16 or higher\n* A backend proxy server (see [Backend Proxy Setup](/docs/backend-proxy))\n\n## Step 1: Install AUTOUI\n\n```bash\nnpm install @autoai-ui/autoui\n```\n\n## Step 2: Configure Vite Plugin (Vite projects only)\n\nIf you're using Vite, add the AutoUI type schema plugin to your `vite.config.ts`:\n\n```typescript\nimport { defineConfig } from 'vite';\nimport react from '@vitejs/plugin-react';\nimport { autouiTypeSchemaPlugin } from '@autoai-ui/autoui/plugin';\n\nexport default defineConfig({\n  plugins: [\n    react(),\n    autouiTypeSchemaPlugin(),\n  ],\n});\n```\n\nThis plugin generates a `.autoui-runtime-schema.json` file during development builds. Skip this step if you're using Create React App.\n\n## Step 3: Create Your Config\n\nCreate a new file `lib/autoui-config.ts`:\n\n**For Vite projects:**\n\n```tsx\nimport type { AutoUIConfig } from '@autoai-ui/autoui';\n\nexport const autouiConfig: AutoUIConfig = {\n  appId: import.meta.env.AUTOUI_APP_ID || 'my-react-app',\n  llm: {\n    proxyUrl: import.meta.env.VITE_BASE_URL || 'http://localhost:3001',\n    sharedSecret: import.meta.env.VITE_AUTOUI_SHARED_SECRET,\n  },\n  runtime: {\n    validateLLMOutput: true,\n    storeChatToLocalStorage: true,\n    maxSteps: 10,\n  },\n};\n```\n\n**For Create React App:**\n\n```tsx\nimport { AutoUIConfig } from \"@autoai-ui/autoui\"\n\nexport function createAutoUIConfig(): AutoUIConfig {\n  return {\n    appId: process.env.REACT_APP_APP_ID || 'my-react-app',\n    llm: {\n      proxyUrl: process.env.REACT_APP_PROXY_URL || 'http://localhost:3001',\n      sharedSecret: process.env.REACT_APP_SHARED_SECRET,\n    },\n    runtime: {\n      validateLLMOutput: true,\n      storeChatToLocalStorage: true,\n      maxSteps: 10,\n    },\n  }\n}\n```\n\n## Step 4: Add Environment Variables\n\nCreate or update your `.env` file:\n\n**For Vite projects:**\n\n```bash\nAUTOUI_APP_ID=your-app-id\nVITE_BASE_URL=http://localhost:3001\nVITE_AUTOUI_SHARED_SECRET=your-secret-key-here\n```\n\n**For Create React App:**\n\n```bash\nREACT_APP_APP_ID=your-app-id\nREACT_APP_PROXY_URL=http://localhost:3001\nREACT_APP_SHARED_SECRET=your-secret-key-here\n```\n\n## Step 5: Add ModalChat to Your App\n\nImport and render the ModalChat component in your main app file:\n\n```tsx\n// App.tsx or your main component\nimport { ModalChat } from \"@autoai-ui/autoui\"\nimport { createAutoUIConfig } from \"./lib/autoui-config\"\n\nfunction App() {\n  const config = createAutoUIConfig()\n\n  return (\n    <div className=\"App\">\n      <h1>My React App</h1>\n      {/* Your app content */}\n      \n      <ModalChat config={config} />\n    </div>\n  )\n}\n\nexport default App\n```\n\n## Step 6: Start Your App\n\n```bash\nnpm start\n```\n\nYou should now see a floating chat button in the bottom-right corner of your app!\n\n## Next Steps\n\n* Read the [Complete Developer Guide](/docs/developer-guide) for comprehensive setup instructions\n* Learn about [configuration options](/docs/config)\n* Add [functions and components](/docs/functions) to extend capabilities\n* Check out [React best practices](/docs/best-practices/react)\n\n## Troubleshooting\n\nIf you encounter issues:\n\n* Make sure your backend proxy server is running\n* Verify your environment variables are set correctly\n* Check the browser console for error messages\n* See the [Troubleshooting guide](/docs/troubleshooting)\n",
    "_searchMeta": {
      "cleanContent": "this guide will help you integrate autoui into your react application quickly prerequisites a react application create react app vite or any react setup node js 16 or higher a backend proxy server see backend proxy setup step 1: install autoui step 2: configure vite plugin vite projects only if you re using vite add the autoui type schema plugin to your vite config ts: this plugin generates a autoui-runtime-schema json file during development builds skip this step if you re using create react app step 3: create your config create a new file lib autoui-config ts: for vite projects: for create react app: step 4: add environment variables create or update your env file: for vite projects: for create react app: step 5: add modalchat to your app import and render the modalchat component in your main app file: step 6: start your app you should now see a floating chat button in the bottom-right corner of your app next steps read the complete developer guide for comprehensive setup instructions learn about configuration options add functions and components to extend capabilities check out react best practices troubleshooting if you encounter issues: make sure your backend proxy server is running verify your environment variables are set correctly check the browser console for error messages see the troubleshooting guide",
      "headings": [
        "Prerequisites",
        "Step 1: Install AUTOUI",
        "Step 2: Configure Vite Plugin (Vite projects only)",
        "Step 3: Create Your Config",
        "Step 4: Add Environment Variables",
        "Step 5: Add ModalChat to Your App",
        "Step 6: Start Your App",
        "Next Steps",
        "Troubleshooting"
      ],
      "keywords": [
        "react",
        "quickstart",
        "getting started",
        "create react app",
        "vite",
        "Prerequisites",
        "Step 1: Install AUTOUI",
        "Step 2: Configure Vite Plugin (Vite projects only)",
        "Step 3: Create Your Config",
        "Step 4: Add Environment Variables",
        "Step 5: Add ModalChat to Your App",
        "Step 6: Start Your App",
        "Next Steps",
        "Troubleshooting",
        "For Vite projects:",
        "For Create React App:",
        "bash\nnpm install @autoai-ui/autoui",
        "## Step 2: Configure Vite Plugin (Vite projects only)\n\nIf you're using Vite, add the AutoUI type schema plugin to your",
        ":",
        "typescript\nimport { defineConfig } from 'vite';\nimport react from '@vitejs/plugin-react';\nimport { autouiTypeSchemaPlugin } from '@autoai-ui/autoui/plugin';\n\nexport default defineConfig({\n  plugins: [\n    react(),\n    autouiTypeSchemaPlugin(),\n  ],\n});",
        "This plugin generates a",
        "file during development builds. Skip this step if you're using Create React App.\n\n## Step 3: Create Your Config\n\nCreate a new file",
        ":\n\n**For Vite projects:**",
        "tsx\nimport type { AutoUIConfig } from '@autoai-ui/autoui';\n\nexport const autouiConfig: AutoUIConfig = {\n  appId: import.meta.env.AUTOUI_APP_ID || 'my-react-app',\n  llm: {\n    proxyUrl: import.meta.env.VITE_BASE_URL || 'http://localhost:3001',\n    sharedSecret: import.meta.env.VITE_AUTOUI_SHARED_SECRET,\n  },\n  runtime: {\n    validateLLMOutput: true,\n    storeChatToLocalStorage: true,\n    maxSteps: 10,\n  },\n};",
        "**For Create React App:**",
        "tsx\nimport { AutoUIConfig } from \"@autoai-ui/autoui\"\n\nexport function createAutoUIConfig(): AutoUIConfig {\n  return {\n    appId: process.env.REACT_APP_APP_ID || 'my-react-app',\n    llm: {\n      proxyUrl: process.env.REACT_APP_PROXY_URL || 'http://localhost:3001',\n      sharedSecret: process.env.REACT_APP_SHARED_SECRET,\n    },\n    runtime: {\n      validateLLMOutput: true,\n      storeChatToLocalStorage: true,\n      maxSteps: 10,\n    },\n  }\n}",
        "## Step 4: Add Environment Variables\n\nCreate or update your",
        "file:\n\n**For Vite projects:**",
        "bash\nAUTOUI_APP_ID=your-app-id\nVITE_BASE_URL=http://localhost:3001\nVITE_AUTOUI_SHARED_SECRET=your-secret-key-here",
        "bash\nREACT_APP_APP_ID=your-app-id\nREACT_APP_PROXY_URL=http://localhost:3001\nREACT_APP_SHARED_SECRET=your-secret-key-here",
        "## Step 5: Add ModalChat to Your App\n\nImport and render the ModalChat component in your main app file:",
        "tsx\n// App.tsx or your main component\nimport { ModalChat } from \"@autoai-ui/autoui\"\nimport { createAutoUIConfig } from \"./lib/autoui-config\"\n\nfunction App() {\n  const config = createAutoUIConfig()\n\n  return (\n    <div className=\"App\">\n      <h1>My React App</h1>\n      {/* Your app content */}\n      \n      <ModalChat config={config} />\n    </div>\n  )\n}\n\nexport default App",
        "## Step 6: Start Your App",
        "bash\nnpm start"
      ]
    }
  },
  {
    "slug": "/random",
    "title": "Introduction",
    "description": "This section provides an overview of Introduction.",
    "content": "Lorem ipsum dolor sit amet consectetur adipisicing elit. Numquam iste dolorum tempore consectetur explicabo tempora provident quia maxime, molestiae, facilis aperiam et, error illum vel ullam? Quis architecto dolore ullam\n\n* \\[x] Write the press release\n* \\[ ] Update the website\n* \\[ ] Contact the media\n\n| Syntax        | Description |   Test Text |\r\n| :------------ | :---------: | ----------: |\r\n| Header        |    Title    | Here's this |\r\n| Paragraph     |    Text     |    And more |\r\n| Strikethrough |             |    ~~Text~~ |\n\n## Getting Started\n\nTo begin using the Documentation Template, follow these simple steps:\n\n* Start by cloning the repository to your local machine.\n\nLorem ipsum dolor sit amet consectetur adipisicing elit. Reprehenderit quae iure nulla deserunt dolore quam pariatur minus sapiente accusantium. Optio, necessitatibus sequi. Veritatis, aspernatur? Possimus quis repellat eum vitae eveniet.\n\n## Blockquotes\n\nBlockquotes are useful for emphasizing key points or quoting external sources:\n\n> \"Documentation is a love letter that you write to your future self.\" - Damian Conway\n\nFeel free to use blockquotes to highlight important information or quotes relevant to your documentation.\n\n## Code Examples with switch\n\nHere a custom tab component from shadcn ui is used.\n\n## Conclusion\n\nAdding some random stuff to change the code\n",
    "_searchMeta": {
      "cleanContent": "lorem ipsum dolor sit amet consectetur adipisicing elit numquam iste dolorum tempore consectetur explicabo tempora provident quia maxime molestiae facilis aperiam et error illum vel ullam quis architecto dolore ullam x write the press release update the website contact the media syntax description test text :------------ :---------: ----------: header title here s this paragraph text and more strikethrough text getting started to begin using the documentation template follow these simple steps: start by cloning the repository to your local machine lorem ipsum dolor sit amet consectetur adipisicing elit reprehenderit quae iure nulla deserunt dolore quam pariatur minus sapiente accusantium optio necessitatibus sequi veritatis aspernatur possimus quis repellat eum vitae eveniet blockquotes blockquotes are useful for emphasizing key points or quoting external sources: documentation is a love letter that you write to your future self - damian conway feel free to use blockquotes to highlight important information or quotes relevant to your documentation code examples with switch here a custom tab component from shadcn ui is used conclusion adding some random stuff to change the code",
      "headings": [
        "Getting Started",
        "Blockquotes",
        "Code Examples with switch",
        "Conclusion"
      ],
      "keywords": [
        "Getting Started",
        "Blockquotes",
        "Code Examples with switch",
        "Conclusion"
      ]
    }
  },
  {
    "slug": "/reference/autouiconfig",
    "title": "AutoUIConfig Reference",
    "description": "Complete reference for the AutoUIConfig type, including all fields, types, and options.",
    "content": "Complete reference for the `AutoUIConfig` type.\n\n## Type Definition\n\n```tsx\nimport { AutoUIConfig } from \"@autoai-ui/autoui\"\n```\n\n## Top-Level Fields\n\n### `appId` (required)\n\n**Type:** `string`\n\nUnique identifier for your application.\n\n```tsx\nappId: 'tasks-demo'\n```\n\nUsed for:\n\n* Logging and analytics\n* localStorage keys (if not overridden)\n* Error tracking\n\n### `metadata` (optional)\n\n**Type:** `AutoUIMetadata`\n\nApplication metadata that describes your app to the LLM. This is optional but recommended for better LLM understanding.\n\n```tsx\nmetadata: {\n  appName: string\n  appVersion?: string\n  author?: string\n  createdAt?: string // ISO timestamp\n  description?: string // Detailed description for LLM\n  tags?: string[]\n}\n```\n\n**Fields:**\n\n* `appName`: Display name of your application (required)\n* `appVersion`: Version string (e.g., \"1.0.0\") (optional)\n* `author`: Author or team name (optional)\n* `createdAt`: ISO 8601 timestamp (optional)\n* `description`: Detailed description that tells the LLM what your app does (optional but recommended)\n* `tags`: Array of tags for categorization (optional)\n\n### `llm` (required)\n\n**Type:** `LLMConfig`\n\nLLM provider configuration.\n\n```tsx\nllm: {\n  proxyUrl: string              // Required: Backend proxy URL\n  sharedSecret?: string          // Optional: Shared secret for proxy auth\n  provider?: string              // Optional: LLM provider (informational)\n  model?: string                 // Optional: Model hint (actual model enforced by proxy)\n  temperature?: number           // Optional: Sampling temperature (0.0-2.0), default: 0.2\n  maxTokens?: number             // Optional: Max tokens hint, default: 2048\n  appDescriptionPrompt?: string  // Optional: App description context\n  requestHeaders?: Record<string, string> // Optional: Headers forwarded to proxy\n}\n```\n\n**Required fields:**\n\n* `proxyUrl`: URL of your proxy server (REQUIRED in production)\n\n**Optional fields:**\n\n* `sharedSecret`: Client key generated by proxy server (optional, for proxy auth)\n* `provider`: LLM provider name (informational, used by proxy)\n* `model`: Model hint (actual model enforced by proxy)\n* `temperature`: Randomness (0.0-2.0), default: 0.2\n* `maxTokens`: Maximum response length hint, default: 2048\n* `appDescriptionPrompt`: Concise description of app capabilities\n* `requestHeaders`: Optional headers forwarded to proxy\n\n### `runtime` (required)\n\n**Type:** `RuntimeConfig`\n\nRuntime execution configuration.\n\n```tsx\nruntime: {\n  validateLLMOutput?: boolean\n  storeChatToLocalStorage?: boolean\n  localStorageKey?: string\n  enableDebugLogs?: boolean\n  toolsSchema?: OpenAIToolSchema[]\n  maxSteps?: number\n  errorHandling?: {\n    showToUser?: boolean\n    retryOnFail?: boolean\n  }\n}\n```\n\n**Fields:**\n\n* `validateLLMOutput`: Validate plan JSON structure (recommended: `true`, optional)\n* `storeChatToLocalStorage`: Persist chat history (optional)\n* `localStorageKey`: Key for localStorage (default: `'autoui_chat'`, optional)\n* `enableDebugLogs`: Log execution details to console (optional)\n* `toolsSchema`: Optional OpenAI tool schema definitions (optional)\n* `maxSteps`: Maximum instruction steps allowed (optional)\n* `errorHandling.showToUser`: Display errors in chat UI (optional)\n* `errorHandling.retryOnFail`: Auto-retry failed function calls (optional)\n\n### `functions` (optional)\n\n**Type:** `Record<string, FunctionConfig>`\n\nRegistered functions that the assistant can call.\n\n```tsx\nfunctions: {\n  functionName: {\n    prompt: string                                    // Required: Description for LLM\n    params?: Record<string, string>                  // Optional: Parameter descriptions\n    callFunc: Function                               // Required: The actual function implementation\n    returns?: string                                 // Optional: Return type description\n    exampleUsage?: string                           // Optional: Example usage for LLM\n    tags?: string[]                                 // Optional: Tags for organization\n    canShareDataWithLLM?: boolean                   // Optional: Whether function can share data with LLM\n  }\n}\n```\n\n**Important:** Functions must return a value (not void) so the LLM can analyze the results.\n\nSee [Functions](/docs/functions) for detailed documentation.\n\n### `components` (optional)\n\n**Type:** `Record<string, ComponentConfig>`\n\nRegistered React components for generative UI.\n\n```tsx\ncomponents: {\n  componentName: {\n    prompt: string                                  // Required: Description for LLM\n    props?: Record<string, string>                  // Optional: Human-readable prop descriptions\n    callComponent: ComponentType<any>              // Required: React component reference\n    defaults?: Record<string, any>                   // Optional: Default prop values\n    exampleUsage?: string                           // Optional: Example JSX usage (string)\n    category?: string                               // Optional: Category (e.g., 'product-display', 'checkout')\n    tags?: string[]                                 // Optional: Tags for search or grouping\n  }\n}\n```\n\n**Note:** `callComponent` must be a React `ComponentType`, which can be a function component or class component.\n\nSee [Components](/docs/components) for detailed documentation.\n\n## Complete Example\n\n```tsx\nconst config: AutoUIConfig = {\n  appId: 'my-app',\n  \n  // Optional but recommended\n  metadata: {\n    appName: 'My Application',\n    appVersion: '1.0.0',\n    author: 'Your Name',\n    createdAt: new Date().toISOString(),\n    description: 'Detailed description of what your app does...',\n    tags: ['demo', 'react'],\n  },\n  \n  llm: {\n    proxyUrl: 'http://localhost:3001',  // Required\n    sharedSecret: 'your-client-key',    // Optional\n    provider: 'openrouter',             // Optional\n    model: 'openai/gpt-4o',             // Optional\n    temperature: 0.2,                   // Optional\n    maxTokens: 2048,                   // Optional\n    appDescriptionPrompt: 'A simple application.', // Optional\n    requestHeaders: {                   // Optional\n      'HTTP-Referer': 'https://myapp.com',\n    },\n  },\n  \n  runtime: {\n    validateLLMOutput: true,           // Optional\n    storeChatToLocalStorage: true,      // Optional\n    localStorageKey: 'autoui_chat',     // Optional\n    enableDebugLogs: false,             // Optional\n    maxSteps: 20,                      // Optional\n    errorHandling: {                    // Optional\n      showToUser: true,\n      retryOnFail: false,\n    },\n  },\n  \n  functions: {\n    // Optional\n    myFunction: {\n      prompt: 'Does something useful',\n      params: {\n        param1: 'string - Description of param1',\n      },\n      callFunc: ({ param1 }) => {\n        // Implementation\n        return { result: 'success' }\n      },\n      returns: 'Object with result',\n      canShareDataWithLLM: true,\n    },\n  },\n  \n  components: {\n    // Optional\n    MyComponent: {\n      prompt: 'Displays something useful',\n      props: {\n        title: 'string - Component title',\n      },\n      callComponent: ({ title }) => <div>{title}</div>,\n      defaults: {\n        title: 'Default Title',\n      },\n      category: 'display',\n    },\n  },\n}\n```\n\n## TypeScript Types\n\nIf you're using TypeScript, import the types:\n\n```tsx\nimport { AutoUIConfig, Metadata, LLMConfig, RuntimeConfig } from \"@autoai-ui/autoui\"\n```\n\n## Validation\n\nAUTOUI validates your config at runtime. Common validation errors:\n\n* Missing required fields (`appId`, `llm.proxyUrl`)\n* Invalid `proxyUrl` format\n* Invalid `maxSteps` (must be positive number if provided)\n* Invalid `temperature` (must be 0.0-2.0 if provided)\n* Functions that return `void` (functions must return a value)\n\n## Best Practices\n\n* Use descriptive `appId` values\n* Write detailed `metadata.description` for better LLM understanding\n* Keep `llm.appDescriptionPrompt` concise but informative\n* Enable `validateLLMOutput` in production\n* Use meaningful `localStorageKey` values\n* Set appropriate `maxSteps` based on app complexity\n\n## Related Documentation\n\n* [TypeScript Types Reference](/docs/reference/types) - Complete types and interfaces reference\n* [Installation & Configuration](/docs/installation) - Setup guide\n* [Functions](/docs/functions) - Function registration\n* [Components](/docs/components) - Component registration\n* [Runtime & Debugging](/docs/runtime) - Runtime behavior\n",
    "_searchMeta": {
      "cleanContent": "complete reference for the autouiconfig type type definition top-level fields appid required type: string unique identifier for your application used for: logging and analytics localstorage keys if not overridden error tracking metadata optional type: autouimetadata application metadata that describes your app to the llm this is optional but recommended for better llm understanding fields: appname: display name of your application required appversion: version string e g 1 0 0 optional author: author or team name optional createdat: iso 8601 timestamp optional description: detailed description that tells the llm what your app does optional but recommended tags: array of tags for categorization optional llm required type: llmconfig llm provider configuration required fields: proxyurl: url of your proxy server required in production optional fields: sharedsecret: client key generated by proxy server optional for proxy auth provider: llm provider name informational used by proxy model: model hint actual model enforced by proxy temperature: randomness 0 0-2 0 default: 0 2 maxtokens: maximum response length hint default: 2048 appdescriptionprompt: concise description of app capabilities requestheaders: optional headers forwarded to proxy runtime required type: runtimeconfig runtime execution configuration fields: validatellmoutput: validate plan json structure recommended: true optional storechattolocalstorage: persist chat history optional localstoragekey: key for localstorage default: autoui_chat optional enabledebuglogs: log execution details to console optional toolsschema: optional openai tool schema definitions optional maxsteps: maximum instruction steps allowed optional errorhandling showtouser: display errors in chat ui optional errorhandling retryonfail: auto-retry failed function calls optional functions optional type: record string functionconfig registered functions that the assistant can call important: functions must return a value not void so the llm can analyze the results see functions for detailed documentation components optional type: record string componentconfig registered react components for generative ui note: callcomponent must be a react componenttype which can be a function component or class component see components for detailed documentation complete example typescript types if you re using typescript import the types: validation autoui validates your config at runtime common validation errors: missing required fields appid llm proxyurl invalid proxyurl format invalid maxsteps must be positive number if provided invalid temperature must be 0 0-2 0 if provided functions that return void functions must return a value best practices use descriptive appid values write detailed metadata description for better llm understanding keep llm appdescriptionprompt concise but informative enable validatellmoutput in production use meaningful localstoragekey values set appropriate maxsteps based on app complexity related documentation typescript types reference - complete types and interfaces reference installation configuration - setup guide functions - function registration components - component registration runtime debugging - runtime behavior",
      "headings": [
        "Type Definition",
        "Top-Level Fields",
        "Complete Example",
        "TypeScript Types",
        "Validation",
        "Best Practices",
        "Related Documentation"
      ],
      "keywords": [
        "reference",
        "autouiconfig",
        "api",
        "types",
        "config",
        "Type Definition",
        "Top-Level Fields",
        "Complete Example",
        "TypeScript Types",
        "Validation",
        "Best Practices",
        "Related Documentation",
        "Type:",
        "Fields:",
        "Required fields:",
        "Optional fields:",
        "Important:",
        "Note:",
        "AutoUIConfig",
        "tsx\nimport { AutoUIConfig } from \"@autoai-ui/autoui\"",
        "## Top-Level Fields\n\n###",
        "(required)\n\n**Type:**",
        "Unique identifier for your application.",
        "tsx\nappId: 'tasks-demo'",
        "Used for:\n\n* Logging and analytics\n* localStorage keys (if not overridden)\n* Error tracking\n\n###",
        "(optional)\n\n**Type:**",
        "Application metadata that describes your app to the LLM. This is optional but recommended for better LLM understanding.",
        "tsx\nmetadata: {\n  appName: string\n  appVersion?: string\n  author?: string\n  createdAt?: string // ISO timestamp\n  description?: string // Detailed description for LLM\n  tags?: string[]\n}",
        "**Fields:**\n\n*",
        ": Display name of your application (required)\n*",
        ": Version string (e.g., \"1.0.0\") (optional)\n*",
        ": Author or team name (optional)\n*",
        ": ISO 8601 timestamp (optional)\n*",
        ": Detailed description that tells the LLM what your app does (optional but recommended)\n*",
        ": Array of tags for categorization (optional)\n\n###",
        "LLM provider configuration.",
        "tsx\nllm: {\n  proxyUrl: string              // Required: Backend proxy URL\n  sharedSecret?: string          // Optional: Shared secret for proxy auth\n  provider?: string              // Optional: LLM provider (informational)\n  model?: string                 // Optional: Model hint (actual model enforced by proxy)\n  temperature?: number           // Optional: Sampling temperature (0.0-2.0), default: 0.2\n  maxTokens?: number             // Optional: Max tokens hint, default: 2048\n  appDescriptionPrompt?: string  // Optional: App description context\n  requestHeaders?: Record<string, string> // Optional: Headers forwarded to proxy\n}",
        "**Required fields:**\n\n*",
        ": URL of your proxy server (REQUIRED in production)\n\n**Optional fields:**\n\n*",
        ": Client key generated by proxy server (optional, for proxy auth)\n*",
        ": LLM provider name (informational, used by proxy)\n*",
        ": Model hint (actual model enforced by proxy)\n*",
        ": Randomness (0.0-2.0), default: 0.2\n*",
        ": Maximum response length hint, default: 2048\n*",
        ": Concise description of app capabilities\n*",
        ": Optional headers forwarded to proxy\n\n###",
        "Runtime execution configuration.",
        "tsx\nruntime: {\n  validateLLMOutput?: boolean\n  storeChatToLocalStorage?: boolean\n  localStorageKey?: string\n  enableDebugLogs?: boolean\n  toolsSchema?: OpenAIToolSchema[]\n  maxSteps?: number\n  errorHandling?: {\n    showToUser?: boolean\n    retryOnFail?: boolean\n  }\n}",
        ": Validate plan JSON structure (recommended:",
        ", optional)\n*",
        ": Persist chat history (optional)\n*",
        ": Key for localStorage (default:",
        ": Log execution details to console (optional)\n*",
        ": Optional OpenAI tool schema definitions (optional)\n*",
        ": Maximum instruction steps allowed (optional)\n*",
        ": Display errors in chat UI (optional)\n*",
        ": Auto-retry failed function calls (optional)\n\n###",
        "Registered functions that the assistant can call.",
        "tsx\nfunctions: {\n  functionName: {\n    prompt: string                                    // Required: Description for LLM\n    params?: Record<string, string>                  // Optional: Parameter descriptions\n    callFunc: Function                               // Required: The actual function implementation\n    returns?: string                                 // Optional: Return type description\n    exampleUsage?: string                           // Optional: Example usage for LLM\n    tags?: string[]                                 // Optional: Tags for organization\n    canShareDataWithLLM?: boolean                   // Optional: Whether function can share data with LLM\n  }\n}",
        "**Important:** Functions must return a value (not void) so the LLM can analyze the results.\n\nSee [Functions](/docs/functions) for detailed documentation.\n\n###",
        "Registered React components for generative UI.",
        "tsx\ncomponents: {\n  componentName: {\n    prompt: string                                  // Required: Description for LLM\n    props?: Record<string, string>                  // Optional: Human-readable prop descriptions\n    callComponent: ComponentType<any>              // Required: React component reference\n    defaults?: Record<string, any>                   // Optional: Default prop values\n    exampleUsage?: string                           // Optional: Example JSX usage (string)\n    category?: string                               // Optional: Category (e.g., 'product-display', 'checkout')\n    tags?: string[]                                 // Optional: Tags for search or grouping\n  }\n}",
        "**Note:**",
        "must be a React",
        ", which can be a function component or class component.\n\nSee [Components](/docs/components) for detailed documentation.\n\n## Complete Example",
        "tsx\nconst config: AutoUIConfig = {\n  appId: 'my-app',\n  \n  // Optional but recommended\n  metadata: {\n    appName: 'My Application',\n    appVersion: '1.0.0',\n    author: 'Your Name',\n    createdAt: new Date().toISOString(),\n    description: 'Detailed description of what your app does...',\n    tags: ['demo', 'react'],\n  },\n  \n  llm: {\n    proxyUrl: 'http://localhost:3001',  // Required\n    sharedSecret: 'your-client-key',    // Optional\n    provider: 'openrouter',             // Optional\n    model: 'openai/gpt-4o',             // Optional\n    temperature: 0.2,                   // Optional\n    maxTokens: 2048,                   // Optional\n    appDescriptionPrompt: 'A simple application.', // Optional\n    requestHeaders: {                   // Optional\n      'HTTP-Referer': 'https://myapp.com',\n    },\n  },\n  \n  runtime: {\n    validateLLMOutput: true,           // Optional\n    storeChatToLocalStorage: true,      // Optional\n    localStorageKey: 'autoui_chat',     // Optional\n    enableDebugLogs: false,             // Optional\n    maxSteps: 20,                      // Optional\n    errorHandling: {                    // Optional\n      showToUser: true,\n      retryOnFail: false,\n    },\n  },\n  \n  functions: {\n    // Optional\n    myFunction: {\n      prompt: 'Does something useful',\n      params: {\n        param1: 'string - Description of param1',\n      },\n      callFunc: ({ param1 }) => {\n        // Implementation\n        return { result: 'success' }\n      },\n      returns: 'Object with result',\n      canShareDataWithLLM: true,\n    },\n  },\n  \n  components: {\n    // Optional\n    MyComponent: {\n      prompt: 'Displays something useful',\n      props: {\n        title: 'string - Component title',\n      },\n      callComponent: ({ title }) => <div>{title}</div>,\n      defaults: {\n        title: 'Default Title',\n      },\n      category: 'display',\n    },\n  },\n}",
        "## TypeScript Types\n\nIf you're using TypeScript, import the types:",
        "tsx\nimport { AutoUIConfig, Metadata, LLMConfig, RuntimeConfig } from \"@autoai-ui/autoui\"",
        "## Validation\n\nAUTOUI validates your config at runtime. Common validation errors:\n\n* Missing required fields (",
        ",",
        ")\n* Invalid",
        "format\n* Invalid",
        "(must be positive number if provided)\n* Invalid",
        "(must be 0.0-2.0 if provided)\n* Functions that return",
        "(functions must return a value)\n\n## Best Practices\n\n* Use descriptive",
        "values\n* Write detailed",
        "for better LLM understanding\n* Keep",
        "concise but informative\n* Enable",
        "in production\n* Use meaningful",
        "values\n* Set appropriate"
      ]
    }
  },
  {
    "slug": "/reference/modalchat",
    "title": "ModalChat Props Reference",
    "description": "Complete reference for ModalChat component props and usage.",
    "content": "Complete reference for the `ModalChat` React component.\n\n## Import\n\n```tsx\nimport { ModalChat } from \"@autoai-ui/autoui\"\n```\n\nOr with dynamic import (recommended for Next.js):\n\n```tsx\nimport dynamic from \"next/dynamic\"\r\n\r\nconst ModalChat = dynamic(\r\n  () => import(\"@autoai-ui/autoui\").then(m => m.ModalChat),\r\n  { ssr: false }\r\n)\n```\n\n## Props\n\n### `config` (required)\n\n**Type:** `AutoUIConfig`\n\nThe AUTOUI configuration object.\n\n```tsx\n<ModalChat config={myConfig} />\n```\n\nSee [AutoUIConfig Reference](/docs/reference/autouiconfig) for details.\n\n### `open` (optional)\n\n**Type:** `boolean`\n\nControls whether the chat modal is open.\n\n```tsx\nconst [isOpen, setIsOpen] = useState(false)\r\n\r\n<ModalChat \r\n  config={config}\r\n  open={isOpen}\r\n  onOpenChange={setIsOpen}\r\n/>\n```\n\n**Default:** `undefined` (uncontrolled)\n\n**Use case:** Use when you want to control the modal state programmatically (e.g., with a custom trigger button).\n\n### `onOpenChange` (optional)\n\n**Type:** `(open: boolean) => void`\n\nCallback fired when the modal open state changes.\n\n```tsx\n<ModalChat \r\n  config={config}\r\n  open={isOpen}\r\n  onOpenChange={(open) => setIsOpen(open)}\r\n/>\n```\n\n**Use case:** Use with controlled `open` prop to sync modal state with your component state.\n\n### `className` (optional)\n\n**Type:** `string`\n\nAdditional CSS class names for the modal container.\n\n```tsx\n<ModalChat \r\n  config={config}\r\n  className=\"my-custom-modal\"\r\n/>\n```\n\n**Use case:** Apply custom styling to the modal container.\n\n### `style` (optional)\n\n**Type:** `React.CSSProperties`\n\nInline styles for the modal container.\n\n```tsx\n<ModalChat \r\n  config={config}\r\n  style={{ zIndex: 9999 }}\r\n/>\n```\n\n**Use case:** Apply inline styles for positioning or z-index.\n\n## Usage Examples\n\n### Basic Usage\n\n```tsx\nimport { ModalChat, AutoUIConfig } from \"@autoai-ui/autoui\"\r\n\r\nexport default function App() {\r\n  const config: AutoUIConfig = {\r\n    // ... your config\r\n  }\r\n\r\n  return <ModalChat config={config} />\r\n}\n```\n\n### With Dynamic Import (Next.js)\n\n```tsx\n\"use client\"\r\nimport dynamic from \"next/dynamic\"\r\nimport { AutoUIConfig } from \"@autoai-ui/autoui\"\r\n\r\nconst ModalChat = dynamic(\r\n  () => import(\"@autoai-ui/autoui\").then(m => m.ModalChat),\r\n  { ssr: false }\r\n)\r\n\r\nexport default function App() {\r\n  const config: AutoUIConfig = {\r\n    // ... your config\r\n  }\r\n\r\n  return <ModalChat config={config} />\r\n}\n```\n\n### Controlled State\n\n```tsx\nimport { useState } from \"react\"\r\nimport { ModalChat, AutoUIConfig } from \"@autoai-ui/autoui\"\r\n\r\nexport default function App() {\r\n  const [isOpen, setIsOpen] = useState(false)\r\n  const config: AutoUIConfig = {\r\n    // ... your config\r\n  }\r\n\r\n  return (\r\n    <>\r\n      <button onClick={() => setIsOpen(true)}>\r\n        Open Chat\r\n      </button>\r\n      <ModalChat \r\n        config={config}\r\n        open={isOpen}\r\n        onOpenChange={setIsOpen}\r\n      />\r\n    </>\r\n  )\r\n}\n```\n\n### With Custom Styling\n\n```tsx\n<ModalChat \r\n  config={config}\r\n  className=\"my-custom-chat\"\r\n  style={{ \r\n    position: 'fixed',\r\n    bottom: '20px',\r\n    right: '20px',\r\n    zIndex: 9999\r\n  }}\r\n/>\n```\n\n## Component Behavior\n\n### Default Trigger Button\n\nBy default, ModalChat renders a floating action button (FAB) that opens the chat modal when clicked. The button appears in the bottom-right corner.\n\n### Modal Behavior\n\n* Opens as a modal overlay\n* Closes when clicking outside or pressing Escape\n* Maintains chat history (if `storeChatToLocalStorage` is enabled)\n* Responsive design (adapts to mobile/desktop)\n\n### SSR Considerations\n\nModalChat must be dynamically imported with `ssr: false` in Next.js or similar SSR frameworks to prevent hydration mismatches.\n\n## Styling\n\nSee [ModalChat Styling](/docs/styling) for detailed styling options and customization.\n\n## Related Documentation\n\n* [AutoUIConfig Reference](/docs/reference/autouiconfig) - Config structure\n* [TypeScript Types Reference](/docs/reference/types) - Complete types and interfaces\n* [Installation & Configuration](/docs/installation) - Setup guide\n* [ModalChat Styling](/docs/styling) - Styling and theming\n",
    "_searchMeta": {
      "cleanContent": "complete reference for the modalchat react component import or with dynamic import recommended for next js : props config required type: autouiconfig the autoui configuration object see autouiconfig reference for details open optional type: boolean controls whether the chat modal is open default: undefined uncontrolled use case: use when you want to control the modal state programmatically e g with a custom trigger button onopenchange optional type: open: boolean void callback fired when the modal open state changes use case: use with controlled open prop to sync modal state with your component state classname optional type: string additional css class names for the modal container use case: apply custom styling to the modal container style optional type: react cssproperties inline styles for the modal container use case: apply inline styles for positioning or z-index usage examples basic usage with dynamic import next js controlled state with custom styling component behavior default trigger button by default modalchat renders a floating action button fab that opens the chat modal when clicked the button appears in the bottom-right corner modal behavior opens as a modal overlay closes when clicking outside or pressing escape maintains chat history if storechattolocalstorage is enabled responsive design adapts to mobile desktop ssr considerations modalchat must be dynamically imported with ssr: false in next js or similar ssr frameworks to prevent hydration mismatches styling see modalchat styling for detailed styling options and customization related documentation autouiconfig reference - config structure typescript types reference - complete types and interfaces installation configuration - setup guide modalchat styling - styling and theming",
      "headings": [
        "Import",
        "Props",
        "Usage Examples",
        "Component Behavior",
        "Styling",
        "Related Documentation"
      ],
      "keywords": [
        "reference",
        "modalchat",
        "props",
        "component",
        "api",
        "Import",
        "Props",
        "Usage Examples",
        "Component Behavior",
        "Styling",
        "Related Documentation",
        "Type:",
        "Default:",
        "Use case:",
        "ModalChat",
        "tsx\nimport { ModalChat } from \"@autoai-ui/autoui\"",
        "Or with dynamic import (recommended for Next.js):",
        "tsx\nimport dynamic from \"next/dynamic\"\r\n\r\nconst ModalChat = dynamic(\r\n  () => import(\"@autoai-ui/autoui\").then(m => m.ModalChat),\r\n  { ssr: false }\r\n)",
        "## Props\n\n###",
        "(required)\n\n**Type:**",
        "The AUTOUI configuration object.",
        "tsx\n<ModalChat config={myConfig} />",
        "See [AutoUIConfig Reference](/docs/reference/autouiconfig) for details.\n\n###",
        "(optional)\n\n**Type:**",
        "Controls whether the chat modal is open.",
        "tsx\nconst [isOpen, setIsOpen] = useState(false)\r\n\r\n<ModalChat \r\n  config={config}\r\n  open={isOpen}\r\n  onOpenChange={setIsOpen}\r\n/>",
        "**Default:**",
        "(uncontrolled)\n\n**Use case:** Use when you want to control the modal state programmatically (e.g., with a custom trigger button).\n\n###",
        "Callback fired when the modal open state changes.",
        "tsx\n<ModalChat \r\n  config={config}\r\n  open={isOpen}\r\n  onOpenChange={(open) => setIsOpen(open)}\r\n/>",
        "**Use case:** Use with controlled",
        "prop to sync modal state with your component state.\n\n###",
        "Additional CSS class names for the modal container.",
        "tsx\n<ModalChat \r\n  config={config}\r\n  className=\"my-custom-modal\"\r\n/>",
        "**Use case:** Apply custom styling to the modal container.\n\n###",
        "Inline styles for the modal container.",
        "tsx\n<ModalChat \r\n  config={config}\r\n  style={{ zIndex: 9999 }}\r\n/>",
        "**Use case:** Apply inline styles for positioning or z-index.\n\n## Usage Examples\n\n### Basic Usage",
        "tsx\nimport { ModalChat, AutoUIConfig } from \"@autoai-ui/autoui\"\r\n\r\nexport default function App() {\r\n  const config: AutoUIConfig = {\r\n    // ... your config\r\n  }\r\n\r\n  return <ModalChat config={config} />\r\n}",
        "### With Dynamic Import (Next.js)",
        "tsx\n\"use client\"\r\nimport dynamic from \"next/dynamic\"\r\nimport { AutoUIConfig } from \"@autoai-ui/autoui\"\r\n\r\nconst ModalChat = dynamic(\r\n  () => import(\"@autoai-ui/autoui\").then(m => m.ModalChat),\r\n  { ssr: false }\r\n)\r\n\r\nexport default function App() {\r\n  const config: AutoUIConfig = {\r\n    // ... your config\r\n  }\r\n\r\n  return <ModalChat config={config} />\r\n}",
        "### Controlled State",
        "tsx\nimport { useState } from \"react\"\r\nimport { ModalChat, AutoUIConfig } from \"@autoai-ui/autoui\"\r\n\r\nexport default function App() {\r\n  const [isOpen, setIsOpen] = useState(false)\r\n  const config: AutoUIConfig = {\r\n    // ... your config\r\n  }\r\n\r\n  return (\r\n    <>\r\n      <button onClick={() => setIsOpen(true)}>\r\n        Open Chat\r\n      </button>\r\n      <ModalChat \r\n        config={config}\r\n        open={isOpen}\r\n        onOpenChange={setIsOpen}\r\n      />\r\n    </>\r\n  )\r\n}",
        "### With Custom Styling",
        "tsx\n<ModalChat \r\n  config={config}\r\n  className=\"my-custom-chat\"\r\n  style={{ \r\n    position: 'fixed',\r\n    bottom: '20px',\r\n    right: '20px',\r\n    zIndex: 9999\r\n  }}\r\n/>",
        "## Component Behavior\n\n### Default Trigger Button\n\nBy default, ModalChat renders a floating action button (FAB) that opens the chat modal when clicked. The button appears in the bottom-right corner.\n\n### Modal Behavior\n\n* Opens as a modal overlay\n* Closes when clicking outside or pressing Escape\n* Maintains chat history (if",
        "is enabled)\n* Responsive design (adapts to mobile/desktop)\n\n### SSR Considerations\n\nModalChat must be dynamically imported with"
      ]
    }
  },
  {
    "slug": "/reference/types",
    "title": "TypeScript Types Reference",
    "description": "Complete reference for all TypeScript types and interfaces in the AutoUI library.",
    "content": "This page provides a complete reference for all TypeScript types and interfaces exported by the AutoUI library.\n\n## AutoUIConfig\n\nThe main configuration interface that defines your app's capabilities.\n\n```typescript\nimport type { AutoUIConfig } from '@autoai-ui/autoui';\r\n\r\nexport interface AutoUIConfig {\r\n  appId: string;\r\n  llm: LLMConfig;\r\n  runtime: RuntimeConfig;\r\n  functions: Record<string, AutoUIFunction>;\r\n  components: Record<string, AutoUIComponent>;\r\n  metadata?: AutoUIMetadata;\r\n}\n```\n\n**Fields:**\n\n* `appId` (required): Unique identifier for your application\n* `llm` (required): LLM proxy configuration\n* `runtime` (required): Runtime behavior settings\n* `functions` (required): Record of function definitions that the LLM can call\n* `components` (required): Record of component definitions that the LLM can render\n* `metadata` (optional): Application metadata\n\n## LLMConfig\n\nConfiguration for the LLM proxy connection.\n\n```typescript\nexport interface LLMConfig {\r\n  /** 🔐 Backend proxy URL */\r\n  proxyUrl: string;\r\n  /** Shared secret for proxy auth */\r\n  sharedSecret?: string;\r\n  /** Sampling temperature (hint only) */\r\n  temperature?: number;\r\n  /** Max tokens (hint only) */\r\n  maxTokens?: number;\r\n  /** App description context */\r\n  appDescriptionPrompt?: string;\r\n  /** Optional headers forwarded to proxy */\r\n  requestHeaders?: Record<string, string>;\r\n}\n```\n\n**Fields:**\n\n* `proxyUrl` (required): Backend proxy URL. Use `https://autoui-chi.vercel.app` for the deployed service, or your own proxy server URL\n* `sharedSecret` (optional): Shared secret for proxy authentication. Get this from the [AutoUI Service Portal](https://autoui-chi.vercel.app/) or generate it from your own proxy server\n* `temperature` (optional): Sampling temperature hint (0.0-2.0). The actual temperature is controlled by the proxy server\n* `maxTokens` (optional): Maximum tokens hint. The actual limit is controlled by the proxy server\n* `appDescriptionPrompt` (optional): Brief description of your app that helps the LLM understand your application's purpose\n* `requestHeaders` (optional): Custom headers to forward to the proxy server\n\n## RuntimeConfig\n\nConfiguration for runtime behavior and execution settings.\n\n```typescript\nexport interface RuntimeConfig {\r\n  /** Whether to validate LLM JSON output */\r\n  validateLLMOutput?: boolean;\r\n  /** Whether to store chat history to localStorage */\r\n  storeChatToLocalStorage?: boolean;\r\n  /** Key used for saving chat history */\r\n  localStorageKey?: string;\r\n  /** Enable internal debug logging */\r\n  enableDebugLogs?: boolean;\r\n  /** Maximum instruction steps allowed */\r\n  maxSteps?: number;\r\n  /** Error-handling policy */\r\n  errorHandling?: {\r\n    showToUser?: boolean;\r\n    retryOnFail?: boolean;\r\n  };\r\n  /** Path to runtime schema file (relative to project root or absolute URL) */\r\n  /** Default: '.autoui-runtime-schema.json' */\r\n  runtimeSchemaPath?: string;\r\n}\n```\n\n**Fields:**\n\n* `validateLLMOutput` (optional): Whether to validate LLM JSON output against the schema. Recommended: `true` for production\n* `storeChatToLocalStorage` (optional): Whether to persist chat history in localStorage\n* `localStorageKey` (optional): Key used for storing chat history in localStorage. Default: `'autoui_chat'`\n* `enableDebugLogs` (optional): Enable internal debug logging to console. Useful for development\n* `maxSteps` (optional): Maximum number of instruction steps allowed per conversation turn. Prevents infinite loops\n* `errorHandling` (optional): Error handling configuration\n  * `showToUser` (optional): Whether to display errors to users in the chat UI\n  * `retryOnFail` (optional): Whether to automatically retry failed operations\n* `runtimeSchemaPath` (optional): Path to the runtime schema file. Default: `'.autoui-runtime-schema.json'`. Can be a relative path from project root or an absolute URL\n\n## AutoUIFunction\n\nDefines a callable function that the LLM can invoke.\n\n```typescript\nexport interface AutoUIFunction {\r\n  /** Prompt used by the LLM to decide when/how to call this function */\r\n  prompt: string;\r\n  /** Descriptive list of parameters (for documentation & LLM guidance) */\r\n  params?: Record<string, string>;\r\n  /** Description of the expected return type */\r\n  returns?: string;\r\n  /** The actual callable implementation (may be mocked) */\r\n  callFunc: Function;\r\n  /** Optional example usage or notes for LLM context */\r\n  exampleUsage?: string;\r\n  /** Optional tags for organization */\r\n  tags?: string[];\r\n  /** Whether the function can share data with the LLM for analysis */\r\n  canShareDataWithLLM?: boolean;\r\n}\n```\n\n**Fields:**\n\n* `prompt` (required): Natural language description that tells the LLM when and how to use this function. This is crucial for the LLM's decision-making\n* `params` (optional): Object describing function parameters. Keys are parameter names, values are type descriptions (e.g., `{ userId: 'string — user ID to fetch' }`)\n* `returns` (optional): Description of what the function returns (e.g., `'UserProfile — user profile object'`)\n* `callFunc` (required): The actual JavaScript function implementation. **Must return a value** (not void) so the LLM can analyze results\n* `exampleUsage` (optional): Example usage or notes to provide additional context to the LLM\n* `tags` (optional): Tags for organizing and categorizing functions\n* `canShareDataWithLLM` (optional): Whether the function's return data can be shared with the LLM for analysis. Set to `false` for sensitive data\n\n**Important:** Functions must return a value (not `void`) so the LLM can analyze the results.\n\n## AutoUIComponent\n\nDefines a React component that the LLM can render.\n\n```typescript\nimport type { ComponentType } from 'react';\r\n\r\nexport interface AutoUIComponent {\r\n  /** Prompt describing what the component does (for LLM) */\r\n  prompt: string;\r\n  /** Human-readable parameter descriptions */\r\n  props?: Record<string, string>;\r\n  /** Actual React component reference */\r\n  callComponent: ComponentType<any>;\r\n  /** Default prop values for runtime or mock previews */\r\n  defaults?: Record<string, any>;\r\n  /** Callback definitions with handlers - combines metadata and implementation */\r\n  callbacks?: Record<string, AutoUICallback | Function>;\r\n  /** Example JSX usage (string literal for docs) */\r\n  exampleUsage?: string;\r\n  /** Optional category (product-display, checkout, etc.) */\r\n  category?: string;\r\n  /** Optional tags for search or grouping */\r\n  tags?: string[];\r\n}\n```\n\n**Fields:**\n\n* `prompt` (required): Natural language description of what the component does and when to render it\n* `props` (optional): Object describing component props. Keys are prop names, values are descriptions (e.g., `{ title: 'string — component title' }`)\n* `callComponent` (required): Reference to the React component (function component or class component)\n* `defaults` (optional): Default prop values. Helps the LLM understand the expected data structure\n* `callbacks` (optional): Callback definitions. Can be `AutoUICallback` objects or direct function references\n* `exampleUsage` (optional): Example JSX usage as a string literal for documentation\n* `category` (optional): Category for grouping related components (e.g., `'product-display'`, `'checkout'`)\n* `tags` (optional): Tags for organizing and searching components\n\n## AutoUICallback\n\nDefines callbacks that components can use for user interactions.\n\n```typescript\nexport interface AutoUICallback {\r\n  /** Description of what this callback does */\r\n  description: string;\r\n  /** When to use this callback */\r\n  whenToUse?: string;\r\n  /** Example usage */\r\n  example?: string;\r\n  /** The actual callback function implementation */\r\n  callFunc: Function;\r\n}\n```\n\n**Fields:**\n\n* `description` (required): Description of what the callback does\n* `whenToUse` (optional): Guidance on when to use this callback\n* `example` (optional): Example usage\n* `callFunc` (required): The callback function implementation\n\n## AutoUIMetadata\n\nOptional metadata about your application.\n\n```typescript\nexport interface AutoUIMetadata {\r\n  appName: string;\r\n  appVersion?: string;\r\n  author?: string;\r\n  createdAt?: string;\r\n  description?: string;\r\n  tags?: string[];\r\n}\n```\n\n**Fields:**\n\n* `appName` (required): Name of your application\n* `appVersion` (optional): Version string (e.g., `'1.0.0'`)\n* `author` (optional): Author or team name\n* `createdAt` (optional): ISO 8601 timestamp of creation date\n* `description` (optional): Detailed description of your application\n* `tags` (optional): Tags for categorization\n\n## Instruction Plan Types\n\nThese types describe the structure that the LLM response must have.\n\n### InstructionStep\n\nUnion type representing a single step in an instruction plan.\n\n```typescript\nexport type InstructionStep = FunctionStep | ComponentStep | TextStep;\n```\n\n### FunctionStep\n\nA step that calls a registered function.\n\n```typescript\nexport type FunctionStep = {\r\n  type: 'function';\r\n  name: string;\r\n  params?: Record<string, any>;\r\n  assign?: string;\r\n  hasToShareDataWithLLM?: boolean;\r\n};\n```\n\n**Fields:**\n\n* `type`: Must be `'function'`\n* `name`: Name of the function to call (must match a key in `functions`)\n* `params`: Parameters to pass to the function\n* `assign`: Optional variable name to assign the result to\n* `hasToShareDataWithLLM`: Whether to share the function's return data with the LLM\n\n### ComponentStep\n\nA step that renders a registered component.\n\n```typescript\nexport type ComponentStep = {\r\n  type: 'component';\r\n  name: string;\r\n  props?: Record<string, any>;\r\n  /** Explicit callback references - maps callback prop names to callback names from component config */\r\n  callbacks?: Record<string, string>;\r\n};\n```\n\n**Fields:**\n\n* `type`: Must be `'component'`\n* `name`: Name of the component to render (must match a key in `components`)\n* `props`: Props to pass to the component\n* `callbacks`: Maps callback prop names to callback names from the component config\n\n### TextStep\n\nA step that displays text to the user.\n\n```typescript\nexport type TextStep = {\r\n  type: 'text';\r\n  text: string;\r\n};\n```\n\n**Fields:**\n\n* `type`: Must be `'text'`\n* `text`: Text content to display\n\n### InstructionPlan\n\nThe complete plan structure returned by the LLM.\n\n```typescript\nexport type InstructionPlan = {\r\n  type: 'sequence';\r\n  steps: InstructionStep[];\r\n};\n```\n\n**Fields:**\n\n* `type`: Must be `'sequence'`\n* `steps`: Array of instruction steps to execute in order\n\n## Usage Example\n\n```typescript\nimport type { AutoUIConfig, AutoUIFunction, AutoUIComponent } from '@autoai-ui/autoui';\r\n\r\nconst config: AutoUIConfig = {\r\n  appId: 'my-app',\r\n  llm: {\r\n    proxyUrl: 'https://autoui-chi.vercel.app',\r\n    sharedSecret: 'your-shared-secret',\r\n    appDescriptionPrompt: 'A task management application',\r\n  },\r\n  runtime: {\r\n    validateLLMOutput: true,\r\n    storeChatToLocalStorage: true,\r\n    maxSteps: 20,\r\n  },\r\n  functions: {\r\n    createTask: {\r\n      prompt: 'Create a new task',\r\n      params: {\r\n        title: 'string — task title',\r\n        description: 'string (optional) — task description',\r\n      },\r\n      returns: 'Task — the created task object',\r\n      callFunc: async ({ title, description }) => {\r\n        // Implementation\r\n        return { id: '1', title, description };\r\n      },\r\n      canShareDataWithLLM: true,\r\n    } satisfies AutoUIFunction,\r\n  },\r\n  components: {\r\n    TaskCard: {\r\n      prompt: 'Display a task card',\r\n      props: {\r\n        task: 'Task — task object to display',\r\n      },\r\n      callComponent: TaskCard,\r\n      defaults: {\r\n        task: { id: '', title: '', description: '' },\r\n      },\r\n    } satisfies AutoUIComponent,\r\n  },\r\n  metadata: {\r\n    appName: 'My Task App',\r\n    appVersion: '1.0.0',\r\n    description: 'A task management application',\r\n  },\r\n};\n```\n\n## Related Documentation\n\n* [AutoUIConfig Reference](/docs/reference/autouiconfig) - Detailed config reference\n* [Configuration Guide](/docs/config) - How to configure AutoUI\n* [Functions Guide](/docs/functions) - Registering functions\n* [Components Guide](/docs/components) - Registering components\n",
    "_searchMeta": {
      "cleanContent": "this page provides a complete reference for all typescript types and interfaces exported by the autoui library autouiconfig the main configuration interface that defines your app s capabilities fields: appid required : unique identifier for your application llm required : llm proxy configuration runtime required : runtime behavior settings functions required : record of function definitions that the llm can call components required : record of component definitions that the llm can render metadata optional : application metadata llmconfig configuration for the llm proxy connection fields: proxyurl required : backend proxy url use https: autoui-chi vercel app for the deployed service or your own proxy server url sharedsecret optional : shared secret for proxy authentication get this from the autoui service portal or generate it from your own proxy server temperature optional : sampling temperature hint 0 0-2 0 the actual temperature is controlled by the proxy server maxtokens optional : maximum tokens hint the actual limit is controlled by the proxy server appdescriptionprompt optional : brief description of your app that helps the llm understand your application s purpose requestheaders optional : custom headers to forward to the proxy server runtimeconfig configuration for runtime behavior and execution settings fields: validatellmoutput optional : whether to validate llm json output against the schema recommended: true for production storechattolocalstorage optional : whether to persist chat history in localstorage localstoragekey optional : key used for storing chat history in localstorage default: autoui_chat enabledebuglogs optional : enable internal debug logging to console useful for development maxsteps optional : maximum number of instruction steps allowed per conversation turn prevents infinite loops errorhandling optional : error handling configuration showtouser optional : whether to display errors to users in the chat ui retryonfail optional : whether to automatically retry failed operations runtimeschemapath optional : path to the runtime schema file default: autoui-runtime-schema json can be a relative path from project root or an absolute url autouifunction defines a callable function that the llm can invoke fields: prompt required : natural language description that tells the llm when and how to use this function this is crucial for the llm s decision-making params optional : object describing function parameters keys are parameter names values are type descriptions e g userid: string user id to fetch returns optional : description of what the function returns e g userprofile user profile object callfunc required : the actual javascript function implementation must return a value not void so the llm can analyze results exampleusage optional : example usage or notes to provide additional context to the llm tags optional : tags for organizing and categorizing functions cansharedatawithllm optional : whether the function s return data can be shared with the llm for analysis set to false for sensitive data important: functions must return a value not void so the llm can analyze the results autouicomponent defines a react component that the llm can render fields: prompt required : natural language description of what the component does and when to render it props optional : object describing component props keys are prop names values are descriptions e g title: string component title callcomponent required : reference to the react component function component or class component defaults optional : default prop values helps the llm understand the expected data structure callbacks optional : callback definitions can be autouicallback objects or direct function references exampleusage optional : example jsx usage as a string literal for documentation category optional : category for grouping related components e g product-display checkout tags optional : tags for organizing and searching components autouicallback defines callbacks that components can use for user interactions fields: description required : description of what the callback does whentouse optional : guidance on when to use this callback example optional : example usage callfunc required : the callback function implementation autouimetadata optional metadata about your application fields: appname required : name of your application appversion optional : version string e g 1 0 0 author optional : author or team name createdat optional : iso 8601 timestamp of creation date description optional : detailed description of your application tags optional : tags for categorization instruction plan types these types describe the structure that the llm response must have instructionstep union type representing a single step in an instruction plan functionstep a step that calls a registered function fields: type: must be function name: name of the function to call must match a key in functions params: parameters to pass to the function assign: optional variable name to assign the result to hastosharedatawithllm: whether to share the function s return data with the llm componentstep a step that renders a registered component fields: type: must be component name: name of the component to render must match a key in components props: props to pass to the component callbacks: maps callback prop names to callback names from the component config textstep a step that displays text to the user fields: type: must be text text: text content to display instructionplan the complete plan structure returned by the llm fields: type: must be sequence steps: array of instruction steps to execute in order usage example related documentation autouiconfig reference - detailed config reference configuration guide - how to configure autoui functions guide - registering functions components guide - registering components",
      "headings": [
        "AutoUIConfig",
        "LLMConfig",
        "RuntimeConfig",
        "AutoUIFunction",
        "AutoUIComponent",
        "AutoUICallback",
        "AutoUIMetadata",
        "Instruction Plan Types",
        "Usage Example",
        "Related Documentation"
      ],
      "keywords": [
        "types",
        "typescript",
        "interface",
        "reference",
        "api",
        "autouiconfig",
        "llmconfig",
        "runtimeconfig",
        "AutoUIConfig",
        "LLMConfig",
        "RuntimeConfig",
        "AutoUIFunction",
        "AutoUIComponent",
        "AutoUICallback",
        "AutoUIMetadata",
        "Instruction Plan Types",
        "Usage Example",
        "Related Documentation",
        "Fields:",
        "Must return a value",
        "Important:",
        "typescript\nimport type { AutoUIConfig } from '@autoai-ui/autoui';\r\n\r\nexport interface AutoUIConfig {\r\n  appId: string;\r\n  llm: LLMConfig;\r\n  runtime: RuntimeConfig;\r\n  functions: Record<string, AutoUIFunction>;\r\n  components: Record<string, AutoUIComponent>;\r\n  metadata?: AutoUIMetadata;\r\n}",
        "**Fields:**\n\n*",
        "(required): Unique identifier for your application\n*",
        "(required): LLM proxy configuration\n*",
        "(required): Runtime behavior settings\n*",
        "(required): Record of function definitions that the LLM can call\n*",
        "(required): Record of component definitions that the LLM can render\n*",
        "(optional): Application metadata\n\n## LLMConfig\n\nConfiguration for the LLM proxy connection.",
        "typescript\nexport interface LLMConfig {\r\n  /** 🔐 Backend proxy URL */\r\n  proxyUrl: string;\r\n  /** Shared secret for proxy auth */\r\n  sharedSecret?: string;\r\n  /** Sampling temperature (hint only) */\r\n  temperature?: number;\r\n  /** Max tokens (hint only) */\r\n  maxTokens?: number;\r\n  /** App description context */\r\n  appDescriptionPrompt?: string;\r\n  /** Optional headers forwarded to proxy */\r\n  requestHeaders?: Record<string, string>;\r\n}",
        "(required): Backend proxy URL. Use",
        "for the deployed service, or your own proxy server URL\n*",
        "(optional): Shared secret for proxy authentication. Get this from the [AutoUI Service Portal](https://autoui-chi.vercel.app/) or generate it from your own proxy server\n*",
        "(optional): Sampling temperature hint (0.0-2.0). The actual temperature is controlled by the proxy server\n*",
        "(optional): Maximum tokens hint. The actual limit is controlled by the proxy server\n*",
        "(optional): Brief description of your app that helps the LLM understand your application's purpose\n*",
        "(optional): Custom headers to forward to the proxy server\n\n## RuntimeConfig\n\nConfiguration for runtime behavior and execution settings.",
        "typescript\nexport interface RuntimeConfig {\r\n  /** Whether to validate LLM JSON output */\r\n  validateLLMOutput?: boolean;\r\n  /** Whether to store chat history to localStorage */\r\n  storeChatToLocalStorage?: boolean;\r\n  /** Key used for saving chat history */\r\n  localStorageKey?: string;\r\n  /** Enable internal debug logging */\r\n  enableDebugLogs?: boolean;\r\n  /** Maximum instruction steps allowed */\r\n  maxSteps?: number;\r\n  /** Error-handling policy */\r\n  errorHandling?: {\r\n    showToUser?: boolean;\r\n    retryOnFail?: boolean;\r\n  };\r\n  /** Path to runtime schema file (relative to project root or absolute URL) */\r\n  /** Default: '.autoui-runtime-schema.json' */\r\n  runtimeSchemaPath?: string;\r\n}",
        "(optional): Whether to validate LLM JSON output against the schema. Recommended:",
        "for production\n*",
        "(optional): Whether to persist chat history in localStorage\n*",
        "(optional): Key used for storing chat history in localStorage. Default:",
        "*",
        "(optional): Enable internal debug logging to console. Useful for development\n*",
        "(optional): Maximum number of instruction steps allowed per conversation turn. Prevents infinite loops\n*",
        "(optional): Error handling configuration\n  *",
        "(optional): Whether to display errors to users in the chat UI\n  *",
        "(optional): Whether to automatically retry failed operations\n*",
        "(optional): Path to the runtime schema file. Default:",
        ". Can be a relative path from project root or an absolute URL\n\n## AutoUIFunction\n\nDefines a callable function that the LLM can invoke.",
        "typescript\nexport interface AutoUIFunction {\r\n  /** Prompt used by the LLM to decide when/how to call this function */\r\n  prompt: string;\r\n  /** Descriptive list of parameters (for documentation & LLM guidance) */\r\n  params?: Record<string, string>;\r\n  /** Description of the expected return type */\r\n  returns?: string;\r\n  /** The actual callable implementation (may be mocked) */\r\n  callFunc: Function;\r\n  /** Optional example usage or notes for LLM context */\r\n  exampleUsage?: string;\r\n  /** Optional tags for organization */\r\n  tags?: string[];\r\n  /** Whether the function can share data with the LLM for analysis */\r\n  canShareDataWithLLM?: boolean;\r\n}",
        "(required): Natural language description that tells the LLM when and how to use this function. This is crucial for the LLM's decision-making\n*",
        "(optional): Object describing function parameters. Keys are parameter names, values are type descriptions (e.g.,",
        ")\n*",
        "(optional): Description of what the function returns (e.g.,",
        "(required): The actual JavaScript function implementation. **Must return a value** (not void) so the LLM can analyze results\n*",
        "(optional): Example usage or notes to provide additional context to the LLM\n*",
        "(optional): Tags for organizing and categorizing functions\n*",
        "(optional): Whether the function's return data can be shared with the LLM for analysis. Set to",
        "for sensitive data\n\n**Important:** Functions must return a value (not",
        ") so the LLM can analyze the results.\n\n## AutoUIComponent\n\nDefines a React component that the LLM can render.",
        "typescript\nimport type { ComponentType } from 'react';\r\n\r\nexport interface AutoUIComponent {\r\n  /** Prompt describing what the component does (for LLM) */\r\n  prompt: string;\r\n  /** Human-readable parameter descriptions */\r\n  props?: Record<string, string>;\r\n  /** Actual React component reference */\r\n  callComponent: ComponentType<any>;\r\n  /** Default prop values for runtime or mock previews */\r\n  defaults?: Record<string, any>;\r\n  /** Callback definitions with handlers - combines metadata and implementation */\r\n  callbacks?: Record<string, AutoUICallback | Function>;\r\n  /** Example JSX usage (string literal for docs) */\r\n  exampleUsage?: string;\r\n  /** Optional category (product-display, checkout, etc.) */\r\n  category?: string;\r\n  /** Optional tags for search or grouping */\r\n  tags?: string[];\r\n}",
        "(required): Natural language description of what the component does and when to render it\n*",
        "(optional): Object describing component props. Keys are prop names, values are descriptions (e.g.,",
        "(required): Reference to the React component (function component or class component)\n*",
        "(optional): Default prop values. Helps the LLM understand the expected data structure\n*",
        "(optional): Callback definitions. Can be",
        "objects or direct function references\n*",
        "(optional): Example JSX usage as a string literal for documentation\n*",
        "(optional): Category for grouping related components (e.g.,",
        ",",
        "(optional): Tags for organizing and searching components\n\n## AutoUICallback\n\nDefines callbacks that components can use for user interactions.",
        "typescript\nexport interface AutoUICallback {\r\n  /** Description of what this callback does */\r\n  description: string;\r\n  /** When to use this callback */\r\n  whenToUse?: string;\r\n  /** Example usage */\r\n  example?: string;\r\n  /** The actual callback function implementation */\r\n  callFunc: Function;\r\n}",
        "(required): Description of what the callback does\n*",
        "(optional): Guidance on when to use this callback\n*",
        "(optional): Example usage\n*",
        "(required): The callback function implementation\n\n## AutoUIMetadata\n\nOptional metadata about your application.",
        "typescript\nexport interface AutoUIMetadata {\r\n  appName: string;\r\n  appVersion?: string;\r\n  author?: string;\r\n  createdAt?: string;\r\n  description?: string;\r\n  tags?: string[];\r\n}",
        "(required): Name of your application\n*",
        "(optional): Version string (e.g.,",
        "(optional): Author or team name\n*",
        "(optional): ISO 8601 timestamp of creation date\n*",
        "(optional): Detailed description of your application\n*",
        "(optional): Tags for categorization\n\n## Instruction Plan Types\n\nThese types describe the structure that the LLM response must have.\n\n### InstructionStep\n\nUnion type representing a single step in an instruction plan.",
        "typescript\nexport type InstructionStep = FunctionStep | ComponentStep | TextStep;",
        "### FunctionStep\n\nA step that calls a registered function.",
        "typescript\nexport type FunctionStep = {\r\n  type: 'function';\r\n  name: string;\r\n  params?: Record<string, any>;\r\n  assign?: string;\r\n  hasToShareDataWithLLM?: boolean;\r\n};",
        ": Must be",
        ": Name of the function to call (must match a key in",
        ": Parameters to pass to the function\n*",
        ": Optional variable name to assign the result to\n*",
        ": Whether to share the function's return data with the LLM\n\n### ComponentStep\n\nA step that renders a registered component.",
        "typescript\nexport type ComponentStep = {\r\n  type: 'component';\r\n  name: string;\r\n  props?: Record<string, any>;\r\n  /** Explicit callback references - maps callback prop names to callback names from component config */\r\n  callbacks?: Record<string, string>;\r\n};",
        ": Name of the component to render (must match a key in",
        ": Props to pass to the component\n*",
        ": Maps callback prop names to callback names from the component config\n\n### TextStep\n\nA step that displays text to the user.",
        "typescript\nexport type TextStep = {\r\n  type: 'text';\r\n  text: string;\r\n};",
        ": Text content to display\n\n### InstructionPlan\n\nThe complete plan structure returned by the LLM.",
        "typescript\nexport type InstructionPlan = {\r\n  type: 'sequence';\r\n  steps: InstructionStep[];\r\n};",
        ": Array of instruction steps to execute in order\n\n## Usage Example",
        "typescript\nimport type { AutoUIConfig, AutoUIFunction, AutoUIComponent } from '@autoai-ui/autoui';\r\n\r\nconst config: AutoUIConfig = {\r\n  appId: 'my-app',\r\n  llm: {\r\n    proxyUrl: 'https://autoui-chi.vercel.app',\r\n    sharedSecret: 'your-shared-secret',\r\n    appDescriptionPrompt: 'A task management application',\r\n  },\r\n  runtime: {\r\n    validateLLMOutput: true,\r\n    storeChatToLocalStorage: true,\r\n    maxSteps: 20,\r\n  },\r\n  functions: {\r\n    createTask: {\r\n      prompt: 'Create a new task',\r\n      params: {\r\n        title: 'string — task title',\r\n        description: 'string (optional) — task description',\r\n      },\r\n      returns: 'Task — the created task object',\r\n      callFunc: async ({ title, description }) => {\r\n        // Implementation\r\n        return { id: '1', title, description };\r\n      },\r\n      canShareDataWithLLM: true,\r\n    } satisfies AutoUIFunction,\r\n  },\r\n  components: {\r\n    TaskCard: {\r\n      prompt: 'Display a task card',\r\n      props: {\r\n        task: 'Task — task object to display',\r\n      },\r\n      callComponent: TaskCard,\r\n      defaults: {\r\n        task: { id: '', title: '', description: '' },\r\n      },\r\n    } satisfies AutoUIComponent,\r\n  },\r\n  metadata: {\r\n    appName: 'My Task App',\r\n    appVersion: '1.0.0',\r\n    description: 'A task management application',\r\n  },\r\n};"
      ]
    }
  },
  {
    "slug": "/runtime",
    "title": "Runtime & Debugging",
    "description": "Understand AUTOUI runtime behavior, debugging options, error handling, and execution limits.",
    "content": "The AUTOUI runtime orchestrates plan execution, manages conversation state, and handles errors. Understanding runtime behavior is crucial for debugging and optimizing your integration.\n\n## Runtime Overview\n\nThe runtime:\n\n1. Receives plans (structured JSON) from the LLM\n2. Validates plan structure (if enabled)\n3. Executes steps in order (function calls, component renders)\n4. Collects results and sends context back to the LLM\n5. Handles errors and retries\n6. Manages conversation state and persistence\n\n## Configuration\n\nRuntime behavior is controlled by the `runtime` section of your config:\n\n```tsx\nruntime: {\r\n  validateLLMOutput: true,\r\n  storeChatToLocalStorage: true,\r\n  localStorageKey: 'autoui_chat',\r\n  enableDebugLogs: true,\r\n  maxSteps: 20,\r\n  errorHandling: {\r\n    showToUser: true,\r\n    retryOnFail: false,\r\n  },\r\n}\n```\n\n## validateLLMOutput\n\nValidates that the LLM returns properly structured plan JSON.\n\n```tsx\nvalidateLLMOutput: true\n```\n\n**What it does:**\n\n* Checks that the response is valid JSON\n* Validates plan structure (steps, actions, parameters)\n* Rejects malformed plans before execution\n\n**When to enable:**\n\n* **Always in production** to prevent execution errors\n* Useful during development to catch LLM output issues early\n\n**When to disable:**\n\n* Only if you're debugging LLM output format issues\n* Not recommended for production\n\n## storeChatToLocalStorage\n\nPersists conversation history in the browser's localStorage.\n\n```tsx\nstoreChatToLocalStorage: true\r\nlocalStorageKey: 'autoui_chat'\n```\n\n**What it stores:**\n\n* Conversation messages (user and assistant)\n* Plan execution history\n* Function call results\n* Component render states\n\n**Benefits:**\n\n* Chat history persists across page reloads\n* Users can continue conversations\n* Useful for debugging (inspect stored state)\n\n**Considerations:**\n\n* localStorage has size limits (~5-10MB)\n* Sensitive data may be stored (be mindful of privacy)\n* Clear localStorage if you change config structure\n\n## enableDebugLogs\n\nLogs detailed execution information to the browser console.\n\n```tsx\nenableDebugLogs: true\n```\n\n**What gets logged:**\n\n* Incoming plans from LLM\n* Function call parameters and results\n* Component render props\n* Error messages and stack traces\n* Execution timing\n\n**Example console output:**\n\n```\n[AUTOUI] Plan received: { steps: [...] }\r\n[AUTOUI] Executing step 1: callFunction('createTask', { draft: {...} })\r\n[AUTOUI] Function result: { id: '123', title: '...' }\r\n[AUTOUI] Executing step 2: renderComponent('TaskCard', { task: {...} })\r\n[AUTOUI] Plan execution complete\n```\n\n**When to enable:**\n\n* During development and debugging\n* When troubleshooting execution issues\n* When optimizing performance\n\n**When to disable:**\n\n* In production (to reduce console noise)\n* When performance is critical\n\n## maxSteps\n\nLimits the number of steps in a single plan execution.\n\n```tsx\nmaxSteps: 20\n```\n\n**Purpose:**\n\n* Prevents infinite loops\n* Limits execution time\n* Controls resource usage\n\n**How it works:**\n\n* Each function call or component render counts as one step\n* If a plan exceeds `maxSteps`, execution stops\n* The runtime returns an error to the LLM\n\n**Choosing a value:**\n\n* **Simple apps**: 5-10 steps\n* **Medium complexity**: 10-20 steps\n* **Complex workflows**: 20-50 steps\n* **Very complex**: 50+ steps (use with caution)\n\n## errorHandling\n\nControls how errors are displayed and handled.\n\n```tsx\nerrorHandling: {\r\n  showToUser: true,\r\n  retryOnFail: false,\r\n}\n```\n\n### showToUser\n\nWhether to display error messages in the chat UI.\n\n```tsx\nshowToUser: true\n```\n\n**When enabled:**\n\n* Errors are shown as chat messages\n* Users see what went wrong\n* Useful for debugging and transparency\n\n**When disabled:**\n\n* Errors are only logged to console\n* Users see generic \"something went wrong\" messages\n* Better for production (hides technical details)\n\n### retryOnFail\n\nWhether to automatically retry failed function calls.\n\n```tsx\nretryOnFail: false\n```\n\n**When enabled:**\n\n* Failed function calls are retried once\n* Useful for transient errors (network, API timeouts)\n* May cause duplicate operations\n\n**When disabled:**\n\n* Errors stop execution immediately\n* LLM can decide to retry in the next turn\n* More predictable behavior\n\n## Debugging Workflow\n\n### 1. Enable Debug Logs\n\n```tsx\nruntime: {\r\n  enableDebugLogs: true,\r\n}\n```\n\n### 2. Open Browser Console\n\nOpen DevTools (F12) and check the Console tab for AUTOUI logs.\n\n### 3. Inspect Plans\n\nLook for `[AUTOUI] Plan received` logs to see what the LLM is generating.\n\n### 4. Check Function Calls\n\nVerify function parameters and return values:\n\n```\n[AUTOUI] Executing step 1: callFunction('createTask', { draft: {...} })\r\n[AUTOUI] Function result: { id: '123', ... }\n```\n\n### 5. Review Errors\n\nCheck for error messages and stack traces:\n\n```\n[AUTOUI] Error: Task not found\r\n[AUTOUI] Stack: ...\n```\n\n### 6. Inspect localStorage\n\nCheck stored conversation state:\n\n```javascript\n// In browser console\r\nconst stored = localStorage.getItem('autoui_chat')\r\nconsole.log(JSON.parse(stored))\n```\n\n## Common Issues\n\n### Plan Validation Fails\n\n**Symptom:** `[AUTOUI] Plan validation failed`\n\n**Causes:**\n\n* LLM returned malformed JSON\n* Plan structure doesn't match expected format\n* Network issues corrupted response\n\n**Solutions:**\n\n* Check LLM response in network tab\n* Verify `validateLLMOutput` is enabled\n* Review LLM provider status\n* Check proxy server logs\n\n### Function Execution Fails\n\n**Symptom:** `[AUTOUI] Error executing function: ...`\n\n**Causes:**\n\n* Function threw an exception\n* Invalid parameters passed\n* Missing dependencies or state\n\n**Solutions:**\n\n* Check function implementation\n* Verify parameters match function signature\n* Add error handling in functions\n* Check console for detailed error messages\n\n### maxSteps Exceeded\n\n**Symptom:** `[AUTOUI] Plan exceeded maxSteps limit`\n\n**Causes:**\n\n* Plan has too many steps\n* Infinite loop in function calls\n* LLM generating overly complex plans\n\n**Solutions:**\n\n* Increase `maxSteps` (if appropriate)\n* Review function prompts to avoid recursion\n* Simplify component structure\n* Break complex operations into smaller functions\n\n### localStorage Quota Exceeded\n\n**Symptom:** `QuotaExceededError` in console\n\n**Causes:**\n\n* Chat history too large\n* Too many stored conversations\n* localStorage near capacity\n\n**Solutions:**\n\n* Clear old chat history\n* Reduce `storeChatToLocalStorage` scope\n* Implement history cleanup\n* Use sessionStorage instead (cleared on tab close)\n\n## Performance Optimization\n\n### Reduce Debug Logging\n\n```tsx\nruntime: {\r\n  enableDebugLogs: false, // Disable in production\r\n}\n```\n\n### Limit Conversation History\n\nImplement history cleanup:\n\n```tsx\n// Clear old messages periodically\r\nif (chatHistory.length > 100) {\r\n  chatHistory = chatHistory.slice(-50) // Keep last 50 messages\r\n}\n```\n\n### Optimize Function Calls\n\n* Cache expensive operations\n* Batch multiple operations\n* Use async functions for I/O\n\n### Monitor Execution Time\n\nCheck console logs for timing information:\n\n```\n[AUTOUI] Plan execution time: 234ms\n```\n\n## Runtime Schema File\n\n### What is it?\n\nThe `.autoui-runtime-schema.json` file is automatically generated by the AutoUI Vite plugin during development builds. It contains a complete type-safe schema of your application's components and functions, extracted from your TypeScript source code.\n\n### Purpose\n\n1. **Type Safety**: Provides a complete type definition of all registered components and functions\n2. **LLM Context**: The schema is sent to the LLM proxy to help it understand your app's structure\n3. **Validation**: Used at runtime to validate LLM responses before executing functions or rendering components\n4. **Documentation**: Serves as a machine-readable documentation of your app's capabilities\n\n### Structure\n\nThe schema file has the following structure:\n\n```json\n{\r\n  \"appId\": \"app_1768313360453_dbptv83\",\r\n  \"version\": \"1.0.0\",\r\n  \"generatedAt\": \"2026-01-13T15:59:08.897Z\",\r\n  \"types\": {\r\n    \"Product\": {\r\n      \"type\": \"object\",\r\n      \"properties\": {\r\n        \"id\": { \"type\": \"string\", \"required\": true },\r\n        \"name\": { \"type\": \"string\", \"required\": true },\r\n        \"price\": { \"type\": \"number\", \"required\": true }\r\n      },\r\n      \"refs\": [\"string\", \"number\"]\r\n    }\r\n  },\r\n  \"components\": [\r\n    {\r\n      \"name\": \"ProductGallery\",\r\n      \"props\": {\r\n        \"products\": {\r\n          \"type\": \"Product[]\",\r\n          \"required\": true\r\n        }\r\n      }\r\n    }\r\n  ],\r\n  \"functions\": [\r\n    {\r\n      \"name\": \"fetchProducts\",\r\n      \"params\": {\r\n        \"params\": {\r\n          \"type\": \"FetchProductsParams\",\r\n          \"required\": false\r\n        }\r\n      },\r\n      \"returns\": {\r\n        \"type\": \"Promise<Product[]>\"\r\n      }\r\n    }\r\n  ]\r\n}\n```\n\n### How it's Generated\n\n1. **Type Extraction**: The plugin uses `ts-morph` to parse your TypeScript project\n2. **Registration Discovery**: It finds components and functions registered using `autouiRegisterComponentPropsSchema` and `autouiRegisterFunctionParamsSchema`\n3. **Type Resolution**: It extracts and resolves all TypeScript types, including:\n   * Primitives (string, number, boolean)\n   * Objects and interfaces\n   * Arrays\n   * Unions and intersections\n   * Generic types\n4. **Schema Creation**: It generates a JSON schema with complete type information\n\n### When is it Generated?\n\n* **Development**: Generated automatically on each build start\n* **Production**: Not generated; uses the committed schema file\n\n### Best Practices\n\n1. **Commit the Schema**: Always commit `.autoui-runtime-schema.json` to your repository\n2. **Version Control**: The schema should match your code—if you change component props or function signatures, regenerate the schema\n3. **CI/CD**: In production builds, the plugin skips generation and uses the committed schema\n4. **Review Changes**: Review schema changes in pull requests to ensure they match your code changes\n\n### Component Registration\n\nTo register components and functions for schema extraction, use the registration utilities:\n\n```typescript\nimport { autouiRegisterComponentPropsSchema, autouiRegisterFunctionParamsSchema } from '@autoai-ui/autoui';\r\n\r\n// Register a component's props type\r\nautouiRegisterComponentPropsSchema('ProductCard', ProductCardProps);\r\n\r\n// Register a function's parameter and return types\r\nautouiRegisterFunctionParamsSchema('fetchProducts', FetchProductsParams, Product[]);\n```\n\nThese registrations help the plugin extract accurate type information during build time.\n\n## Next Steps\n\n* Learn about functions: [Functions](/docs/functions)\n* Explore components: [Components](/docs/components)\n* Troubleshoot issues: [Troubleshooting](/docs/troubleshooting)\n* Read the [Complete Developer Guide](/docs/developer-guide) for comprehensive schema documentation\n",
    "_searchMeta": {
      "cleanContent": "the autoui runtime orchestrates plan execution manages conversation state and handles errors understanding runtime behavior is crucial for debugging and optimizing your integration runtime overview the runtime: receives plans structured json from the llm validates plan structure if enabled executes steps in order function calls component renders collects results and sends context back to the llm handles errors and retries manages conversation state and persistence configuration runtime behavior is controlled by the runtime section of your config: validatellmoutput validates that the llm returns properly structured plan json what it does: checks that the response is valid json validates plan structure steps actions parameters rejects malformed plans before execution when to enable: always in production to prevent execution errors useful during development to catch llm output issues early when to disable: only if you re debugging llm output format issues not recommended for production storechattolocalstorage persists conversation history in the browser s localstorage what it stores: conversation messages user and assistant plan execution history function call results component render states benefits: chat history persists across page reloads users can continue conversations useful for debugging inspect stored state considerations: localstorage has size limits 5-10mb sensitive data may be stored be mindful of privacy clear localstorage if you change config structure enabledebuglogs logs detailed execution information to the browser console what gets logged: incoming plans from llm function call parameters and results component render props error messages and stack traces execution timing example console output: when to enable: during development and debugging when troubleshooting execution issues when optimizing performance when to disable: in production to reduce console noise when performance is critical maxsteps limits the number of steps in a single plan execution purpose: prevents infinite loops limits execution time controls resource usage how it works: each function call or component render counts as one step if a plan exceeds maxsteps execution stops the runtime returns an error to the llm choosing a value: simple apps: 5-10 steps medium complexity: 10-20 steps complex workflows: 20-50 steps very complex: 50 steps use with caution errorhandling controls how errors are displayed and handled showtouser whether to display error messages in the chat ui when enabled: errors are shown as chat messages users see what went wrong useful for debugging and transparency when disabled: errors are only logged to console users see generic something went wrong messages better for production hides technical details retryonfail whether to automatically retry failed function calls when enabled: failed function calls are retried once useful for transient errors network api timeouts may cause duplicate operations when disabled: errors stop execution immediately llm can decide to retry in the next turn more predictable behavior debugging workflow enable debug logs open browser console open devtools f12 and check the console tab for autoui logs inspect plans look for autoui plan received logs to see what the llm is generating check function calls verify function parameters and return values: review errors check for error messages and stack traces: inspect localstorage check stored conversation state: common issues plan validation fails symptom: autoui plan validation failed causes: llm returned malformed json plan structure doesn t match expected format network issues corrupted response solutions: check llm response in network tab verify validatellmoutput is enabled review llm provider status check proxy server logs function execution fails symptom: autoui error executing function: causes: function threw an exception invalid parameters passed missing dependencies or state solutions: check function implementation verify parameters match function signature add error handling in functions check console for detailed error messages maxsteps exceeded symptom: autoui plan exceeded maxsteps limit causes: plan has too many steps infinite loop in function calls llm generating overly complex plans solutions: increase maxsteps if appropriate review function prompts to avoid recursion simplify component structure break complex operations into smaller functions localstorage quota exceeded symptom: quotaexceedederror in console causes: chat history too large too many stored conversations localstorage near capacity solutions: clear old chat history reduce storechattolocalstorage scope implement history cleanup use sessionstorage instead cleared on tab close performance optimization reduce debug logging limit conversation history implement history cleanup: optimize function calls cache expensive operations batch multiple operations use async functions for i o monitor execution time check console logs for timing information: runtime schema file what is it the autoui-runtime-schema json file is automatically generated by the autoui vite plugin during development builds it contains a complete type-safe schema of your application s components and functions extracted from your typescript source code purpose type safety: provides a complete type definition of all registered components and functions llm context: the schema is sent to the llm proxy to help it understand your app s structure validation: used at runtime to validate llm responses before executing functions or rendering components documentation: serves as a machine-readable documentation of your app s capabilities structure the schema file has the following structure: how it s generated type extraction: the plugin uses ts-morph to parse your typescript project registration discovery: it finds components and functions registered using autouiregistercomponentpropsschema and autouiregisterfunctionparamsschema type resolution: it extracts and resolves all typescript types including: primitives string number boolean objects and interfaces arrays unions and intersections generic types schema creation: it generates a json schema with complete type information when is it generated development: generated automatically on each build start production: not generated uses the committed schema file best practices commit the schema: always commit autoui-runtime-schema json to your repository version control: the schema should match your code if you change component props or function signatures regenerate the schema ci cd: in production builds the plugin skips generation and uses the committed schema review changes: review schema changes in pull requests to ensure they match your code changes component registration to register components and functions for schema extraction use the registration utilities: these registrations help the plugin extract accurate type information during build time next steps learn about functions: functions explore components: components troubleshoot issues: troubleshooting read the complete developer guide for comprehensive schema documentation",
      "headings": [
        "Runtime Overview",
        "Configuration",
        "validateLLMOutput",
        "storeChatToLocalStorage",
        "enableDebugLogs",
        "maxSteps",
        "errorHandling",
        "Debugging Workflow",
        "Common Issues",
        "Performance Optimization",
        "Runtime Schema File",
        "Next Steps"
      ],
      "keywords": [
        "runtime",
        "debugging",
        "validateLLMOutput",
        "maxSteps",
        "error handling",
        "localStorage",
        "Runtime Overview",
        "Configuration",
        "storeChatToLocalStorage",
        "enableDebugLogs",
        "errorHandling",
        "Debugging Workflow",
        "Common Issues",
        "Performance Optimization",
        "Runtime Schema File",
        "Next Steps",
        "What it does:",
        "When to enable:",
        "Always in production",
        "When to disable:",
        "What it stores:",
        "Benefits:",
        "Considerations:",
        "What gets logged:",
        "Example console output:",
        "Purpose:",
        "How it works:",
        "Choosing a value:",
        "Simple apps",
        "Medium complexity",
        "Complex workflows",
        "Very complex",
        "When enabled:",
        "When disabled:",
        "Symptom:",
        "Causes:",
        "Solutions:",
        "Type Safety",
        "LLM Context",
        "Validation",
        "Documentation",
        "Type Extraction",
        "Registration Discovery",
        "Type Resolution",
        "Schema Creation",
        "Development",
        "Production",
        "Commit the Schema",
        "Version Control",
        "CI/CD",
        "Review Changes",
        "tsx\nruntime: {\r\n  validateLLMOutput: true,\r\n  storeChatToLocalStorage: true,\r\n  localStorageKey: 'autoui_chat',\r\n  enableDebugLogs: true,\r\n  maxSteps: 20,\r\n  errorHandling: {\r\n    showToUser: true,\r\n    retryOnFail: false,\r\n  },\r\n}",
        "## validateLLMOutput\n\nValidates that the LLM returns properly structured plan JSON.",
        "tsx\nvalidateLLMOutput: true",
        "**What it does:**\n\n* Checks that the response is valid JSON\n* Validates plan structure (steps, actions, parameters)\n* Rejects malformed plans before execution\n\n**When to enable:**\n\n* **Always in production** to prevent execution errors\n* Useful during development to catch LLM output issues early\n\n**When to disable:**\n\n* Only if you're debugging LLM output format issues\n* Not recommended for production\n\n## storeChatToLocalStorage\n\nPersists conversation history in the browser's localStorage.",
        "tsx\nstoreChatToLocalStorage: true\r\nlocalStorageKey: 'autoui_chat'",
        "**What it stores:**\n\n* Conversation messages (user and assistant)\n* Plan execution history\n* Function call results\n* Component render states\n\n**Benefits:**\n\n* Chat history persists across page reloads\n* Users can continue conversations\n* Useful for debugging (inspect stored state)\n\n**Considerations:**\n\n* localStorage has size limits (~5-10MB)\n* Sensitive data may be stored (be mindful of privacy)\n* Clear localStorage if you change config structure\n\n## enableDebugLogs\n\nLogs detailed execution information to the browser console.",
        "tsx\nenableDebugLogs: true",
        "**What gets logged:**\n\n* Incoming plans from LLM\n* Function call parameters and results\n* Component render props\n* Error messages and stack traces\n* Execution timing\n\n**Example console output:**",
        "[AUTOUI] Plan received: { steps: [...] }\r\n[AUTOUI] Executing step 1: callFunction('createTask', { draft: {...} })\r\n[AUTOUI] Function result: { id: '123', title: '...' }\r\n[AUTOUI] Executing step 2: renderComponent('TaskCard', { task: {...} })\r\n[AUTOUI] Plan execution complete",
        "**When to enable:**\n\n* During development and debugging\n* When troubleshooting execution issues\n* When optimizing performance\n\n**When to disable:**\n\n* In production (to reduce console noise)\n* When performance is critical\n\n## maxSteps\n\nLimits the number of steps in a single plan execution.",
        "tsx\nmaxSteps: 20",
        "**Purpose:**\n\n* Prevents infinite loops\n* Limits execution time\n* Controls resource usage\n\n**How it works:**\n\n* Each function call or component render counts as one step\n* If a plan exceeds",
        ", execution stops\n* The runtime returns an error to the LLM\n\n**Choosing a value:**\n\n* **Simple apps**: 5-10 steps\n* **Medium complexity**: 10-20 steps\n* **Complex workflows**: 20-50 steps\n* **Very complex**: 50+ steps (use with caution)\n\n## errorHandling\n\nControls how errors are displayed and handled.",
        "tsx\nerrorHandling: {\r\n  showToUser: true,\r\n  retryOnFail: false,\r\n}",
        "### showToUser\n\nWhether to display error messages in the chat UI.",
        "tsx\nshowToUser: true",
        "**When enabled:**\n\n* Errors are shown as chat messages\n* Users see what went wrong\n* Useful for debugging and transparency\n\n**When disabled:**\n\n* Errors are only logged to console\n* Users see generic \"something went wrong\" messages\n* Better for production (hides technical details)\n\n### retryOnFail\n\nWhether to automatically retry failed function calls.",
        "tsx\nretryOnFail: false",
        "**When enabled:**\n\n* Failed function calls are retried once\n* Useful for transient errors (network, API timeouts)\n* May cause duplicate operations\n\n**When disabled:**\n\n* Errors stop execution immediately\n* LLM can decide to retry in the next turn\n* More predictable behavior\n\n## Debugging Workflow\n\n### 1. Enable Debug Logs",
        "tsx\nruntime: {\r\n  enableDebugLogs: true,\r\n}",
        "### 2. Open Browser Console\n\nOpen DevTools (F12) and check the Console tab for AUTOUI logs.\n\n### 3. Inspect Plans\n\nLook for",
        "logs to see what the LLM is generating.\n\n### 4. Check Function Calls\n\nVerify function parameters and return values:",
        "[AUTOUI] Executing step 1: callFunction('createTask', { draft: {...} })\r\n[AUTOUI] Function result: { id: '123', ... }",
        "### 5. Review Errors\n\nCheck for error messages and stack traces:",
        "[AUTOUI] Error: Task not found\r\n[AUTOUI] Stack: ...",
        "### 6. Inspect localStorage\n\nCheck stored conversation state:",
        "javascript\n// In browser console\r\nconst stored = localStorage.getItem('autoui_chat')\r\nconsole.log(JSON.parse(stored))",
        "## Common Issues\n\n### Plan Validation Fails\n\n**Symptom:**",
        "**Causes:**\n\n* LLM returned malformed JSON\n* Plan structure doesn't match expected format\n* Network issues corrupted response\n\n**Solutions:**\n\n* Check LLM response in network tab\n* Verify",
        "is enabled\n* Review LLM provider status\n* Check proxy server logs\n\n### Function Execution Fails\n\n**Symptom:**",
        "**Causes:**\n\n* Function threw an exception\n* Invalid parameters passed\n* Missing dependencies or state\n\n**Solutions:**\n\n* Check function implementation\n* Verify parameters match function signature\n* Add error handling in functions\n* Check console for detailed error messages\n\n### maxSteps Exceeded\n\n**Symptom:**",
        "**Causes:**\n\n* Plan has too many steps\n* Infinite loop in function calls\n* LLM generating overly complex plans\n\n**Solutions:**\n\n* Increase",
        "(if appropriate)\n* Review function prompts to avoid recursion\n* Simplify component structure\n* Break complex operations into smaller functions\n\n### localStorage Quota Exceeded\n\n**Symptom:**",
        "in console\n\n**Causes:**\n\n* Chat history too large\n* Too many stored conversations\n* localStorage near capacity\n\n**Solutions:**\n\n* Clear old chat history\n* Reduce",
        "scope\n* Implement history cleanup\n* Use sessionStorage instead (cleared on tab close)\n\n## Performance Optimization\n\n### Reduce Debug Logging",
        "tsx\nruntime: {\r\n  enableDebugLogs: false, // Disable in production\r\n}",
        "### Limit Conversation History\n\nImplement history cleanup:",
        "tsx\n// Clear old messages periodically\r\nif (chatHistory.length > 100) {\r\n  chatHistory = chatHistory.slice(-50) // Keep last 50 messages\r\n}",
        "### Optimize Function Calls\n\n* Cache expensive operations\n* Batch multiple operations\n* Use async functions for I/O\n\n### Monitor Execution Time\n\nCheck console logs for timing information:",
        "[AUTOUI] Plan execution time: 234ms",
        "## Runtime Schema File\n\n### What is it?\n\nThe",
        "file is automatically generated by the AutoUI Vite plugin during development builds. It contains a complete type-safe schema of your application's components and functions, extracted from your TypeScript source code.\n\n### Purpose\n\n1. **Type Safety**: Provides a complete type definition of all registered components and functions\n2. **LLM Context**: The schema is sent to the LLM proxy to help it understand your app's structure\n3. **Validation**: Used at runtime to validate LLM responses before executing functions or rendering components\n4. **Documentation**: Serves as a machine-readable documentation of your app's capabilities\n\n### Structure\n\nThe schema file has the following structure:",
        "json\n{\r\n  \"appId\": \"app_1768313360453_dbptv83\",\r\n  \"version\": \"1.0.0\",\r\n  \"generatedAt\": \"2026-01-13T15:59:08.897Z\",\r\n  \"types\": {\r\n    \"Product\": {\r\n      \"type\": \"object\",\r\n      \"properties\": {\r\n        \"id\": { \"type\": \"string\", \"required\": true },\r\n        \"name\": { \"type\": \"string\", \"required\": true },\r\n        \"price\": { \"type\": \"number\", \"required\": true }\r\n      },\r\n      \"refs\": [\"string\", \"number\"]\r\n    }\r\n  },\r\n  \"components\": [\r\n    {\r\n      \"name\": \"ProductGallery\",\r\n      \"props\": {\r\n        \"products\": {\r\n          \"type\": \"Product[]\",\r\n          \"required\": true\r\n        }\r\n      }\r\n    }\r\n  ],\r\n  \"functions\": [\r\n    {\r\n      \"name\": \"fetchProducts\",\r\n      \"params\": {\r\n        \"params\": {\r\n          \"type\": \"FetchProductsParams\",\r\n          \"required\": false\r\n        }\r\n      },\r\n      \"returns\": {\r\n        \"type\": \"Promise<Product[]>\"\r\n      }\r\n    }\r\n  ]\r\n}",
        "### How it's Generated\n\n1. **Type Extraction**: The plugin uses",
        "to parse your TypeScript project\n2. **Registration Discovery**: It finds components and functions registered using",
        "and",
        "3. **Type Resolution**: It extracts and resolves all TypeScript types, including:\n   * Primitives (string, number, boolean)\n   * Objects and interfaces\n   * Arrays\n   * Unions and intersections\n   * Generic types\n4. **Schema Creation**: It generates a JSON schema with complete type information\n\n### When is it Generated?\n\n* **Development**: Generated automatically on each build start\n* **Production**: Not generated; uses the committed schema file\n\n### Best Practices\n\n1. **Commit the Schema**: Always commit",
        "to your repository\n2. **Version Control**: The schema should match your code—if you change component props or function signatures, regenerate the schema\n3. **CI/CD**: In production builds, the plugin skips generation and uses the committed schema\n4. **Review Changes**: Review schema changes in pull requests to ensure they match your code changes\n\n### Component Registration\n\nTo register components and functions for schema extraction, use the registration utilities:",
        "typescript\nimport { autouiRegisterComponentPropsSchema, autouiRegisterFunctionParamsSchema } from '@autoai-ui/autoui';\r\n\r\n// Register a component's props type\r\nautouiRegisterComponentPropsSchema('ProductCard', ProductCardProps);\r\n\r\n// Register a function's parameter and return types\r\nautouiRegisterFunctionParamsSchema('fetchProducts', FetchProductsParams, Product[]);"
      ]
    }
  },
  {
    "slug": "/structure/deep/deeper/even-deeper",
    "title": "Introduction",
    "description": "This section provides an overview of Introduction.",
    "content": "Lorem ipsum dolor sit amet consectetur adipisicing elit. Numquam iste dolorum tempore consectetur explicabo tempora provident quia maxime, molestiae, facilis aperiam et, error illum vel ullam? Quis architecto dolore ullam\n\n* \\[x] Write the press release\n* \\[ ] Update the website\n* \\[ ] Contact the media\n\n| Syntax        | Description |   Test Text |\n| :------------ | :---------: | ----------: |\n| Header        |    Title    | Here's this |\n| Paragraph     |    Text     |    And more |\n| Strikethrough |             |    ~~Text~~ |\n",
    "_searchMeta": {
      "cleanContent": "lorem ipsum dolor sit amet consectetur adipisicing elit numquam iste dolorum tempore consectetur explicabo tempora provident quia maxime molestiae facilis aperiam et error illum vel ullam quis architecto dolore ullam x write the press release update the website contact the media syntax description test text:------------ :---------: ----------:header title here s thisparagraph text and morestrikethrough text",
      "headings": [],
      "keywords": []
    }
  },
  {
    "slug": "/structure/deep/deeper",
    "title": "Introduction",
    "description": "This section provides an overview of Introduction.",
    "content": "Lorem ipsum dolor sit amet consectetur adipisicing elit. Numquam iste dolorum tempore consectetur explicabo tempora provident quia maxime, molestiae, facilis aperiam et, error illum vel ullam? Quis architecto dolore ullam\n\n* \\[x] Write the press release\n* \\[ ] Update the website\n* \\[ ] Contact the media\n\n| Syntax        | Description |   Test Text |\r\n| :------------ | :---------: | ----------: |\r\n| Header        |    Title    | Here's this |\r\n| Paragraph     |    Text     |    And more |\r\n| Strikethrough |             |    ~~Text~~ |\n\n## Getting Started\n\nTo begin using the Documentation Template, follow these simple steps:\n\n* Start by cloning the repository to your local machine.\n\nLorem ipsum dolor sit amet consectetur adipisicing elit. Reprehenderit quae iure nulla deserunt dolore quam pariatur minus sapiente accusantium. Optio, necessitatibus sequi. Veritatis, aspernatur? Possimus quis repellat eum vitae eveniet.\n\n## Blockquotes\n\nBlockquotes are useful for emphasizing key points or quoting external sources:\n\n> \"Documentation is a love letter that you write to your future self.\" - Damian Conway\n\nFeel free to use blockquotes to highlight important information or quotes relevant to your documentation.\n\n## Code Examples with switch\n\nHere a custom tab component from shadcn ui is used.\n\n## Conclusion\n\nThank you for choosing the Documentation Template for your project. Whether you're documenting software, APIs, or processes, we're here to support you in creating clear and effective documentation. Happy documenting!\n\n## Tabs Example\n",
    "_searchMeta": {
      "cleanContent": "lorem ipsum dolor sit amet consectetur adipisicing elit numquam iste dolorum tempore consectetur explicabo tempora provident quia maxime molestiae facilis aperiam et error illum vel ullam quis architecto dolore ullam x write the press release update the website contact the media syntax description test text :------------ :---------: ----------: header title here s this paragraph text and more strikethrough text getting started to begin using the documentation template follow these simple steps: start by cloning the repository to your local machine lorem ipsum dolor sit amet consectetur adipisicing elit reprehenderit quae iure nulla deserunt dolore quam pariatur minus sapiente accusantium optio necessitatibus sequi veritatis aspernatur possimus quis repellat eum vitae eveniet blockquotes blockquotes are useful for emphasizing key points or quoting external sources: documentation is a love letter that you write to your future self - damian conway feel free to use blockquotes to highlight important information or quotes relevant to your documentation code examples with switch here a custom tab component from shadcn ui is used conclusion thank you for choosing the documentation template for your project whether you re documenting software apis or processes we re here to support you in creating clear and effective documentation happy documenting tabs example",
      "headings": [
        "Getting Started",
        "Blockquotes",
        "Code Examples with switch",
        "Conclusion",
        "Tabs Example"
      ],
      "keywords": [
        "Getting Started",
        "Blockquotes",
        "Code Examples with switch",
        "Conclusion",
        "Tabs Example"
      ]
    }
  },
  {
    "slug": "/structure/deep",
    "title": "Introduction",
    "description": "This section provides an overview of Introduction.",
    "content": "Lorem ipsum dolor sit amet consectetur adipisicing elit. Numquam iste dolorum tempore consectetur explicabo tempora provident quia maxime, molestiae, facilis aperiam et, error illum vel ullam? Quis architecto dolore ullam\n\n* \\[x] Write the press release\n* \\[ ] Update the website\n* \\[ ] Contact the media\n\n| Syntax        | Description |   Test Text |\r\n| :------------ | :---------: | ----------: |\r\n| Header        |    Title    | Here's this |\r\n| Paragraph     |    Text     |    And more |\r\n| Strikethrough |             |    ~~Text~~ |\n\n## Getting Started\n\nTo begin using the Documentation Template, follow these simple steps:\n\n* Start by cloning the repository to your local machine.\n\nLorem ipsum dolor sit amet consectetur adipisicing elit. Reprehenderit quae iure nulla deserunt dolore quam pariatur minus sapiente accusantium. Optio, necessitatibus sequi. Veritatis, aspernatur? Possimus quis repellat eum vitae eveniet.\n\n## Blockquotes\n\nBlockquotes are useful for emphasizing key points or quoting external sources:\n\n> \"Documentation is a love letter that you write to your future self.\" - Damian Conway\n\nFeel free to use blockquotes to highlight important information or quotes relevant to your documentation.\n\n## Code Examples with switch\n\nHere a custom tab component from shadcn ui is used.\n\n## Conclusion\n\nThank you for choosing the Documentation Template for your project. Whether you're documenting software, APIs, or processes, we're here to support you in creating clear and effective documentation. Happy documenting!\n\n## Tabs Example\n",
    "_searchMeta": {
      "cleanContent": "lorem ipsum dolor sit amet consectetur adipisicing elit numquam iste dolorum tempore consectetur explicabo tempora provident quia maxime molestiae facilis aperiam et error illum vel ullam quis architecto dolore ullam x write the press release update the website contact the media syntax description test text :------------ :---------: ----------: header title here s this paragraph text and more strikethrough text getting started to begin using the documentation template follow these simple steps: start by cloning the repository to your local machine lorem ipsum dolor sit amet consectetur adipisicing elit reprehenderit quae iure nulla deserunt dolore quam pariatur minus sapiente accusantium optio necessitatibus sequi veritatis aspernatur possimus quis repellat eum vitae eveniet blockquotes blockquotes are useful for emphasizing key points or quoting external sources: documentation is a love letter that you write to your future self - damian conway feel free to use blockquotes to highlight important information or quotes relevant to your documentation code examples with switch here a custom tab component from shadcn ui is used conclusion thank you for choosing the documentation template for your project whether you re documenting software apis or processes we re here to support you in creating clear and effective documentation happy documenting tabs example",
      "headings": [
        "Getting Started",
        "Blockquotes",
        "Code Examples with switch",
        "Conclusion",
        "Tabs Example"
      ],
      "keywords": [
        "Getting Started",
        "Blockquotes",
        "Code Examples with switch",
        "Conclusion",
        "Tabs Example"
      ]
    }
  },
  {
    "slug": "/structure",
    "title": "Structure",
    "description": "This section provides an overview of Introduction.",
    "content": "Lorem ipsum dolor sit amet consectetur adipisicing elit. Numquam iste dolorum tempore consectetur explicabo tempora provident quia maxime, molestiae, facilis aperiam et, error illum vel ullam? Quis architecto dolore ullam\n\n* \\[x] Write the press release\n* \\[ ] Update the website\n* \\[ ] Contact the media\n\n| Syntax        | Description |   Test Text |\r\n| :------------ | :---------: | ----------: |\r\n| Header        |    Title    | Here's this |\r\n| Paragraph     |    Text     |    And more |\r\n| Strikethrough |             |    ~~Text~~ |\n\n## Getting Started\n\nTo begin using the Documentation Template, follow these simple steps:\n\n* Start by cloning the repository to your local machine.\n\nLorem ipsum dolor sit amet consectetur adipisicing elit. Reprehenderit quae iure nulla deserunt dolore quam pariatur minus sapiente accusantium. Optio, necessitatibus sequi. Veritatis, aspernatur? Possimus quis repellat eum vitae eveniet.\n\n## Blockquotes\n\nBlockquotes are useful for emphasizing key points or quoting external sources:\n\n> \"Documentation is a love letter that you write to your future self.\" - Damian Conway\n\nFeel free to use blockquotes to highlight important information or quotes relevant to your documentation.\n\n## Code Examples with switch\n\nHere a custom tab component from shadcn ui is used.\n\n## Conclusion\n\nThank you for choosing the Documentation Template for your project. Whether you're documenting software, APIs, or processes, we're here to support you in creating clear and effective documentation. Happy documenting!\n",
    "_searchMeta": {
      "cleanContent": "lorem ipsum dolor sit amet consectetur adipisicing elit numquam iste dolorum tempore consectetur explicabo tempora provident quia maxime molestiae facilis aperiam et error illum vel ullam quis architecto dolore ullam x write the press release update the website contact the media syntax description test text :------------ :---------: ----------: header title here s this paragraph text and more strikethrough text getting started to begin using the documentation template follow these simple steps: start by cloning the repository to your local machine lorem ipsum dolor sit amet consectetur adipisicing elit reprehenderit quae iure nulla deserunt dolore quam pariatur minus sapiente accusantium optio necessitatibus sequi veritatis aspernatur possimus quis repellat eum vitae eveniet blockquotes blockquotes are useful for emphasizing key points or quoting external sources: documentation is a love letter that you write to your future self - damian conway feel free to use blockquotes to highlight important information or quotes relevant to your documentation code examples with switch here a custom tab component from shadcn ui is used conclusion thank you for choosing the documentation template for your project whether you re documenting software apis or processes we re here to support you in creating clear and effective documentation happy documenting",
      "headings": [
        "Getting Started",
        "Blockquotes",
        "Code Examples with switch",
        "Conclusion"
      ],
      "keywords": [
        "Getting Started",
        "Blockquotes",
        "Code Examples with switch",
        "Conclusion"
      ]
    }
  },
  {
    "slug": "/styling",
    "title": "ModalChat Styling",
    "description": "Customize ModalChat appearance, positioning, theming, and responsive behavior.",
    "content": "ModalChat provides a ready-to-use chat interface, but you can customize its appearance to match your application's design.\n\n## What Can Be Customized?\n\nModalChat supports customization through:\n\n* **Container styles**: Override default container classes\n* **Positioning**: Control where the chat button appears\n* **Theme tokens**: CSS variables for colors and spacing\n* **Responsive behavior**: Mobile and desktop layouts\n* **Custom trigger button**: Replace the default floating button\n\n## Basic Styling\n\n### Container Styles\n\nWrap ModalChat in a container and apply custom styles:\n\n```tsx\n<div className=\"autoui-wrapper\">\r\n  <ModalChat config={config} />\r\n</div>\n```\n\n```css\n.autoui-wrapper {\r\n  /* Override default positioning */\r\n  position: fixed;\r\n  bottom: 24px;\r\n  right: 24px;\r\n  z-index: 1000;\r\n}\r\n\r\n/* Customize the trigger button */\r\n.autoui-wrapper button {\r\n  background-color: #007bff;\r\n  border-radius: 50%;\r\n  width: 56px;\r\n  height: 56px;\r\n  box-shadow: 0 4px 12px rgba(0, 0, 0, 0.15);\r\n}\n```\n\n### Positioning\n\nControl where the chat button appears:\n\n```tsx\n<div style={{ position: 'fixed', bottom: '20px', right: '20px', zIndex: 1000 }}>\r\n  <ModalChat config={config} />\r\n</div>\n```\n\n**Common positions:**\n\n* Bottom-right (default): `bottom: 20px; right: 20px;`\n* Bottom-left: `bottom: 20px; left: 20px;`\n* Top-right: `top: 20px; right: 20px;`\n* Top-left: `top: 20px; left: 20px;`\n\n## Theming\n\n### CSS Variables\n\nIf ModalChat supports CSS variables, you can customize theme tokens:\n\n```css\n:root {\r\n  --autoui-primary: #007bff;\r\n  --autoui-background: #ffffff;\r\n  --autoui-text: #333333;\r\n  --autoui-border: #e0e0e0;\r\n  --autoui-radius: 8px;\r\n  --autoui-shadow: 0 4px 12px rgba(0, 0, 0, 0.15);\r\n}\r\n\r\n[data-theme=\"dark\"] {\r\n  --autoui-primary: #4a9eff;\r\n  --autoui-background: #1a1a1a;\r\n  --autoui-text: #ffffff;\r\n  --autoui-border: #333333;\r\n}\n```\n\n### Dark Mode\n\nModalChat should respect your app's theme. If you're using a theme provider (like `next-themes`), ensure ModalChat is wrapped in the provider:\n\n```tsx\nimport { ThemeProvider } from \"next-themes\"\r\n\r\nexport default function App() {\r\n  return (\r\n    <ThemeProvider attribute=\"class\" defaultTheme=\"system\">\r\n      <ModalChat config={config} />\r\n    </ThemeProvider>\r\n  )\r\n}\n```\n\n## Custom Trigger Button\n\nReplace the default floating button with your own:\n\n```tsx\nimport { useState } from 'react'\r\nimport { ModalChat } from \"@autoai-ui/autoui\"\r\n\r\nexport default function MyApp() {\r\n  const [isOpen, setIsOpen] = useState(false)\r\n\r\n  return (\r\n    <>\r\n      {/* Your custom trigger */}\r\n      <button \r\n        onClick={() => setIsOpen(true)}\r\n        className=\"my-custom-chat-button\"\r\n      >\r\n        Chat with AI\r\n      </button>\r\n\r\n      {/* ModalChat with controlled open state */}\r\n      <ModalChat \r\n        config={config} \r\n        open={isOpen}\r\n        onOpenChange={setIsOpen}\r\n      />\r\n    </>\r\n  )\r\n}\n```\n\n## Responsive Design\n\n### Mobile Optimization\n\nModalChat should be responsive by default, but you can add custom breakpoints:\n\n```css\n@media (max-width: 768px) {\r\n  .autoui-wrapper {\r\n    bottom: 16px;\r\n    right: 16px;\r\n  }\r\n\r\n  .autoui-wrapper button {\r\n    width: 48px;\r\n    height: 48px;\r\n  }\r\n}\n```\n\n### Full-Screen on Mobile\n\nMake the chat modal full-screen on mobile:\n\n```css\n@media (max-width: 768px) {\r\n  .autoui-modal {\r\n    width: 100vw;\r\n    height: 100vh;\r\n    max-width: 100vw;\r\n    max-height: 100vh;\r\n    border-radius: 0;\r\n  }\r\n}\n```\n\n## Advanced Customization\n\n### Custom Modal Container\n\nIf ModalChat accepts a `className` prop, you can style the modal container:\n\n```tsx\n<ModalChat \r\n  config={config}\r\n  className=\"my-custom-modal\"\r\n/>\n```\n\n```css\n.my-custom-modal {\r\n  border-radius: 16px;\r\n  box-shadow: 0 20px 60px rgba(0, 0, 0, 0.3);\r\n}\r\n\r\n.my-custom-modal .chat-header {\r\n  background: linear-gradient(135deg, #667eea 0%, #764ba2 100%);\r\n  color: white;\r\n  padding: 20px;\r\n}\n```\n\n### Z-Index Management\n\nEnsure ModalChat appears above other UI elements:\n\n```tsx\n<div style={{ zIndex: 9999 }}>\r\n  <ModalChat config={config} />\r\n</div>\n```\n\nOr use CSS:\n\n```css\n.autoui-wrapper {\r\n  z-index: 9999;\r\n}\n```\n\n## Styling Examples\n\n### Minimal Style\n\n```css\n.autoui-wrapper button {\r\n  background: #000;\r\n  color: #fff;\r\n  border: none;\r\n  border-radius: 50%;\r\n  width: 56px;\r\n  height: 56px;\r\n  cursor: pointer;\r\n  transition: transform 0.2s;\r\n}\r\n\r\n.autoui-wrapper button:hover {\r\n  transform: scale(1.1);\r\n}\n```\n\n### Branded Style\n\n```css\n.autoui-wrapper button {\r\n  background: linear-gradient(135deg, #667eea 0%, #764ba2 100%);\r\n  color: white;\r\n  border-radius: 50%;\r\n  width: 64px;\r\n  height: 64px;\r\n  box-shadow: 0 8px 24px rgba(102, 126, 234, 0.4);\r\n}\r\n\r\n.autoui-wrapper button::before {\r\n  content: \"💬\";\r\n  font-size: 24px;\r\n}\n```\n\n### Compact Style\n\n```css\n.autoui-wrapper button {\r\n  background: #007bff;\r\n  color: white;\r\n  border-radius: 12px;\r\n  width: auto;\r\n  height: 40px;\r\n  padding: 0 16px;\r\n  font-size: 14px;\r\n  font-weight: 500;\r\n}\n```\n\n## Best Practices\n\n<Note title=\"Performance\" type=\"warning\">\n  * Avoid heavy CSS animations that impact performance\n  * Use CSS transforms for animations (GPU-accelerated)\n  * Minimize re-renders with proper React patterns\n</Note>\n\n## Troubleshooting\n\n### Styles Not Applying\n\n* Check CSS specificity (use `!important` sparingly)\n* Verify class names match ModalChat's internal structure\n* Inspect the DOM to see actual class names\n* Ensure styles are loaded after ModalChat's default styles\n\n### Z-Index Issues\n\n* Increase z-index value\n* Check parent containers for `position` and `z-index`\n* Use browser DevTools to inspect stacking context\n\n### Dark Mode Not Working\n\n* Verify theme provider is wrapping ModalChat\n* Check CSS variable names match ModalChat's expectations\n* Inspect computed styles in DevTools\n* Ensure `data-theme` or `class` attributes are set correctly\n\n## Next Steps\n\n* Learn about functions: [Functions](/docs/functions)\n* Explore components registry: [Components](/docs/components)\n* Configure runtime: [Runtime & Debugging](/docs/runtime)\n",
    "_searchMeta": {
      "cleanContent": "modalchat provides a ready-to-use chat interface but you can customize its appearance to match your application s design what can be customized modalchat supports customization through: container styles: override default container classes positioning: control where the chat button appears theme tokens: css variables for colors and spacing responsive behavior: mobile and desktop layouts custom trigger button: replace the default floating button basic styling container styles wrap modalchat in a container and apply custom styles: positioning control where the chat button appears: common positions: bottom-right default : bottom: 20px right: 20px bottom-left: bottom: 20px left: 20px top-right: top: 20px right: 20px top-left: top: 20px left: 20px theming css variables if modalchat supports css variables you can customize theme tokens: dark mode modalchat should respect your app s theme if you re using a theme provider like next-themes ensure modalchat is wrapped in the provider: custom trigger button replace the default floating button with your own: responsive design mobile optimization modalchat should be responsive by default but you can add custom breakpoints: full-screen on mobile make the chat modal full-screen on mobile: advanced customization custom modal container if modalchat accepts a classname prop you can style the modal container: z-index management ensure modalchat appears above other ui elements: or use css: styling examples minimal style branded style compact style best practices avoid heavy css animations that impact performance use css transforms for animations gpu-accelerated minimize re-renders with proper react patterns troubleshooting styles not applying check css specificity use important sparingly verify class names match modalchat s internal structure inspect the dom to see actual class names ensure styles are loaded after modalchat s default styles z-index issues increase z-index value check parent containers for position and z-index use browser devtools to inspect stacking context dark mode not working verify theme provider is wrapping modalchat check css variable names match modalchat s expectations inspect computed styles in devtools ensure data-theme or class attributes are set correctly next steps learn about functions: functions explore components registry: components configure runtime: runtime debugging",
      "headings": [
        "What Can Be Customized?",
        "Basic Styling",
        "Theming",
        "Custom Trigger Button",
        "Responsive Design",
        "Advanced Customization",
        "Styling Examples",
        "Best Practices",
        "Troubleshooting",
        "Next Steps"
      ],
      "keywords": [
        "styling",
        "theming",
        "modalchat",
        "css",
        "customization",
        "dark mode",
        "What Can Be Customized?",
        "Basic Styling",
        "Theming",
        "Custom Trigger Button",
        "Responsive Design",
        "Advanced Customization",
        "Styling Examples",
        "Best Practices",
        "Troubleshooting",
        "Next Steps",
        "Container styles",
        "Positioning",
        "Theme tokens",
        "Responsive behavior",
        "Custom trigger button",
        "Common positions:",
        "tsx\n<div className=\"autoui-wrapper\">\r\n  <ModalChat config={config} />\r\n</div>",
        "",
        "css\n.autoui-wrapper {\r\n  /* Override default positioning */\r\n  position: fixed;\r\n  bottom: 24px;\r\n  right: 24px;\r\n  z-index: 1000;\r\n}\r\n\r\n/* Customize the trigger button */\r\n.autoui-wrapper button {\r\n  background-color: #007bff;\r\n  border-radius: 50%;\r\n  width: 56px;\r\n  height: 56px;\r\n  box-shadow: 0 4px 12px rgba(0, 0, 0, 0.15);\r\n}",
        "### Positioning\n\nControl where the chat button appears:",
        "tsx\n<div style={{ position: 'fixed', bottom: '20px', right: '20px', zIndex: 1000 }}>\r\n  <ModalChat config={config} />\r\n</div>",
        "**Common positions:**\n\n* Bottom-right (default):",
        "* Bottom-left:",
        "* Top-right:",
        "* Top-left:",
        "## Theming\n\n### CSS Variables\n\nIf ModalChat supports CSS variables, you can customize theme tokens:",
        "css\n:root {\r\n  --autoui-primary: #007bff;\r\n  --autoui-background: #ffffff;\r\n  --autoui-text: #333333;\r\n  --autoui-border: #e0e0e0;\r\n  --autoui-radius: 8px;\r\n  --autoui-shadow: 0 4px 12px rgba(0, 0, 0, 0.15);\r\n}\r\n\r\n[data-theme=\"dark\"] {\r\n  --autoui-primary: #4a9eff;\r\n  --autoui-background: #1a1a1a;\r\n  --autoui-text: #ffffff;\r\n  --autoui-border: #333333;\r\n}",
        "### Dark Mode\n\nModalChat should respect your app's theme. If you're using a theme provider (like",
        "), ensure ModalChat is wrapped in the provider:",
        "tsx\nimport { ThemeProvider } from \"next-themes\"\r\n\r\nexport default function App() {\r\n  return (\r\n    <ThemeProvider attribute=\"class\" defaultTheme=\"system\">\r\n      <ModalChat config={config} />\r\n    </ThemeProvider>\r\n  )\r\n}",
        "## Custom Trigger Button\n\nReplace the default floating button with your own:",
        "tsx\nimport { useState } from 'react'\r\nimport { ModalChat } from \"@autoai-ui/autoui\"\r\n\r\nexport default function MyApp() {\r\n  const [isOpen, setIsOpen] = useState(false)\r\n\r\n  return (\r\n    <>\r\n      {/* Your custom trigger */}\r\n      <button \r\n        onClick={() => setIsOpen(true)}\r\n        className=\"my-custom-chat-button\"\r\n      >\r\n        Chat with AI\r\n      </button>\r\n\r\n      {/* ModalChat with controlled open state */}\r\n      <ModalChat \r\n        config={config} \r\n        open={isOpen}\r\n        onOpenChange={setIsOpen}\r\n      />\r\n    </>\r\n  )\r\n}",
        "## Responsive Design\n\n### Mobile Optimization\n\nModalChat should be responsive by default, but you can add custom breakpoints:",
        "css\n@media (max-width: 768px) {\r\n  .autoui-wrapper {\r\n    bottom: 16px;\r\n    right: 16px;\r\n  }\r\n\r\n  .autoui-wrapper button {\r\n    width: 48px;\r\n    height: 48px;\r\n  }\r\n}",
        "### Full-Screen on Mobile\n\nMake the chat modal full-screen on mobile:",
        "css\n@media (max-width: 768px) {\r\n  .autoui-modal {\r\n    width: 100vw;\r\n    height: 100vh;\r\n    max-width: 100vw;\r\n    max-height: 100vh;\r\n    border-radius: 0;\r\n  }\r\n}",
        "## Advanced Customization\n\n### Custom Modal Container\n\nIf ModalChat accepts a",
        "prop, you can style the modal container:",
        "tsx\n<ModalChat \r\n  config={config}\r\n  className=\"my-custom-modal\"\r\n/>",
        "css\n.my-custom-modal {\r\n  border-radius: 16px;\r\n  box-shadow: 0 20px 60px rgba(0, 0, 0, 0.3);\r\n}\r\n\r\n.my-custom-modal .chat-header {\r\n  background: linear-gradient(135deg, #667eea 0%, #764ba2 100%);\r\n  color: white;\r\n  padding: 20px;\r\n}",
        "### Z-Index Management\n\nEnsure ModalChat appears above other UI elements:",
        "tsx\n<div style={{ zIndex: 9999 }}>\r\n  <ModalChat config={config} />\r\n</div>",
        "Or use CSS:",
        "css\n.autoui-wrapper {\r\n  z-index: 9999;\r\n}",
        "## Styling Examples\n\n### Minimal Style",
        "css\n.autoui-wrapper button {\r\n  background: #000;\r\n  color: #fff;\r\n  border: none;\r\n  border-radius: 50%;\r\n  width: 56px;\r\n  height: 56px;\r\n  cursor: pointer;\r\n  transition: transform 0.2s;\r\n}\r\n\r\n.autoui-wrapper button:hover {\r\n  transform: scale(1.1);\r\n}",
        "### Branded Style",
        "css\n.autoui-wrapper button {\r\n  background: linear-gradient(135deg, #667eea 0%, #764ba2 100%);\r\n  color: white;\r\n  border-radius: 50%;\r\n  width: 64px;\r\n  height: 64px;\r\n  box-shadow: 0 8px 24px rgba(102, 126, 234, 0.4);\r\n}\r\n\r\n.autoui-wrapper button::before {\r\n  content: \"💬\";\r\n  font-size: 24px;\r\n}",
        "### Compact Style",
        "css\n.autoui-wrapper button {\r\n  background: #007bff;\r\n  color: white;\r\n  border-radius: 12px;\r\n  width: auto;\r\n  height: 40px;\r\n  padding: 0 16px;\r\n  font-size: 14px;\r\n  font-weight: 500;\r\n}",
        "## Best Practices\n\n<Note title=\"Performance\" type=\"warning\">\n  * Avoid heavy CSS animations that impact performance\n  * Use CSS transforms for animations (GPU-accelerated)\n  * Minimize re-renders with proper React patterns\n</Note>\n\n## Troubleshooting\n\n### Styles Not Applying\n\n* Check CSS specificity (use",
        "sparingly)\n* Verify class names match ModalChat's internal structure\n* Inspect the DOM to see actual class names\n* Ensure styles are loaded after ModalChat's default styles\n\n### Z-Index Issues\n\n* Increase z-index value\n* Check parent containers for",
        "and",
        "* Use browser DevTools to inspect stacking context\n\n### Dark Mode Not Working\n\n* Verify theme provider is wrapping ModalChat\n* Check CSS variable names match ModalChat's expectations\n* Inspect computed styles in DevTools\n* Ensure",
        "or"
      ]
    }
  },
  {
    "slug": "/troubleshooting",
    "title": "Troubleshooting & FAQ",
    "description": "Common issues, solutions, and frequently asked questions about AUTOUI.",
    "content": "This guide covers common issues and solutions when working with AUTOUI.\n\n## Common Issues\n\n### ModalChat Not Rendering\n\n**Symptom:** ModalChat component doesn't appear on the page.\n\n**Possible causes:**\n\n* SSR mismatch (Next.js)\n* Missing dynamic import\n* CSS z-index issues\n* Config validation errors\n\n**Solutions:**\n\n### Proxy Server Connection Errors\n\n**Symptom:** `Failed to connect to proxy server` or CORS errors.\n\n**Possible causes:**\n\n* Proxy server not running\n* Incorrect `proxyUrl` in config\n* CORS not configured\n* Network/firewall issues\n\n**Solutions:**\n\n### LLM Not Responding\n\n**Symptom:** Chat messages are sent but no response is received.\n\n**Possible causes:**\n\n* Invalid OpenRouter API key\n* Proxy server not forwarding requests\n* LLM provider errors\n* Network timeouts\n\n**Solutions:**\n\n### Functions Not Being Called\n\n**Symptom:** Functions are registered but the LLM never calls them.\n\n**Possible causes:**\n\n* Unclear function prompts\n* Missing or incorrect params descriptions\n* LLM doesn't understand when to use the function\n\n**Solutions:**\n\n### Components Not Rendering\n\n**Symptom:** Components are registered but never rendered by the LLM.\n\n**Possible causes:**\n\n* Unclear component prompts\n* Missing or incorrect defaults\n* LLM doesn't understand when to render\n\n**Solutions:**\n\n### Plan Execution Errors\n\n**Symptom:** Plans are received but execution fails.\n\n**Possible causes:**\n\n* Invalid plan structure\n* Function errors\n* Missing state or dependencies\n* maxSteps exceeded\n\n**Solutions:**\n\n### Schema Not Generated\n\n**Symptom:** The `.autoui-runtime-schema.json` file is not being generated.\n\n**Possible causes:**\n\n* Vite plugin not added to `vite.config.ts`\n* Missing `tsconfig.json` or `tsconfig.app.json` file\n* Components/functions not registered using registration utilities\n* Plugin errors in console\n\n**Solutions:**\n\n### Schema File Out of Sync\n\n**Symptom:** The schema file doesn't match your code changes.\n\n**Possible causes:**\n\n* Schema file not regenerated after code changes\n* Schema file committed with outdated information\n* Production build using outdated schema\n\n**Solutions:**\n\n* Regenerate the schema by running your development build\n* Commit the updated schema file to version control\n* Ensure the schema file matches your current code before deploying\n* Review schema changes in pull requests to ensure they align with code changes\n\n## FAQ\n\n### Do I need a proxy server?\n\n**Answer:** Yes, for production. The proxy server keeps your OpenRouter API key secure. For development, you may be able to use direct API key mode (not recommended for production).\n\n### Can I use AUTOUI without React?\n\n**Answer:** No, AUTOUI is built specifically for React applications. ModalChat is a React component.\n\n### How do I customize the chat UI?\n\n**Answer:** See the [ModalChat Styling](/docs/styling) guide. You can customize positioning, theming, and appearance through CSS.\n\n### Can I use my own LLM provider?\n\n**Answer:** AUTOUI is designed to work with OpenRouter, which provides access to multiple LLM providers. You may be able to configure other providers through the proxy server.\n\n### How do I handle authentication?\n\n**Answer:** Authentication should be handled in your functions. For example:\n\n```tsx\nfunctions: {\n  getCurrentUser: {\n    prompt: 'Get the currently authenticated user.',\n    callFunc: () => {\n      return auth.getCurrentUser()\n    },\n  },\n}\n```\n\n### Can I stream responses?\n\n**Answer:** AUTOUI uses a request/response pattern, not streaming. Each turn sends a message and receives a complete response.\n\n### How do I clear chat history?\n\n**Answer:** Clear localStorage:\n\n```javascript\nlocalStorage.removeItem('autoui_chat')\n```\n\nOr change the `localStorageKey` in your config.\n\n### What's the difference between functions and components?\n\n**Answer:**\n\n* **Functions**: Execute JavaScript code, modify state, trigger side effects\n* **Components**: Render React UI elements dynamically\n\nSee [Functions](/docs/functions) and [Components](/docs/components) for details.\n\n### How do I debug plan execution?\n\n**Answer:** Enable debug logs:\n\n```tsx\nruntime: {\n  enableDebugLogs: true,\n}\n```\n\nThen check the browser console for detailed logs. See [Runtime & Debugging](/docs/runtime) for more.\n\n### Can I use TypeScript?\n\n**Answer:** Yes! AUTOUI is written in TypeScript and provides type definitions. Import types:\n\n```tsx\nimport { AutoUIConfig } from \"@autoai-ui/autoui\"\n```\n\n## Getting Help\n\nIf you're still experiencing issues:\n\n1. **Check the documentation**: Review relevant guides\n2. **Enable debug logs**: See [Runtime & Debugging](/docs/runtime)\n3. **Check browser console**: Look for error messages\n4. **Review proxy server logs**: Check server-side errors\n5. **Search GitHub issues**: Check for similar problems\n6. **Contact support**: Reach out via GitHub or project channels\n\n## Next Steps\n\n* Review configuration: [Installation & Configuration](/docs/installation)\n* Understand runtime: [Runtime & Debugging](/docs/runtime)\n* Learn about functions: [Functions](/docs/functions)\n* Explore components: [Components](/docs/components)\n",
    "_searchMeta": {
      "cleanContent": "this guide covers common issues and solutions when working with autoui common issues modalchat not rendering symptom: modalchat component doesn t appear on the page possible causes: ssr mismatch next js missing dynamic import css z-index issues config validation errors solutions: proxy server connection errors symptom: failed to connect to proxy server or cors errors possible causes: proxy server not running incorrect proxyurl in config cors not configured network firewall issues solutions: llm not responding symptom: chat messages are sent but no response is received possible causes: invalid openrouter api key proxy server not forwarding requests llm provider errors network timeouts solutions: functions not being called symptom: functions are registered but the llm never calls them possible causes: unclear function prompts missing or incorrect params descriptions llm doesn t understand when to use the function solutions: components not rendering symptom: components are registered but never rendered by the llm possible causes: unclear component prompts missing or incorrect defaults llm doesn t understand when to render solutions: plan execution errors symptom: plans are received but execution fails possible causes: invalid plan structure function errors missing state or dependencies maxsteps exceeded solutions: schema not generated symptom: the autoui-runtime-schema json file is not being generated possible causes: vite plugin not added to vite config ts missing tsconfig json or tsconfig app json file components functions not registered using registration utilities plugin errors in console solutions: schema file out of sync symptom: the schema file doesn t match your code changes possible causes: schema file not regenerated after code changes schema file committed with outdated information production build using outdated schema solutions: regenerate the schema by running your development build commit the updated schema file to version control ensure the schema file matches your current code before deploying review schema changes in pull requests to ensure they align with code changes faq do i need a proxy server answer: yes for production the proxy server keeps your openrouter api key secure for development you may be able to use direct api key mode not recommended for production can i use autoui without react answer: no autoui is built specifically for react applications modalchat is a react component how do i customize the chat ui answer: see the modalchat styling guide you can customize positioning theming and appearance through css can i use my own llm provider answer: autoui is designed to work with openrouter which provides access to multiple llm providers you may be able to configure other providers through the proxy server how do i handle authentication answer: authentication should be handled in your functions for example: can i stream responses answer: autoui uses a request response pattern not streaming each turn sends a message and receives a complete response how do i clear chat history answer: clear localstorage: or change the localstoragekey in your config what s the difference between functions and components answer: functions: execute javascript code modify state trigger side effects components: render react ui elements dynamically see functions and components for details how do i debug plan execution answer: enable debug logs: then check the browser console for detailed logs see runtime debugging for more can i use typescript answer: yes autoui is written in typescript and provides type definitions import types: getting help if you re still experiencing issues: check the documentation: review relevant guides enable debug logs: see runtime debugging check browser console: look for error messages review proxy server logs: check server-side errors search github issues: check for similar problems contact support: reach out via github or project channels next steps review configuration: installation configuration understand runtime: runtime debugging learn about functions: functions explore components: components",
      "headings": [
        "Common Issues",
        "FAQ",
        "Getting Help",
        "Next Steps"
      ],
      "keywords": [
        "troubleshooting",
        "faq",
        "errors",
        "debugging",
        "common issues",
        "Common Issues",
        "FAQ",
        "Getting Help",
        "Next Steps",
        "Symptom:",
        "Possible causes:",
        "Solutions:",
        "Answer:",
        "Functions",
        "Components",
        "Check the documentation",
        "Enable debug logs",
        "Check browser console",
        "Review proxy server logs",
        "Search GitHub issues",
        "Contact support",
        "Failed to connect to proxy server",
        "proxyUrl",
        ".autoui-runtime-schema.json",
        "vite.config.ts",
        "tsconfig.json",
        "tsconfig.app.json",
        "tsx\nfunctions: {\n  getCurrentUser: {\n    prompt: 'Get the currently authenticated user.',\n    callFunc: () => {\n      return auth.getCurrentUser()\n    },\n  },\n}",
        "### Can I stream responses?\n\n**Answer:** AUTOUI uses a request/response pattern, not streaming. Each turn sends a message and receives a complete response.\n\n### How do I clear chat history?\n\n**Answer:** Clear localStorage:",
        "javascript\nlocalStorage.removeItem('autoui_chat')",
        "Or change the",
        "in your config.\n\n### What's the difference between functions and components?\n\n**Answer:**\n\n* **Functions**: Execute JavaScript code, modify state, trigger side effects\n* **Components**: Render React UI elements dynamically\n\nSee [Functions](/docs/functions) and [Components](/docs/components) for details.\n\n### How do I debug plan execution?\n\n**Answer:** Enable debug logs:",
        "tsx\nruntime: {\n  enableDebugLogs: true,\n}",
        "Then check the browser console for detailed logs. See [Runtime & Debugging](/docs/runtime) for more.\n\n### Can I use TypeScript?\n\n**Answer:** Yes! AUTOUI is written in TypeScript and provides type definitions. Import types:",
        "tsx\nimport { AutoUIConfig } from \"@autoai-ui/autoui\""
      ]
    }
  }
]